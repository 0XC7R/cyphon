{"config_file": ".coveragerc", "source_files": [{"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "aggregator/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "aggregator/filters/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, null, 1, 1, null, null, 1, null, 1, null], "name": "aggregator/filters/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a |ModelAdmin| subclass for |Filters| and registers them with\nDjango Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom aggregator.filters.models import Filter\n\n\nclass FilterAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for |Filters|.\n    \"\"\"\n    list_display = [\n        'filter_object',\n        'filter_type',\n        'date_created',\n        'last_used',\n        'enabled',\n    ]\n    list_display_links = ['filter_object', ]\n    related_lookup_fields = {\n        'generic': [['content_type', 'object_id'], ],\n    }\n    readonly_fields = ['date_created', 'last_used', ]\n\nadmin.site.register(Filter, FilterAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, 1, 1, null, null, 1, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, null, 1, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, 1, 1, 1, null, 1, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, 1, null, 1, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, 1, 1, 1, 1, 1, null, 1, null, 1, 1, null, 1, null, null, null, null, null, null, 1, null], "name": "aggregator/filters/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a class for a search filter, which can refer to a |Followee|,\n|Location|, or |SearchTerm|.\n\"\"\"\n\n# third party\nfrom django.db import models\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.contrib.contenttypes.fields import GenericForeignKey\nfrom django.utils import timezone\n\n# local\nfrom cyphon.models import FindEnabledMixin\nfrom query.reservoirqueries.models import ReservoirQuery\nfrom target.followees.models import Followee\nfrom target.locations.models import Location\nfrom target.searchterms.models import SearchTerm\nfrom target.timeframes.models import TimeFrame\n\n\nclass FilterManager(models.Manager, FindEnabledMixin):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    @staticmethod\n    def _get_followee_accounts(followees):\n        \"\"\"\n        Takes a list of |Followees| and returns a list of |Accounts|\n        associated with the |Followees|.\n        \"\"\"\n        accounts = []\n\n        for followee in followees:\n            accts = list(followee.accounts.all())\n            accounts.extend(accts)\n\n        return accounts\n\n    def _find_enabled_filters_by_type(self, content_type):\n        \"\"\"\n        Takes a |ContentType| and returns a |QuerySet| of |Filters|\n        associated with that |ContentType|.\n        \"\"\"\n        enabled_filters = self.find_enabled()\n        return enabled_filters.filter(content_type=content_type)\n\n    def _get_targets_by_type(self):\n        \"\"\"\n        Gets Filters grouped by the class of their filter_object.\n        Returns a dict mapping target model types (e.g. Account,\n        Location, or SearchTerm) to a QuerySet of Filters\n        associated with those models.\n        \"\"\"\n        targets = (Followee, Location, SearchTerm)\n        content_types = ContentType.objects.get_for_models(*targets)\n        targets = {}\n\n        for key in content_types:\n            content_type = content_types[key]\n            filters = self._find_enabled_filters_by_type(content_type)\n            target_list = [obj.filter_object for obj in filters]\n            targets[key] = target_list\n\n        return targets\n\n    def _get_oldest_time_last_used(self):\n        \"\"\"\n        Returns a datetime for the oldest time an enabled Filter\n        was last used.\n        \"\"\"\n        default_queryset = self.get_queryset()\n        enabled_filters = default_queryset.filter(enabled=True)\n        aggregation = enabled_filters.aggregate(models.Min('last_used'))\n        return aggregation['last_used__min']\n\n    def _create_timeframe(self):\n        \"\"\"\n        Returns a TimeFrame with no end value and a start value\n        of the oldest time an enabled Filter was last used.\n        \"\"\"\n        oldest_time = self._get_oldest_time_last_used()\n        return TimeFrame(start=oldest_time)\n\n    def update_enabled_filters(self):\n        \"\"\"Update the :attr:`~filters.models.Filter.last_used` field of\n        enabled |Filters|.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        current_time = timezone.now()\n        self.find_enabled().update(last_used=current_time)\n\n    def create_reservoir_query(self):\n        \"\"\"Create a |ReservoirQuery| object using all enabled |Filters|.\n\n        Returns\n        -------\n        ReservoirQuery\n            A |ReservoirQuery| that uses all enabled |Filters|.\n\n        \"\"\"\n        # convert QuerySets to lists\n        targets = self._get_targets_by_type()\n        followees = targets[Followee]\n        locations = targets[Location]\n        searchterms = targets[SearchTerm]\n\n        timeframe = self._create_timeframe()\n\n        accounts = self._get_followee_accounts(followees)\n\n        query = ReservoirQuery(\n            accounts=accounts,\n            locations=locations,\n            searchterms=searchterms,\n            timeframe=timeframe,\n            trm_loc_logic='OR'\n        )\n\n        return query\n\n\nclass Filter(models.Model):\n    \"\"\"\n    Represents a search parameter used in ongoing background searches.\n\n    A |Filter| is a search parameter used for \"streaming\" background\n    searches of |Reservoirs|. A |Filter| can represent a |Followee|,\n    |Location|, or |SearchTerm|.\n\n    A |Filter| keeps track of the date it was created, the date\n    it was last used, and whether it is currently enabled.\n\n    Attributes\n    ----------\n    id : int\n        The primary key of the |Filter|.\n\n    content_type : ContentType\n        The |ContentType| of the :attr:`~Filter.filter_object`. Used to\n        define a generic relation.\n\n    object_id : int\n        The primary key of the :attr:`~Filter.filter_object`. Used to\n        define a generic relation.\n\n    filter_object : Followee, Location, or SearchTerm\n        The object defining the search parameter.\n\n    date_created : datetime\n        A |datetime| for when the |Filter| was created.\n\n    last_used : datetime\n        A |datetime| for when the |Filter| was last used in a query.\n\n    enabled : bool\n        ``True`` if the |Filter| should be included in background\n        searches. ``False`` otherwise.\n\n    Notes\n    -----\n    Because data for |Followees|, |Locations|, and |SearchTerms|\n    are modeled differently and are therefore stored in different\n    tables, a |Filter| stores the reference to this object in the\n    :attr:`~Filter.filter_object` field as a |GenericForeignKey|.\n\n    See also\n    --------\n    For further background, see Django's documentation on\n    `Generic Relations`_.\n\n    \"\"\"\n\n    # get the models that can serve as filters\n    _FOLLOWEE = models.Q(app_label='followees', model='followee')\n    _LOCATION = models.Q(app_label='locations', model='location')\n    _SEARCHTERM = models.Q(app_label='searchterms', model='searchterm')\n    _FILTERS = _FOLLOWEE | _LOCATION | _SEARCHTERM\n\n    content_type = models.ForeignKey(ContentType, limit_choices_to=_FILTERS)\n    object_id = models.PositiveIntegerField()\n    filter_object = GenericForeignKey()\n    date_created = models.DateTimeField(auto_now_add=True)\n    last_used = models.DateTimeField(auto_now=True)\n    enabled = models.BooleanField(default=True)\n\n    objects = FilterManager()\n\n    def __str__(self):\n        return \"%s (%s)\" % (self.filter_object, self.filter_type)\n\n    @property\n    def filter_type(self):\n        \"\"\"\n        |str|: the lowercase name of the model for the type\n        of filter, which can be either a |Followee|, |Location|,\n        or |SearchTerm|.\n        \"\"\"\n        return self.content_type.model\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, 1, null, null, 1, null, 1, null], "name": "aggregator/filters/services.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a function for creating and processing queries from |Filters|.\n\"\"\"\n\n# local\nfrom aggregator.filters.models import Filter\nfrom aggregator.reservoirs.models import Reservoir\nfrom aggregator.pumproom.pumproom import PumpRoom\n\n\ndef execute_filter_queries():\n    \"\"\"\n    Executes periodic background searches with enabled |Filters|.\n\n    Gathers enabled |Filters|, creates a query for each enabled\n    |Reservoir|, and sends the queries to the |Reservoir|.\n\n    Returns\n    -------\n    |list| of |Invoices|\n        |Invoices| recording the responses of the API calls made.\n\n    \"\"\"\n    # ReservoirQuery object created from enabled Filters\n    query = Filter.objects.create_reservoir_query()\n\n    # QuerySet containing enabled Reservoirs\n    active_reservoirs = Reservoir.objects.find_enabled()\n\n    pumproom = PumpRoom(reservoirs=active_reservoirs, task='BKGD_SRCH')\n\n    # update last_used fields of enabled Filters\n    Filter.objects.update_enabled_filters()\n\n    return pumproom.get_results(query)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "aggregator/funnels/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1], "name": "aggregator/funnels/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a |ModelAdmin| subclass for |Funnels| and registers them with\nDjango Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n#local\nfrom aggregator.funnels.models import Funnel\n\n\nclass FunnelAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for |Funnels|.\n    \"\"\"\n    pass\n\n\nadmin.site.register(Funnel, FunnelAdmin)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, 1, 1, 1, null, 1, null, 1, null, null, null, 1, null, 1, 1], "name": "aggregator/funnels/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a |Funnel| class, which funnels data from a |Pipe| through a\n|DataCondenser| and into a |Bottle|.\n\nNotes\n-----\n\nThe |Funnel| class provides an intermediary model that controls the\nmany-to-many relationship between |DataCondensers| and |Pipes|.\nIt ensures that each |Pipe| is connected to only one |DataCondenser|\nper |Bottle|.\n\n**Rationale:**\n\nIn most cases, different |Pipes| will return data in different forms\n(e.g., a tweet vs. an Instagram post). Thus, |Pipes| usually need\ndifferent |DataCondensers| to store data in a particular |Bottle|.\nIn some cases, however, |Pipes| may return data using the same model\n(e.g., tweets returned by Twitter's Search API and Public Streams API).\nIn these cases, |Pipes| may use the same |DataCondenser| to store data\nin a |Bottle|.\n\nFrom the reverse persective, data from the same |Pipe| can be modeled\nin different ways (i.e., stored in different |Bottles|). Thus, it is\npossible for a |Pipe| to have more than one |Bottle| associated with it.\n\n|DataCondensers| therefore have a many-to-one relationship with |Bottles|\nand a many-to-many relationship with |Pipes|.\n\n|Funnels| control these relationships to ensure that data flowing from\na |Pipe| have only one way to make into a given |Bottle|.\n\n\"\"\"\n\n# standard library\nimport logging\n\n# third party\nfrom django.db import models\nfrom django.core.exceptions import ObjectDoesNotExist\n\n# local\nfrom aggregator.pipes.models import Pipe\nfrom bottler.bottles.models import Bottle\nfrom sifter.datasifter.datacondensers.models import DataCondenser\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass FunnelManager(models.Manager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def get_by_natural_key(self, bottle_name, pipe_natural_key):\n        \"\"\"\n        Allows retrieval of a |Funnel| by its natural key instead of its\n        primary key.\n\n        Parameters\n        ----------\n\n        bottle_id : str\n            The primary key of the |Bottle| associated with the |Funnel|. \n\n        pipe_natural_key : list of str\n\n\n        \"\"\"\n        pipe = Pipe.objects.get_by_natural_key(*pipe_natural_key)\n        try:\n            return self.get(bottle__name=bottle_name, pipe=pipe.pk)\n        except ObjectDoesNotExist:\n            LOGGER.error('%s for Bottle \"%s\" and Pipe %s does not exist',\n                         self.model.__name__, bottle_name, pipe.pk)\n\n    def get_condenser(self, bottle_name, pipe_natural_key):\n        \"\"\"\n        Gets the |DataCondenser| used for saving data from the specified\n        |Pipe| in the specified |Bottle|.\n        \"\"\"\n        funnel = self.get_by_natural_key(bottle_name, pipe_natural_key)\n        return funnel.condenser\n\n    def get_bottle(self, condenser_id, pipe_id):\n        \"\"\"\n        Takes the primary key of a |DataCondenser| and gets the primary\n        key of the |Bottle| associated with it.\n        \"\"\"\n        funnel = self.get(condenser=condenser_id, pipe=pipe_id)\n        return funnel.bottle\n\n\nclass Funnel(models.Model):\n    \"\"\"\n    An intermediary model that funnels data from |Pipes| into a\n    |DataCondenser|. This class controls the many-to-many relationship\n    between |DataCondensers| and |Pipes|. It ensures that each |Pipe|\n    uses only one |DataCondenser| per |Bottle|.\n    \"\"\"\n    pipe = models.ForeignKey(Pipe)\n    bottle = models.ForeignKey(Bottle)\n    condenser = models.ForeignKey(DataCondenser)\n\n    objects = FunnelManager()\n\n    class Meta:\n        \"\"\"\n        Metadata options for a Django Model.\n        \"\"\"\n        unique_together = ('bottle', 'pipe')\n\n    def __str__(self):\n        return \"%s <- %s\" % (self.bottle, self.pipe)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "aggregator/invoices/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null], "name": "aggregator/invoices/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a |ModelAdmin| subclass for |Invoices| and registers them with\nDjango Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom .models import Invoice\n\n\nclass InvoiceAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for |Invoices|.\n    \"\"\"\n    readonly_fields = [\n        'stamp',\n        'query_str',\n        'task',\n    ]\n    fieldsets = (\n        (None, {\n            'fields':  [\n                'task',\n                'stamp',\n                'query_str',\n            ],\n            'classes': ('collapse', 'pre'),\n        }),\n    )\n\n\nadmin.site.register(Invoice, InvoiceAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, 0, null, 1, null, null, null, 0, 0, null, 1, null], "name": "aggregator/invoices/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines an |Invoice| class for logging API calls to |Reservoirs|.\n\"\"\"\n\n# standard library\nfrom collections import OrderedDict\nimport json\n\n# third party\nfrom django.contrib.postgres.fields.jsonb import JSONField\nfrom django.db import models\n\n# local\nfrom ambassador.records.models import Record, RecordManager\nfrom cyphon.choices import SEARCH_TASK_CHOICES\n\n\nclass Invoice(Record):\n    \"\"\"\n    Provides a record of an API call, including the |Stamp| associated\n    with the call and the |ReservoirQuery| that was sent.\n\n    Attributes\n    ----------\n\n    stamp : Stamp\n        The |Stamp| associated with the API call.\n\n    query : dict\n        A |dict| representation of the |ReservoirQuery| sent to the API.\n\n    task : str\n\n\n    \"\"\"\n    query = JSONField(default=dict)\n    task = models.CharField(max_length=20, choices=SEARCH_TASK_CHOICES)\n\n    objects = RecordManager()\n\n    def __str__(self):\n        return '%s: %s' % (self.task, self.stamp)\n\n    def query_str(self):\n        \"\"\"\n        Returns a JSON string representing the :attr:`~Invoice.query`.\n        \"\"\"\n        ordered_query = OrderedDict(sorted(self.query.items()))\n        return json.dumps(ordered_query, indent=4)\n\n    query_str.short_description = 'query'\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "aggregator/pipes/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, 1, 1, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, null, null, null, null, null, null, 1, 1, null], "name": "aggregator/pipes/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a |ModelAdmin| subclass for |Pipes| and registers them with\nDjango Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom aggregator.pipes.models import Pipe, PipeSpecSheet\n\n\nclass PipeSpecSheetInLineAdmin(admin.StackedInline):\n    \"\"\"\n    Customizes inline admin forms for |PipeSpecsheets|.\n    \"\"\"\n    model = PipeSpecSheet\n    classes = ('grp-open', )\n    inline_classes = ('grp-open', )\n    max_num = 1\n    min_num = 1\n    verbose_name_plural = 'spec sheet'\n    can_delete = False\n\n\nclass PipeSpecSheetAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for |PipeSpecsheets|.\n    \"\"\"\n    pass\n\n\nclass PipeAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for |Pipes|.\n    \"\"\"\n    inlines = [PipeSpecSheetInLineAdmin, ]\n    fields = [\n        'platform',\n        'api_module',\n        'api_class',\n        'visa_required',\n    ]\n\nadmin.site.register(Pipe, PipeAdmin)\nadmin.site.register(PipeSpecSheet, PipeSpecSheetAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, 1, null, null, null, 1, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, 1, null, null, null, null, null, 1, null, null, null, 1, null, null, null, 1, null, null, null, 1, null, null, null, 1, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, 1, 1], "name": "aggregator/pipes/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a class for a data platform's API. Stores information on\nan API's rate limits and parameter limits. Also stores information on\nhow to access the specific class needed to handle a query to the API.\n\"\"\"\n\n# standard library\nimport logging\n\n# third party\nfrom django.db import models\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom aggregator.reservoirs.models import Reservoir\nfrom ambassador.endpoints.models import Endpoint, EndpointManager\nfrom cyphon.choices import LOCATION_FORMAT_CHOICES, LOGIC_CHOICES\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass Pipe(Endpoint):\n    \"\"\"\n    Specifies the module and |Faucet| class that should be used to\n    access an API endpoint of a |Reservoir|, such as Twitter.\n\n    A |Pipe| can have a |PipeSpecSheet| that details information on the\n    API's parameter limits.\n\n    Since a |Reservoir| may be accessed using more than one API (e.g.,\n    Twitter Search API vs. Twitter Public API), |Pipes| have a\n    many-to-one relationship with |Reservoirs|.\n\n    Attributes\n    ----------\n    platform : |Reservoir|\n        The data platform which the API endpoint accesses.\n\n    \"\"\"\n    platform = models.ForeignKey(Reservoir)\n\n    objects = EndpointManager()\n\n    class Meta:\n        \"\"\"\n        Metadata options.\n        \"\"\"\n        unique_together = ('platform', 'api_class')\n\n    def get_specsheet(self):\n        \"\"\"\n        Returns the Specs for the Pipe if it has them.\n        \"\"\"\n        if hasattr(self, 'specsheet'):\n            return self.specsheet\n\n\nclass PipeSpecSheet(models.Model):\n    \"\"\"\n    Contains info on search parameter formats and limits.\n\n    Attributes:\n        pipe: the ForeignKey for the Pipe with which the SpecSheet is associated\n        streaming: a Boolean indicating whether the API endpoint is for streaming\n        searchterms_limit: the maximum number of search terms allowed in a query\n        followees_limit: the maximum number of user accounts that can be\n            included in a query\n        locations_limit: the maximum number of locations that can be searched\n            in a query\n        location_format: whether the API takes a location as a bounding box or\n            a search radius\n        radius_limit_km: the maximum radius of a search area accepted,\n            in kilometers\n        combine_trm_dt: a Boolean indicating whether timeframes count toward\n            the search term limit; if true, start datetime and end datetime each\n            count as a search term\n        combine_trm_fol: a Boolean indicating whether search terms and followees\n            share the same parameter space and therefore the same limit;\n            if true, also indicates than terms and followees can be joined with\n            an \"OR\" operator if one is available\n        combine_trm_loc: a Boolean indicating whether search terms and locations\n            share the same parameter space and therefore the same limit;\n            if true, also indicates than terms and locations can be joined with\n            an \"OR\" operator if one is available\n        combine_trm_opr: a Boolean indicating whether logical operators count\n            toward the search term limit\n        accepts_phrases: whether the API accepts phrases (if False,\n            only takes keywords)\n        trm_trm_logic: a logical \"AND\" or \"OR\" operator indicating how multiple\n            terms are evaluated in a query (i.e., with an intersection vs.\n            a union of results)\n        trm_fol_logic: a logical \"AND\" or \"OR\" operator indicating how terms and\n            followees are evaluated in a query (i.e., with an intersection vs.\n            a union of results)\n        trm_loc_logic: a logical \"AND\" or \"OR\" operator indicating how terms and\n            locations are evaluated in a query (i.e., with an intersection vs.\n            a union of results)\n        OR_operator: a string that the API uses as an \"OR\" operator; can be used\n            to join arguments in the search terms parameter space\n        NOT_operator: a string that the API uses as a \"NOT\" operator\n\n        #TODO(LH): add validator that makes sure logic fields have values if limits are > 1\n    \"\"\"\n    pipe = models.OneToOneField(\n        Pipe,\n        primary_key=True,\n        related_name='specsheet'\n    )\n\n    streaming = models.BooleanField(default=False)\n    searchterms_limit = models.IntegerField(\n        blank=True,\n        null=True,\n        verbose_name=_('Search-term limit'),\n        help_text=_('Maximum number of search terms in a query.')\n    )\n    followees_limit = models.IntegerField(\n        blank=True,\n        null=True,\n        verbose_name=_('Followee limit'),\n        help_text=_('Maximum number of user accounts in a query.')\n    )\n    locations_limit = models.IntegerField(\n        blank=True,\n        null=True,\n        verbose_name=_('Location limit'),\n        help_text=_('Maximum number of user accounts in a query.')\n    )\n    location_format = models.CharField(\n        max_length=6,\n        choices=LOCATION_FORMAT_CHOICES\n    )\n    radius_limit_km = models.FloatField(\n        blank=True,\n        null=True,\n        verbose_name=_('Radius limit in km'),\n        help_text=_('Maximum radius of a search area in kilometers')\n    )\n    combine_trm_dt = models.BooleanField(\n        default=False,\n        verbose_name=_('Time frames count toward search-term limit')\n    )\n    combine_trm_fol = models.BooleanField(\n        default=False,\n        verbose_name=_('Followees count toward search-term limit')\n    )\n    combine_trm_loc = models.BooleanField(\n        default=False,\n        verbose_name=_('Locations count toward search-term limit')\n    )\n    combine_trm_opr = models.BooleanField(\n        default=False,\n        verbose_name=_('Logical operators count toward search-term limit')\n    )\n    accepts_phrases = models.BooleanField(default=True)\n    trm_trm_logic = models.CharField(\n        max_length=6,\n        blank=True,\n        null=True,\n        choices=LOGIC_CHOICES,\n        verbose_name=_('Term-Term logic'),\n        help_text=_('Operator used to combine search terms.')\n    )\n    trm_fol_logic = models.CharField(\n        max_length=6,\n        blank=True,\n        null=True,\n        choices=LOGIC_CHOICES,\n        verbose_name=_('Term-Followee logic'),\n        help_text=_('Operator used to combine search terms and followees.')\n    )\n    trm_loc_logic = models.CharField(\n        max_length=6,\n        blank=True,\n        null=True,\n        choices=LOGIC_CHOICES,\n        verbose_name=_('Term-Location logic'),\n        help_text=_('Operator used to combine search terms and locations.')\n    )\n    OR_operator = models.CharField(\n        max_length=10,\n        blank=True,\n        null=True,\n        help_text=_('String used for an \"OR\" operator, if applicable.')\n    )\n    NOT_operator = models.CharField(\n        max_length=10,\n        blank=True,\n        null=True,\n        help_text=_('String used for a \"NOT\" operator, if applicable.')\n    )\n\n    def __str__(self):\n        return str(self.pipe)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "aggregator/plumbers/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null], "name": "aggregator/plumbers/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclass for Plumbers and registers them with Django Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom aggregator.plumbers.models import Plumber\n\n\nclass PlumberAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Plumbers.\n    \"\"\"\n    pass\n\n\nadmin.site.register(Plumber, PlumberAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null], "name": "aggregator/plumbers/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines classes for handling API keys and API call counts.\n\"\"\"\n\n# third party\nfrom django.db import models\n\n# local\nfrom aggregator.pipes.models import Pipe\nfrom ambassador.emissaries.models import Emissary, EmissaryManager\n\n\nclass Plumber(Emissary):\n    \"\"\"\n    Handles an API key or token (KeySet) for a set of users of a Pipe.\n    Uses a Meter to keep track of the number of calls made using that\n    API key.\n    \"\"\"\n    endpoints = models.ManyToManyField(\n        Pipe,\n        verbose_name='pipes',\n        related_name='emissaries',\n        related_query_name='emissary'\n    )\n\n    objects = EmissaryManager()\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "aggregator/pumproom/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, 1, null, 1, null, null, null, 1, null, 1, null, null, null, 1, null, 1, null, null, null, 1, null, 1, null, null, null, 1, null, 1, null, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, null, 1, 1, null, 1, 1, 1, 1, null, null, 1, null, 1, null, null, null, null, 1, null, 1, 1, null, 1, null, null, null, null, null, 1, null, 1, 1, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, 1, null, null, null, null, null, null, null, null, 1, null, null, 1, null, 1, null, null, 1, null, null, 1, null, 1, null, null, 1, null, 1, null, null, 1, null, null, 1, null, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, null, 1, null, 1, 1, 1, 1, null, 1, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, null, null, 1, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, 1, 1, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, 1, null, null, null, null, 1, 1, null, 1, 1, 1, null, 1, null, null, 1, null, 1, null, null, null, null, null, null, null, 1, 1, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, 1, null, null, 1, null, 1, null, 1, null, null, 1, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, null, 1, null, null, null, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, 1, null, 1, null, 1, null, 1, 1, null, 1, 1, null, 1, null, 1, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, 1, null, 1, null, null, 1, null, null, 1, 1, 1, 1, null, 1, null, 1, null, 1, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, 1, null, 1, null, 1, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, null, 1, null, 1, null, null, null, 1, null, 1, null, null, null, 1, null, 1, null, null, null, 1, null], "name": "aggregator/pumproom/engineer.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Engineer class for formatting a query to conform to API limits.\n\"\"\"\n\n# standard library\nfrom copy import deepcopy\n\n# local\nfrom utils.parserutils import parserutils\n\n\nclass Engineer(object):\n    \"\"\"\n    Examines API limits (Specs) for a Pipe and ensures that a query conforms\n    to those limits. May refactor the original query into a set of queries\n    if necessary.\n\n    Attributes:\n        _query: a ReservoirQuery object\n        _specs: a Specs object\n\n    \"\"\"\n\n    def __init__(self, query, specs):\n        self._query = query\n        self._specs = specs\n\n    def _get_spec(self, name):\n        \"\"\"\n        Takes the name of a Specs attribute and returns its value.\n        Returns None if the attribute does not exist.\n        \"\"\"\n        return getattr(self._specs, name, None)\n\n    def _get_query_trm_loc_logic(self):\n        \"\"\"\n\n        \"\"\"\n        return self._query.trm_loc_logic\n\n    def _remove_negated_terms(self):\n        \"\"\"\n\n        \"\"\"\n        return self._query.remove_negated_terms()\n\n    def _convert_all_shapes_to_boxes(self):\n        \"\"\"\n\n        \"\"\"\n        return self._query.convert_all_shapes_to_boxes()\n\n    def _convert_all_shapes_to_radiuses(self):\n        \"\"\"\n\n        \"\"\"\n        return self._query.convert_all_shapes_to_radiuses()\n\n    def _factor_locations_by_radius(self, radius_km):\n        \"\"\"\n\n        \"\"\"\n        return self._query.factor_locations_by_radius(radius_km)\n\n    def _transform_phrases(self):\n        \"\"\"\n\n        \"\"\"\n        return self._query.transform_phrases()\n\n    # TODO(LH): save the query for a filter so we don't have to refactor\n    #   locations every time a background search is run\n\n    def _format_locations(self):\n        \"\"\"\n        Formats the query Locations to conform to Specs for search area size\n        and shape.\n        \"\"\"\n        location_format = self._get_spec('location_format')\n\n        if location_format == 'box':\n            self._convert_all_shapes_to_boxes()\n\n        elif location_format == 'radius':\n            self._convert_all_shapes_to_radiuses()\n            radius_km = self._get_spec('radius_limit_km')\n            self._factor_locations_by_radius(radius_km)\n\n        else:\n            raise AttributeError('Invalid location format \"%s\"' % location_format)\n\n    def _handle_negation(self):\n        \"\"\"\n        If the API does not allow terms to be excluded from query results (e.g.,\n        with a \"NOT\" operator), removes any negated search terms from the query.\n        \"\"\"\n        allows_negation = self._get_spec('NOT_operator')\n\n        if not allows_negation:\n            self._remove_negated_terms()\n\n    def _handle_phrases(self):\n        \"\"\"\n        If the API does not accepts phrases, reformats any phrases so that a\n        query is performed on each word of a phrase, as well as on the tag for\n        the phrase (i.e., no spaces between words).\n        \"\"\"\n        accepts_phrases = self._get_spec('accepts_phrases')\n\n        if not accepts_phrases:\n            self._transform_phrases()\n\n    # TODO(LH): need a better way to handle excluded terms in factored queries,\n    #   so that each negated term is included in each subquery; also need to\n    #   make sure that no query consists only of negated search terms (i.e.,\n    #   no included search terms, locations, or accounts)\n\n    def _preprocess_components(self):\n        \"\"\"\n        Formats locations and phrases so they can be handled by the API.\n        \"\"\"\n        # convert locations into the proper format\n        self._format_locations()\n\n        # removed negated terms if the API lacks a \"NOT\" operator\n        self._handle_negation()\n\n        # break up phrases if needed\n        self._handle_phrases()\n\n    def get_num_searchterms(self, query):\n        \"\"\"\n        Takes a ReservoirQuery and returns the number of search terms in\n        the query, according to how the API counts terms (i.e., whether logical\n        operators or Accounts count toward the total number of search terms).\n        Depending on the query and the API, this may be greater than the number\n        of SearchTerms in the query.\n        \"\"\"\n        # first count the actual SearchTerms in the query\n        total_terms = len(query.searchterms)\n\n        # determine whether followees (Accnts) count toward the search term limit\n        handled_together = self._get_spec('combine_trm_fol')\n\n        if handled_together:\n\n            # count accounts as search terms\n            total_terms += len(query.accounts)\n\n        # determine whether query operators count toward the search term limit\n        includes_operators = self._get_spec('combine_trm_opr')\n\n        if includes_operators:\n\n            # get the default logic for combining terms (\"AND\" or \"OR\")\n            default_logic = self._get_spec('trm_trm_logic')\n\n            if default_logic == 'AND':\n\n                # make sure we have a way to combine search terms with \"OR\"\n                if self._get_spec('OR_operator'):\n\n                    # add the number of \"OR\" operators we'll need to join terms\n                    total_terms += total_terms - 1\n\n        return total_terms\n\n    def _exceeds_searchterms_limit(self, query):\n        \"\"\"\n        Takes a ReservoirQuery and return a Boolean indicating whether\n        the query exceeds the Specs for maximum number of search terms allowed.\n        \"\"\"\n        # get the total number of search terms allowed\n        searchterms_limit = self._get_spec('searchterms_limit')\n        total_terms = self.get_num_searchterms(query)\n\n        return total_terms > searchterms_limit\n\n    @staticmethod\n    def _separate_terms(query):\n        \"\"\"\n        Takes a ReservoirQuery and returns a list of queries, each\n        containing one SearchTerm from the orginal query.\n        \"\"\"\n        if len(query.searchterms) > 1:\n\n            new_queries = []\n\n            for term in query.searchterms:\n                new_query = deepcopy(query)\n                new_query.terms = [term]\n                new_queries.append(new_query)\n\n            return new_queries\n\n        else:\n            return [query]\n\n    def _handle_trm_trm_logic(self, queries):\n        \"\"\"\n        Takes a list of ReservoirQueries and determines the need to break\n        up the queries in order to obtain a union of results for each SearchTerm in a\n        query (i.e., by joining SearchTerms with an \"OR\" operator). If the API\n        doesn't provide a means of joining SearchTerms with \"OR\", the method breaks up\n        each query into multiple queries with only one SearchTerm per query, and\n        returns the processed queries as a list. Otherwise, returns the orignal\n        queries.\n        \"\"\"\n        # get the Pipe's default logic for combining terms (\"AND\" or \"OR\")\n        default_logic = self._get_spec('trm_trm_logic')\n\n        if default_logic == 'OR' or self._get_spec('OR_operator'):\n            return queries\n\n        else:\n            new_queries = []\n\n            for query in queries:\n                sep_queries = self._separate_terms(query)\n                new_queries.extend(sep_queries)\n\n            return new_queries\n\n    @staticmethod\n    def _separate_locations_and_terms(query):\n        \"\"\"\n        Takes a ReservoirQuery and divides it into two queries: one that\n        contains Locations but not SearchTerms, and one that contains SearchTerms but not\n        Locations. Returns the two new ReservoirMediaQueries as a list.\n        \"\"\"\n        # create a copy of the query without SearchTerms\n        locations_query = deepcopy(query)\n        locations_query.searchterms = []\n\n        # create a copy of the query without Locations\n        terms_query = deepcopy(query)\n        terms_query.locations = []\n\n        return [locations_query, terms_query]\n\n    def _handle_trm_loc_logic(self, queries):\n        \"\"\"\n        Takes a list of ReservoirMediaQueries and determines the need to place\n        Locations and SearchTerms in seperate queries before sending to the API. If\n        Locations need to be handled separately from SearchTerms, puts each in its own\n        query and returns the processed queries as a list. Otherwise, returns\n        original queries.\n        \"\"\"\n        # we assume that each query in the queries argument was derived from the\n        # original query (self._query) and therefore uses the same trm_loc_logic\n        query_logic = self._get_query_trm_loc_logic()\n\n        default_logic = self._get_spec('trm_loc_logic')\n\n        # check if terms and locations can be combined in a query with \"OR\"\n        has_or_logic = self._get_spec('combine_trm_loc') \\\n                       and self._get_spec('OR_operator')\n\n        # If query_logic == 'OR' and 'OR' logic is not allowed, we need to\n        # split each query up before sending it to the API.\n        if query_logic == 'OR' and default_logic == 'AND' and not has_or_logic:\n            new_queries = []\n\n            for query in queries:\n                sep_queries = self._separate_locations_and_terms(query)\n                new_queries.extend(sep_queries)\n\n            return new_queries\n\n        else:\n            return queries\n\n    @staticmethod\n    def _separate_accounts_and_terms(query):\n        \"\"\"\n        Takes a ReservoirQuery and divides it into two queries: one that\n        contains Accounts but not SearchTerms, and one that contains SearchTerms but not\n        Accounts. Returns the two new ReservoirMediaQueries as a list.\n        \"\"\"\n        # create a copy of the query without terms\n        accounts_query = deepcopy(query)\n        accounts_query.searchterms = []\n\n        # create a copy of the query without accounts\n        terms_query = deepcopy(query)\n        terms_query.accounts = []\n\n        return [accounts_query, terms_query]\n\n    def _handle_trm_fol_logic(self, queries):\n        \"\"\"\n        Takes a list of ReservoirMediaQueries and determines the need to place\n        Accounts and SearchTerms in seperate queries before sending to the API. If\n        Accounts need to be handled separately from SearchTerms, puts each in its own\n        query and returns the processed queries as a list. Otherwise, returns\n        the original queries.\n        \"\"\"\n        # get the Pipe's default logic for combining terms (\"AND\" or \"OR\")\n        default_logic = self._get_spec('trm_fol_logic')\n\n        # check if terms and accounts are combined in a query\n        can_combine = self._get_spec('combine_trm_fol')\n\n        if default_logic == 'OR' or (self._get_spec('OR_operator') and \\\n        can_combine):\n            return queries\n\n        else:\n            new_queries = []\n\n            for query in queries:\n                separated_queries = self._separate_accounts_and_terms(query)\n                new_queries.extend(separated_queries)\n\n            return new_queries\n\n    def _separate_components(self):\n        \"\"\"\n        Takes the current ReservoirQuery and, where needed, breaks it\n        into smaller queries to allow \"OR\" queries in cases where the API only\n        allows \"AND\" queries. For example, if a query is for \"cat OR dog\" and\n        the API only allows the query \"cat AND dog\", the method will break the\n        orginal query into two separate queries: one for \"cat\" and one for\n        \"dog\", which together will produce the same results as \"cat OR dog\".\n        Returns the result as a list of ReservoirMediaQueries.\n        \"\"\"\n        new_queries = [self._query]\n\n        # Media query can use either \"SearchTerm OR Location\" or \"SearchTerm AND Location\"\n        # logic. In the case of a \"SearchTerm OR Location\" query, we need to split up\n        # SearchTerms and Locations if the API only takes \"SearchTerm AND Location\" queries.\n        new_queries = self._handle_trm_loc_logic(new_queries)\n\n        # media query uses \"SearchTerm OR Account\", so we need to break these up if\n        # the API uses \"SearchTerm AND Account\" logic\n        new_queries = self._handle_trm_fol_logic(new_queries)\n\n        # media query uses \"SearchTerm OR SearchTerm\", so we need to break these up if\n        # the API uses \"SearchTerm AND SearchTerm\" logic\n        new_queries = self._handle_trm_trm_logic(new_queries)\n\n        return new_queries\n\n    def _handle_combined_trm_fol_limit(self, queries):\n        \"\"\"\n        Takes a list of ReservoirMediaQueries and, for each query, determines\n        the need to query Accounts separately from SearchTerms. If the API handles\n        Accounts and SearchTerms together (by treating usernames like keywords), and a\n        query exceeds the API's limit for search terms, breaks up the query so\n        that Accounts are queried separately from SearchTerms. Returns the processed\n        queries as a list.\n        \"\"\"\n        # determine whether followees count toward the search term limit\n        handled_together = self._get_spec('combine_trm_fol')\n\n        if handled_together:\n\n            new_queries = []\n\n            for query in queries:\n                if query.accounts and query.searchterms \\\n                and self._exceeds_searchterms_limit(query):\n                    sep_queries = self._separate_accounts_and_terms(query)\n                    new_queries.extend(sep_queries)\n                else:\n                    new_queries.append(query)\n\n            return new_queries\n\n        else:\n            return queries\n\n    @staticmethod\n    def _factor_queries_by_component(queries, component, limit):\n        \"\"\"\n        Takes a list of ReservoirMediaQueries, a string representing the name\n        of a query component/attribute (e.g., 'locations'), and an integer\n        representing the API limit on the number of items for that attribute.\n        Returns a list of queries that break up the orginal queries by the given\n        component so than none of the new queries exceed the API limit for that\n        component.\n        \"\"\"\n        if limit == None:\n            limit = float('inf')\n\n        new_queries = []\n\n        for query in queries:\n\n            # get the items in the query component (e.g., query.locations)\n            items = getattr(query, component)\n\n            if len(items) > limit:\n\n                # divide the items into groups no larger than the limit\n                groups = parserutils.divide_into_groups(items, limit)\n\n                # create a new query for each group\n                for group in groups:\n                    new_query = deepcopy(query)\n                    setattr(new_query, component, group)\n                    new_queries.append(new_query)\n            else:\n                new_queries.append(query)\n\n        return new_queries\n\n    def _get_adjusted_searchterms_limit(self):\n        \"\"\"\n        Determines whether the search terms limit needs to be adjusted downward\n        to take into account inclusion of 'OR' operators between terms. If so,\n        returns the adjusted limit. Otherwise, returns the unadjusted limit.\n        \"\"\"\n        limit = self._get_spec('searchterms_limit')\n        includes_operators = self._get_spec('combine_trm_opr')\n        needs_operators = (self._get_spec('trm_trm_logic') == 'AND')\n        has_operator = self._get_spec('OR_operator')\n\n        if includes_operators and needs_operators and has_operator and limit > 1:\n\n            # return half the limit, rounded down to the enarest integer\n            limit = limit // 2\n\n        return limit\n\n    def _factor_by_searchterms(self, queries):\n        \"\"\"\n        Takes a list of ReservoirMediaQueries and returns a list of queries\n        that, if necessary, breaks up the orginal queries by the searchterms\n        attribute to ensure that no query exceeds the API limit for number of\n        terms.\n        \"\"\"\n        limit = self._get_adjusted_searchterms_limit()\n        return self._factor_queries_by_component(queries, 'searchterms', limit)\n\n    def _factor_by_accounts(self, queries):\n        \"\"\"\n        Takes a list of ReservoirMediaQueries and returns a list of queries\n        that, if necessary, breaks up the orginal queries by the accounts\n        attribute to ensure that no query exceeds the API limit for number of\n        accounts.\n        \"\"\"\n        limit = self._get_spec('followees_limit')\n        return self._factor_queries_by_component(queries, 'accounts', limit)\n\n    def _factor_by_locations(self, queries):\n        \"\"\"\n        Takes a list of ReservoirMediaQueries and returns a list of queries\n        that, if necessary, breaks up the orginal queries by the locations\n        attribute to ensure that no query exceeds the API limit for number of\n        locations.\n        \"\"\"\n        limit = self._get_spec('locations_limit')\n        return self._factor_queries_by_component(queries, 'locations', limit)\n\n    def _factor_components(self, queries):\n        \"\"\"\n        Takes a list of ReservoirQueries and returns a list of ReservoirQueries\n        that, if necessary, breaks up the orginal queries by accounts, locations,\n        and/or search terms to ensure that no query exceeds the API limit for\n        any of these arguments.\n        \"\"\"\n        new_queries = self._factor_by_accounts(queries)\n        new_queries = self._factor_by_searchterms(new_queries)\n        new_queries = self._factor_by_locations(new_queries)\n        return new_queries\n\n    def factor_query(self):\n        \"\"\"\n        Takes a ReservoirQuery and factors them into a list of ReservoirQueries\n        for a particular API.\n        \"\"\"\n        # format Locations and SearchTerms so that they can be handled by the API\n        self._preprocess_components()\n\n        # split up components where the API doesn't allow \"OR\" queries\n        new_queries = self._separate_components()\n\n        # split up Accounts and SearchTerms if they share the same API limit\n        new_queries = self._handle_combined_trm_fol_limit(new_queries)\n\n        # break up each component (Accounts, Locations, SearchTerms) so that none\n        # exceed their respective API limit\n        new_queries = self._factor_components(new_queries)\n\n        return new_queries\n\n    def get_accounts(self):\n        \"\"\"\n        Returns the list of Accounts associated with the query.\n        \"\"\"\n        return self._query.accounts\n\n    def get_locations(self):\n        \"\"\"\n        Returns the list of Locations associated with the query.\n        \"\"\"\n        return self._query.locations\n\n    def get_searchterms(self):\n        \"\"\"\n        Returns the list of SearchTerms associated with the query.\n        \"\"\"\n        return self._query.searchterms\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null], "name": "aggregator/pumproom/exceptions.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n\nclass PlumberDoesNotExist(Exception):\n    \"\"\"\n    \n    \"\"\"\n    pass\n\n\nclass PipeDoesNotExist(Exception):\n    \"\"\"\n\n    \"\"\"\n    pass\n\n\nclass SpecsheetDoesNotExist(Exception):\n    \"\"\"\n\n    \"\"\"\n    pass\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, 1, 1, null, 0, null, 1, null, null, null, 0, null, 1, null, null, null, null, null, 0, null, 1, null, null, null, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, 1, 1, 1, 1, 1, 1, null, 1, null, 1, null, null], "name": "aggregator/pumproom/faucet.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# standard library\nimport logging\n\n# third party\nfrom django.utils.functional import cached_property\n\n# local\nfrom aggregator.invoices.models import Invoice\nfrom ambassador.transport import Cargo, Transport\nfrom cyphon.transaction import close_old_connections\nfrom sifter.datasifter.datachutes.models import DataChute\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass Faucet(Transport):\n    \"\"\"\n\n    Attributes\n    ----------\n    endpoint : Pipe\n\n    emissary : Plumber\n\n    user : AppUser\n\n    cargo :  Cargo\n\n    record : Invoice\n\n    task : str\n\n\n    \"\"\"\n\n    def __init__(self, task, *args, **kawrgs):\n        super(Faucet, self).__init__(*args, **kawrgs)\n        self.task = task\n\n    @cached_property\n    def _stamp(self):\n        \"\"\"\n\n        \"\"\"\n        if self.record:\n            return self.record.stamp\n\n    @close_old_connections\n    def is_obsolete(self):\n        \"\"\"\n        Returns a Boolean indicating whether a more recent call has been\n        made to the same endpoint with the same credentials.\n        \"\"\"\n        if self._stamp:\n            return self._stamp.is_obsolete()\n        else:\n            return False\n\n    def load_cargo(self, data):\n        \"\"\"\n\n        \"\"\"\n        self.cargo = Cargo(data=data, status_code='200')\n\n    def stash_data(self, data):\n        \"\"\"\n        For ad hoc searches, data from each endpoint should be\n        temporarily saved in a separate collection associated with the\n        user making the request.\n        \"\"\"\n        pass\n\n    def send_to_chutes(self, data):\n        \"\"\"\n\n        \"\"\"\n        chutes = DataChute.objects.find_by_endpoint(self.endpoint)\n        for chute in chutes:\n            chute.bulk_process(data=data)\n\n    def create_record(self, stamp, obj):\n        \"\"\"\n        Create a record of the response\n\n        Parameters\n        ----------\n        stamp : |Stamp|\n\n        obj : |ReservoirQuery|\n\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        query = obj.to_dict()\n\n        return Invoice.objects.create(\n            stamp=stamp,\n            query=query,\n            task=self.task\n        )\n\n    def process_request(self, obj):\n        \"\"\"\n\n        Parameters\n        ----------\n        obj : |ReservoirQuery|\n\n        Returns\n        -------\n        |Cargo|\n\n\n        Takes an a ReservoirQuery, formats and submits it to the API,\n        returns a Cargo object. This method needs to be implemented in\n        derived classes so it can be customized for specific APIs.\n\n        \"\"\"\n        raise self.raise_method_not_implemented()\n\n    @close_old_connections\n    def process_results(self):\n        \"\"\"\n\n        \"\"\"\n        if self.cargo is not None:\n            data = self.cargo.data\n            if self.task == 'ADHOC_SRCH':\n                return self.stash_data(data)\n            elif self.task == 'BKGD_SRCH':\n                return self.send_to_chutes(data)\n            else:\n                return data\n        else:\n            LOGGER.error('There are no results to process. '\n                         'Call the start() method to get data from the API.')\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, 1, 1, null, null, null, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, 1, null, 1, null, null, null, null, 1, 1, 1, null, 1, 1, null, 1, null, null, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, 1, null, 1, null, 1, null, null, null, null, null, null, 1, 1, null, 1, 1, 1, 1, 1, null, 1, null, 1, null, 1, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, 1, 1, null, null, 1, null, 1, null, 0, null], "name": "aggregator/pumproom/pump.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Pump class, which coordinates the process of passing a ReservoirQuery\nto an API and saving the results.\n\"\"\"\n\n# standard library\nfrom collections import deque\nimport logging\n\n# third party\nfrom django.utils.functional import cached_property\n\n# local\nfrom aggregator.pumproom.engineer import Engineer\nfrom aggregator.pumproom.exceptions import (\n    PipeDoesNotExist,\n    SpecsheetDoesNotExist,\n)\nfrom aggregator.pumproom.streamcontroller import StreamController\nfrom cyphon.transaction import close_old_connections\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass Pump(object):\n    \"\"\"\n    Coordinates the process of sending a |ReservoirQuery| to a\n    |Reservoir| and retrieving the results.\n\n    Attributes\n    ----------\n    reservoir : Reservoir\n        A |Reservoir| representing an external data platform from which\n        data should be retreved.\n\n    task : str\n        The type of task being performed. Corresponds to a value in\n        |SEARCH_TASK_CHOICES|.\n\n    user : AppUser\n        The |AppUser| making the request.\n\n    container : Container\n        A |Container| to store the results.\n\n    \"\"\"\n\n    def __init__(self, reservoir, task, user=None):\n        self.reservoir = reservoir\n        self.task = task\n        self.user = user\n\n    def __str__(self):\n        return str(self._pipe)\n\n    @cached_property\n    def _pipe(self):\n        \"\"\"\n        The Pipe that should be used for the |Pump|'s :attr:`~Pump.task`.\n        \"\"\"\n        pipe = self.reservoir.get_pipe(self.task)\n        if pipe:\n            return pipe\n        else:\n            error_msg = 'The Reservoir \"%s\" has no Pipe for the Task \"%s\"'\n            raise PipeDoesNotExist(error_msg % (self.reservoir, self.task))\n\n    @cached_property\n    def _faucet(self):\n        \"\"\"\n\n        \"\"\"\n        return self._pipe.create_request_handler(\n            user=self.user,\n            params={'task': self.task}\n        )\n\n    @cached_property\n    def _plumber(self):\n        \"\"\"\n\n        \"\"\"\n        return self._faucet.emissary\n\n    @cached_property\n    def _specsheet(self):\n        \"\"\"\n        Returns the SpecSheet associated with the Pump's Pipe.\n        \"\"\"\n        if hasattr(self._pipe, 'specsheet'):\n            return self._pipe.specsheet\n        else:\n            error_msg = 'The Pipe \"%s\" has no Specsheet'\n            raise SpecsheetDoesNotExist(error_msg % self._pipe)\n\n    def _is_stream(self):\n        \"\"\"\n        Returns a Boolean indicating whether the Pump's Pipe is for a\n        streaming API.\n        \"\"\"\n        return self._specsheet.streaming           \n\n    def _factor_query(self, query):\n        \"\"\"\n        Takes a ReservoirQuery and returns it as a list of one or more\n        ReservoirQueries formatted for the Pump's Pipe.\n        \"\"\"\n        engineer = Engineer(query=query, specs=self._specsheet)\n        return engineer.factor_query()\n\n    def _create_stream_controller(self, query):\n        \"\"\"\n        Returns an instance of an ApiHandler subclass to contact the API\n        associated with the Pump's Pipe.\n        \"\"\"\n        return StreamController(faucet=self._faucet, query=query)\n\n    def _process_streaming_query(self, query):\n        \"\"\"\n\n\n        Takes a ReservoirQuery and, if a stream for the query is not currently\n        running, starts a stream and saves an Invoice of the API call. Returns\n\n        \"\"\"\n        controller = self._create_stream_controller(query)\n        return controller.process_query()\n\n    def _process_nonstreaming_query(self, query):\n        \"\"\"\n\n\n\n        Takes a ReservoirQuery, passes it to the Pump's ApiHandler for\n        processing, and saves an Invoice of the API call. Returns\n        \"\"\"\n        # send query to API\n        self._faucet.run(query)\n\n        return self._faucet.process_results()\n\n    def _process_nonstreaming_queries(self, queries):\n        \"\"\"\n\n\n        Takes a list of ReservoirQueries and processes each through the\n        Pump's Pipe. Returns\n        \"\"\"\n        results = []\n        query_queue = deque(queries)\n\n        while len(query_queue) > 0:\n            query = query_queue.popleft()\n            result = self._process_nonstreaming_query(query)\n            if isinstance(result, list):\n                results.extend(result)\n            else:\n                results.append(result)\n\n        return results\n\n    def get_time_requirements(self, query_cnt):\n        \"\"\"\n        Takes an integer query_cnt, representing the number of queries that\n        need to be performed, and returns a float representing the number of\n        minutes required to fulfill all the queries, given the rate limit of\n        the API.\n        \"\"\"\n        return self._plumber.calculate_query_time_in_minutes(query_cnt)\n\n    @close_old_connections\n    def start(self, query):\n        \"\"\"Send a query to the Pump's Reservoir.\n\n        Parameters\n        ----------\n        query : |ReservoirQuery|\n            The query to be sent to the |Reservoir|.\n\n        Returns\n        -------\n        |list| of |Invoice| or |None|\n            If the |Pump| uses a non-streaming API, returns a |list|\n            of |Invoices|. If the |Pump| uses a streaming API,\n            returns None (since a discrete set of results is not\n            available).\n\n        Notes\n        -----\n        If the Pipe is using a streaming API, it will start a stream as\n        a daemon thread.\n\n        Warning\n        -------\n        If the number of parameters in the `query` exceeds the number\n        of parameters allowed by the API that the Pump is using, the\n        query will be reformatted into smaller subqueries. If the Pump\n        is using a streaming API, only the first subquery will be\n        submitted to the API.\n\n        \"\"\"\n        queries = self._factor_query(query)\n\n        if self._specsheet:\n            if self._is_stream():\n                if len(queries) > 1:\n                    LOGGER.warning('Query was too large for Pipe \"%s.\" '\n                                   'A smaller version of the query was '\n                                   'submitted.', self._pipe)\n                return self._process_streaming_query(queries[0])\n            else:\n                return self._process_nonstreaming_queries(queries)\n        else:\n            LOGGER.error('The Pipe %s is missing a Specsheet.', self.endpoint)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, null, 1, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, 1, 1, 0, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, null, null, null, 1, 1, null, 1, 1, null, 1, null], "name": "aggregator/pumproom/pumproom.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a |PumpRoom| class, which coordinates the process of passing a\n|ReservoirQuery| to selected APIs and aggregating the results.\n\"\"\"\n\n# standard library\nimport logging\nimport threading\n\n# local\nfrom aggregator.pumproom.pump import Pump\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass PumpRoom(object):\n    \"\"\"\n    Coordinates the process of sending a |ReservoirQuery| to set of\n    |Reservoirs| and aggregating the results.\n\n    Attributes\n    ----------\n    reservoirs : `QuerySet` of `Reservoirs`\n        A |QuerySet| of |Reservoirs| from which data should be retrieved.\n\n    task : str\n        The type of task being performed. Corresponds to a value in\n        |SEARCH_TASK_CHOICES|.\n\n    user : AppUser\n        The |AppUser| making the request.\n\n    \"\"\"\n\n    def __init__(self, reservoirs, task, user=None):\n        self.reservoirs = reservoirs\n        self.task = task\n        self.user = user\n        self.records = []  # Invoices for the API calls made\n\n    def _create_pump(self, reservoir):\n        \"\"\"\n        Takes a Reservoir and creates a Pump to pull data from that Reservoir,\n        appropriate to the PumpRoom's user and task.\n        \"\"\"\n        return Pump(\n            reservoir=reservoir,\n            task=self.task,\n            user=self.user,\n        )\n\n    def _start_pump(self, pump, query):\n        \"\"\"\n        Takes a Pump and a ReservoirQuery and starts the Pump with that\n        query. Adds the result to the PumpRoom's records.\n        \"\"\"\n        records = pump.start(query)\n        if isinstance(records, list):\n            self.records.extend(records)\n        else:\n            self.records.append(records)\n\n    def get_results(self, query):\n        \"\"\"Get query results from the PumpRoom's Reservoirs.\n\n        Parameters\n        ----------\n        query : |ReservoirQuery|\n            The query to be sent to the |PumpRoom|'s |Reservoirs|.\n\n        Returns\n        -------\n        |list| of |Invoices|\n            |Invoices| recording the responses of the API calls made.\n\n        \"\"\"\n        threads = []\n        for reservoir in self.reservoirs:\n            pump = self._create_pump(reservoir)\n            subquery = query.filter_accounts(reservoir)\n            thread = threading.Thread(\n                target=self._start_pump,\n                kwargs={'pump': pump, 'query': subquery}\n            )\n            threads.append(thread)\n            thread.start()\n\n        for thread in threads:\n            thread.join()\n\n        return self.records\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, 0, null, null, 0, null, null, 0, null, 1, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, 1, null, 1, 1, null, null, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, 1, 1, null, 1, null], "name": "aggregator/pumproom/streamcontroller.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a StreamController class, which handles queries for streaming APIs.\n\"\"\"\n\n# standard library\nimport threading\n\n# third party\nfrom django.db import transaction\nfrom django.utils.functional import cached_property\n\n# local\nfrom aggregator.streams.models import Stream\nfrom cyphon.transaction import require_lock\n\n\nclass StreamController(object):\n    \"\"\"\n    Attributes\n    ----------\n    query : dict\n\n    \"\"\"\n    def __init__(self, faucet, query):\n        self.faucet = faucet\n        self.query = query\n\n    @cached_property\n    def stream(self):\n        \"\"\"\n        Checks whether a Stream associated with the StreamController's ApiHandler\n        already exists in the database. If so, returns the Stream object;\n        otherwise, returns a newly created Stream object.\n        \"\"\"\n        return Stream.objects.find_stream(self.faucet)\n\n    def _run_faucet(self):\n        \"\"\"\n        Passes the StreamController's query to the Pump's ApiHandler for\n        processing.\n        Updates Stream record as active and saves the current query.\n\n        \"\"\"\n        # make the API call\n        self.faucet.start(self.query)\n\n        # update the Invoice\n        self.faucet.stop()\n\n        # update the Stream\n        self.stream.save_as_closed()\n\n    def _start_stream(self):\n        \"\"\"\n        Starts a daemon thread to process the StreamController's query.\n        Returns the created thread.\n        \"\"\"\n        thread = threading.Thread(target=self._run_faucet)\n        thread.daemon = True\n        thread.start()\n        return thread\n\n    def _query_is_running(self):\n        \"\"\"\n        Returns a Boolean indicating whether the StreamController's\n        query is already being processed by a thread.\n        \"\"\"\n        return self.stream.is_running(self.query)\n\n    @transaction.atomic\n    @require_lock(Stream, 'ACCESS EXCLUSIVE')\n    def process_query(self):\n        \"\"\"\n        Checks if a stream for the ReservoirQuery is already running. If not,\n        starts a stream, updates the Stream object keeping track of the stream,\n        and returns True. Otherwise, does nothing with the query and returns\n        False.\n        \"\"\"\n        if not self._query_is_running():\n\n            # create an Invoice for the call\n            self.faucet.prepare(self.query)\n            record = self.faucet.record\n\n            # associate the Invoice with the Stream\n            self.stream.save_as_open(record)\n\n            self._start_stream()\n            return True\n        else:\n            return False\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "aggregator/reservoirs/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1], "name": "aggregator/reservoirs/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom aggregator.reservoirs.models import Reservoir\n\n\nclass ReservoirAdmin(admin.ModelAdmin):\n    \"\"\"\n\n    \"\"\"\n    list_display = ['id', 'name']\n\n\nadmin.site.register(Reservoir, ReservoirAdmin)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, null, null, 1, 1, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, null, 1, null, 1, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, 1, null], "name": "aggregator/reservoirs/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nHandles settings for which social media platforms are enabled.\nAlso handles settings for which Pipes (APIs) are used for which purpose\n(ad hoc search vs. background stream, etc.).\n\"\"\"\n\n# third party\nfrom django.db import models\n\n# local\nfrom ambassador.platforms.models import Platform, PlatformManager\nfrom cyphon.choices import SEARCH_TASK_CHOICES\n\n\nclass ReservoirManager(PlatformManager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def find_pipes(self, task):\n        \"\"\"\n        (str) -> set\n\n        Takes a gateway task and returns a set of pipes assigned to that task.\n        Only returns pipes from platforms that are enabled.\n        \"\"\"\n        enabled_platforms = self.find_enabled()\n        pipes = set([])\n        for platform in enabled_platforms:\n            pipe = platform.get_pipe(task)\n            if pipe:\n                pipes.add(pipe)\n        return pipes\n\n\nclass Reservoir(Platform):\n    \"\"\"\n    Determines whether a platform is enabled for use. The platform\n    corresponds to a subpackage in the Platforms package. A Reservoir's\n    primary key is the name of the subpackage associated with the\n    Reservoir (e.g., 'twitter').\n    \"\"\"\n    objects = ReservoirManager()\n\n    def get_gateway(self, task):\n        \"\"\"\n        Returns the gateway for a given task, or None if the gateway\n        doesn't exist.\n        \"\"\"\n        try:\n            return Gateway.objects.get(reservoir=self, task=task)\n        except Gateway.DoesNotExist:\n            return None\n\n    def get_pipe(self, task):\n        \"\"\"\n        Takes the primary key (name) of a SearchTask and returns the\n        Pipe for that task, if one exists. Otherwise, returns None.\n        \"\"\"\n        gateway = self.get_gateway(task)\n        if gateway and gateway.pipe:\n            return gateway.pipe\n        else:\n            return None\n\n\nclass Gateway(models.Model):\n    \"\"\"\n    Specifies the Pipe (API) that is used for a particular task, e.g., ad hoc\n    searches, \"streaming\" background searches, or finding the user id for an\n    account. In many cases, the same API may be used for more than one task.\n    \"\"\"\n    reservoir = models.ForeignKey(Reservoir)\n    task = models.CharField(max_length=20, choices=SEARCH_TASK_CHOICES)\n    pipe = models.ForeignKey('pipes.Pipe', null=True, blank=True,\n                             limit_choices_to={'reservoir': reservoir})\n\n    class Meta:\n        \"\"\"\n        Metadata options.\n        \"\"\"\n        unique_together = ('reservoir', 'task')\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "aggregator/samples/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null], "name": "aggregator/samples/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\nfrom django.contrib import admin\n\n# Register your models here.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, 1, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, 1, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, 1, 1, null], "name": "aggregator/samples/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Sample class to create a teaser for data from a |Pipe|.\nA Sample provides basic information about the data, specifing \"Who,\"\n\"What,\" \"When,\" and \"Where.\"\n\"\"\"\n\n# standard library\nimport logging\n\n# third party\nfrom django.db import models\nfrom django.core.exceptions import ObjectDoesNotExist\n\n# local\nfrom aggregator.pipes.models import Pipe\nfrom teasers.models import Teaser\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass SampleManager(models.Manager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def get_by_natural_key(self, platform, api_class):\n        \"\"\"\n        Allow retrieval of a Sample by its natural key instead of its\n        primary key.\n        \"\"\"\n        pipe = Pipe.objects.get_by_natural_key(platform, api_class)\n        try:\n            return self.get(pipe=pipe)\n        except ObjectDoesNotExist:\n            LOGGER.error('%s for Pipe \"%s %s\" does not exist',\n                         self.model.__name__, platform, api_class)\n\n\nclass Sample(Teaser):\n    \"\"\"\n    The Sample class specifies which fields of distilled data should be\n    used to construct a teaser for those data. A Taste defines a\n    crosswalk between the fields of a teaser and the fields in a\n    |Container|. Nested fields (as for embedded documents) should be\n    indicated with dot notation (e.g. 'user.name').\n\n    The Sample is used to answer basic questions about a document, e.g.,\n    Who?, What?, When?, and Where?.\n\n    \"\"\"\n    pipe = models.OneToOneField(Pipe, primary_key=True)\n\n    objects = SampleManager()\n\n    def __str__(self):\n        return str(self.pipe)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1], "name": "aggregator/streams/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\ndefault_app_config = 'aggregator.streams.apps.StreamsConfig'\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, null, null, null, null, 1, null], "name": "aggregator/streams/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines ModelAdmin subclass for Stream and register it them with Django\nAdmin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom .models import Stream\n\n\nclass StreamAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for CodeNames.\n    \"\"\"\n    exclude = []\n    # list_display = ['id', 'pipe', 'auth', 'record', 'active']\n    # list_display_links = ['id', 'pipe']\n\n\nadmin.site.register(Stream, StreamAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, 1, 1, null, 1, null, null, null, 1, null, 1, 0, 0, 0, 0, 0], "name": "aggregator/streams/apps.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.apps import AppConfig\nfrom django.conf import settings\nfrom django.db import close_old_connections\nfrom django.db.utils import ProgrammingError\n\n_IN_TESTING_MODE = settings.TEST\n\n\nclass StreamsConfig(AppConfig):\n    \"\"\"\n\n    \"\"\"\n    name = 'aggregator.streams'\n    verbose_name = 'Streams'\n\n    def ready(self):\n        \"\"\"\n\n        \"\"\"\n        from .models import Stream\n\n        if not _IN_TESTING_MODE:\n            try:\n                Stream.objects.close_all()\n                close_old_connections()\n            except ProgrammingError:  # if migrations have not been run\n                pass\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, 0, 0, 0, 0, null, null, 1, null, null, null, 1, 1, 1, 1, null, 1, null, 1, 1, null, 1, 1, null, 1, null, null, null, 1, 1, null, 1, null, null, null, 1, 1, 1, null, 1, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, null, null, 1, null, null], "name": "aggregator/streams/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Stream class for saving the status of a stream.\n\"\"\"\n\n# standard library\nimport logging\n\n# third party\nfrom django.db import models\nfrom django.db.utils import OperationalError\n\n# local\nfrom aggregator.invoices.models import Invoice\nfrom aggregator.pipes.models import Pipe\nfrom ambassador.passports.models import Passport\n\n_LOGGER = logging.getLogger(__name__)\n\n\nclass StreamManager(models.Manager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def find_stream(self, faucet):\n        \"\"\"\n        Checks whether a Stream associated with the StreamController's ApiHandler\n        already exists in the database. If so, returns the Stream object;\n        otherwise, returns None.\n        \"\"\"\n        try:\n            return self.get(pipe=faucet.endpoint, auth=faucet.passport)\n        except Stream.DoesNotExist:\n            return self.create(pipe=faucet.endpoint, auth=faucet.passport)\n\n    def close_all(self):\n        \"\"\"\n\n        \"\"\"\n        try:\n            self.update(active=False)\n        except OperationalError as err:\n            _LOGGER.warning('An error occurred while closing Streams: %s', err)\n\n\nclass Stream(models.Model):\n    \"\"\"\n    Records the status of a streaming API connection.\n    \"\"\"\n    pipe = models.ForeignKey(Pipe)\n    auth = models.ForeignKey(Passport)\n    record = models.ForeignKey(Invoice, null=True, blank=True)\n    active = models.BooleanField(default=False)\n\n    objects = StreamManager()\n\n    class Meta:\n        unique_together = ['pipe', 'auth']\n\n    def __str__(self):\n        return '%s: %s' % (self.pipe, self.auth.name)\n\n    def save_as_closed(self):\n        \"\"\"\n        Sets active to False.\n        \"\"\"\n        self.active = False\n        self.save()\n\n    def save_as_open(self, record):\n        \"\"\"\n        Sets active to True.\n        \"\"\"\n        self.record = record\n        self.active = True\n        self.save()\n\n    def _query_is_unchanged(self, query):\n        \"\"\"\n        Takes a ReservoirQuery\n        \"\"\"\n        query_dict = query.to_dict()\n        self.record.query.pop('timeframe', None)\n        query_dict.pop('timeframe', None)\n        return query_dict == self.record.query\n\n    def is_running(self, query):\n        \"\"\"\n        query : |ReservoirQuery|\n\n        Returns a Boolean indicating whether the StreamController's query is\n        already being processed by a thread.\n        \"\"\"\n        return self.active and \\\n            self.record and \\\n            self._query_is_unchanged(query)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "alarms/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, null, null, 1, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, 1], "name": "alarms/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines an Alarm base class.\n\"\"\"\n\n# third party\nfrom django.contrib.auth.models import Group\nfrom django.contrib.contenttypes.fields import GenericRelation\nfrom django.db import models\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom alerts.models import Alert\nfrom categories.models import Category\nfrom cyphon.models import GetByNameManager, FindEnabledMixin\n\n\nclass AlarmManager(GetByNameManager, FindEnabledMixin):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n    pass\n\n\nclass Alarm(models.Model):\n    \"\"\"\n    Defines a class for inspecting data produced by a Distillery. Used\n    to create Alerts when appropriate.\n\n    Attributes\n    ----------\n    name : str\n        A |str| representing the name of the Watchdog.\n\n    enabled : bool\n        A |bool| indicating whether the Watchdog is active.\n\n    groups : `QuerySet` of `Groups`\n\n    \"\"\"\n    name = models.CharField(max_length=255, unique=True)\n    enabled = models.BooleanField(default=True)\n    groups = models.ManyToManyField(\n        Group,\n        blank=True,\n        help_text=_('Only show Alerts to Users in these Groups. '\n                    'If no Groups are selected, Alerts will be visible '\n                    'to all Groups.')\n    )\n    alerts = GenericRelation(\n        Alert,\n        content_type_field='alarm_type',\n        object_id_field='alarm_id',\n        related_query_name='%(class)s'\n    )\n\n    class Meta:\n        abstract = True\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "alerts/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, null, null, 1, 1, 1, 1, 1, 1, 1, 1, 1, null, null, 1, 1, null], "name": "alerts/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclass for Alerts and registers Alerts with Django Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom .models import Alert, Comment\n\n\nclass AlertAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Alerts.\n\n    WARNING\n    -------\n    'search_fields' will only let you search the actual title\n    of Alerts, not the display_title. This means you can't search for\n    CodeNames in Alert titles even if CodeNames are enabled.\n\n    \"\"\"\n    readonly_fields = (\n        'incidents',\n        'display_title',\n        'created_date',\n        'content_date',\n        'alarm',\n        'distillery',\n        'doc_id',\n        'company',\n        'get_data_str',\n        'location',\n    )\n    fieldsets = (\n        (None, {\n            'fields': (\n                'display_title',\n                'created_date',\n                'content_date',\n            )\n        }),\n        (_('Workflow'), {\n            'fields': (\n                'level',\n                'status',\n                'assigned_user',\n                'notes',\n                'tags',\n            ),\n        }),\n        (_('Source'), {\n            'fields': (\n                'incidents',\n                'alarm',\n                'company',\n                'distillery',\n                'doc_id',\n            ),\n        }),\n        (_('Data'), {\n            'classes': ('pre', ),\n            'fields': (\n                'get_data_str',\n                'location',\n            ),\n        }),\n    )\n    list_display = (\n        'id',\n        'display_title',\n        'content_date',\n        'level',\n        'status',\n        'incidents',\n        'outcome',\n        'assigned_user',\n        'alarm',\n        'company',\n        'distillery',\n        'location',\n    )\n    list_editable = (\n        'level',\n        'status',\n        'outcome',\n        'assigned_user'\n    )\n    list_filter = (\n        'content_date',\n        'level',\n        'status',\n        'outcome',\n        'assigned_user',\n        'distillery',\n        'alarm_type'\n    )\n    list_per_page = 25\n    date_hierarchy = 'content_date'\n    search_fields = (\n        'title',\n    )\n    actions = [\n        'set_status_to_new',\n        'set_status_to_busy',\n        'set_status_to_done',\n        'set_level_to_critical',\n        'set_level_to_high',\n        'set_level_to_medium',\n        'set_level_to_low',\n        'set_outcome_to_true',\n        'set_outcome_to_false',\n    ]\n\n    @staticmethod\n    def _format_msg(rows_updated):\n        \"\"\"\n        Helper method that formats an update message according to the number\n        of rows updated.\n        \"\"\"\n        if rows_updated == 1:\n            return '1 alert was'\n        else:\n            return '%s alerts were' % rows_updated\n\n    def set_status_to_new(self, request, queryset):\n        \"\"\"\n        Allows bulk update of Alert status to \"New.\"\n        \"\"\"\n        rows_updated = queryset.update(status='NEW')\n        self.message_user(request, '%s successfully marked as New.'\n                          % self._format_msg(rows_updated))\n\n    def set_status_to_busy(self, request, queryset):\n        \"\"\"\n        Allows bulk update of Alert status to \"Busy.\"\n        \"\"\"\n        rows_updated = queryset.update(status='BUSY')\n        self.message_user(request, '%s successfully marked as Busy.'\n                          % self._format_msg(rows_updated))\n\n    def set_status_to_done(self, request, queryset):\n        \"\"\"\n        Allows bulk update of Alert status to \"Done.\"\n        \"\"\"\n        rows_updated = queryset.update(status='DONE')\n        self.message_user(request, '%s successfully marked as Done.'\n                          % self._format_msg(rows_updated))\n\n    def set_level_to_critical(self, request, queryset):\n        \"\"\"\n        Allows bulk update of Alert level to \"Critical.\"\n        \"\"\"\n        rows_updated = queryset.update(level='CRITICAL')\n        self.message_user(request, '%s successfully marked as critical priority.'\n                          % self._format_msg(rows_updated))\n\n    def set_level_to_high(self, request, queryset):\n        \"\"\"\n        Allows bulk update of Alert level to \"High.\"\n        \"\"\"\n        rows_updated = queryset.update(level='HIGH')\n        self.message_user(request, '%s successfully marked as high priority.'\n                          % self._format_msg(rows_updated))\n\n    def set_level_to_medium(self, request, queryset):\n        \"\"\"\n        Allows bulk update of Alert level to \"Medium.\"\n        \"\"\"\n        rows_updated = queryset.update(level='MEDIUM')\n        self.message_user(request, '%s successfully marked as medium priority.'\n                          % self._format_msg(rows_updated))\n\n    def set_level_to_low(self, request, queryset):\n        \"\"\"\n        Allows bulk update of Alert level to \"Low.\"\n        \"\"\"\n        rows_updated = queryset.update(level='LOW')\n        self.message_user(request, '%s successfully marked as low priority.'\n                          % self._format_msg(rows_updated))\n\n    def set_outcome_to_true(self, request, queryset):\n        \"\"\"\n        Allows bulk update of Alert outcome to \"True.\"\n        \"\"\"\n        rows_updated = queryset.update(outcome=True)\n        self.message_user(request, '%s successfully marked as True.'\n                          % self._format_msg(rows_updated))\n\n    def set_outcome_to_false(self, request, queryset):\n        \"\"\"\n        Allows bulk update of Alert outcome to \"False.\"\n        \"\"\"\n        rows_updated = queryset.update(outcome=False)\n        self.message_user(request, '%s successfully marked as False.'\n                          % self._format_msg(rows_updated))\n\n    # define option text for actions\n    set_outcome_to_true.short_description = 'Mark as True'\n    set_outcome_to_false.short_description = 'Mark as False'\n    set_status_to_new.short_description = 'Mark as New'\n    set_status_to_busy.short_description = 'Mark as Busy'\n    set_status_to_done.short_description = 'Mark as Done'\n    set_level_to_critical.short_description = 'Mark as Critical'\n    set_level_to_high.short_description = 'Mark as High'\n    set_level_to_medium.short_description = 'Mark as Medium'\n    set_level_to_low.short_description = 'Mark as Low'\n\n\nadmin.site.register(Alert, AlertAdmin)\nadmin.site.register(Comment)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, null, 1, 1, 1, null, null, null, null, 1, 1, 1, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, 0, null, null, 1, null, null, null, 1, null, null, null, 1, null, null, null, 1, 1, 1, null, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, 1, 1, 1, 1, null, 1, 1, 1, 1, null, 1, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, 1, null, 1, 1, null, 1, 1, 1, null, 0, null, null, 1, null, null, null, null, 1, 1, null, 1, 1, null, 0, 0, 0, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1], "name": "alerts/filters.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines AlertFilter, CommentFilter, and CommentFilterBackend classes.\n\"\"\"\n\n# standard library\nimport logging\n# from threading import Thread\n\n# third party\nfrom django.db.models import Q\nfrom django_filters.rest_framework import filters as django_filters\nfrom django_filters.rest_framework import FilterSet, DjangoFilterBackend\n\n# from rest_framework.filters import BaseFilterBackend\n\n# local\nfrom appusers.models import AppUser\nfrom categories.models import Category\nfrom cyphon.choices import ALERT_LEVEL_CHOICES, ALERT_STATUS_CHOICES\nfrom distilleries.models import Distillery\nfrom tags.models import Tag\nfrom utils.dbutils.dbutils import join_query\nfrom .models import Alert  #, Comment\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass AlertFilter(FilterSet):\n    \"\"\"\n    Filters Alerts.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super(AlertFilter, self).__init__(*args, **kwargs)\n\n        # add a blank choice to ChoiceFilter options\n        for (dummy_name, field) in self.filters.items():\n            if isinstance(field, django_filters.ChoiceFilter):\n                field.extra['choices'] = tuple([('', '---------'), ] + \\\n                    list(field.extra['choices']))\n\n    collection = django_filters.ModelMultipleChoiceFilter(\n        name='distillery',\n        queryset=Distillery.objects.have_alerts()\n    )\n    after = django_filters.DateTimeFilter(\n        name='created_date',\n        lookup_expr='gt'\n    )\n    before = django_filters.DateTimeFilter(\n        name='created_date',\n        lookup_expr='lte'\n    )\n    level = django_filters.MultipleChoiceFilter(choices=ALERT_LEVEL_CHOICES)\n    status = django_filters.MultipleChoiceFilter(choices=ALERT_STATUS_CHOICES)\n    assigned_user = django_filters.ModelChoiceFilter(\n        name='assigned_user',\n        queryset=AppUser.objects.all()\n    )\n    content = django_filters.CharFilter(\n        name='data',\n        label='Content',\n        method='filter_by_content'\n    )\n    categories = django_filters.ModelMultipleChoiceFilter(\n        name='distillery__categories',\n        label='Collection categories',\n        queryset=Category.objects.all()\n    )\n    tags = django_filters.ModelMultipleChoiceFilter(\n        name='tags',\n        queryset=Tag.objects.all()\n    )\n\n    class Meta:\n        model = Alert\n\n        # List content field last so it will have fewer Alerts to\n        # filter. The content filter requires a query to the Distillery\n        # associated with the Alert. It's best to filter out as many\n        # records as possible before constructing that query.\n        fields = ['collection', 'after', 'before', 'level', 'status',\n                  'assigned_user', 'content']\n\n    @staticmethod\n    def _get_data_query(distillery, value):\n        \"\"\"\n\n        \"\"\"\n        text_fields = distillery.get_text_fields()\n        field_names = [field.field_name for field in text_fields]\n        field_keys = [name.replace('.', '__') for name in field_names]\n        queries = []\n\n        for key in field_keys:\n            query_exp = 'data__%s' % key\n            kwarg = {query_exp: value}\n            queries.append(Q(**kwarg))\n\n        field_query = join_query(queries, 'OR')\n        return Q(distillery=distillery) & field_query\n\n    @staticmethod\n    def _get_title_query(value):\n        \"\"\"\n\n        \"\"\"\n        return Q(title__icontains=value)\n\n    def _filter_by_value(self, queryset, value):\n        \"\"\"\n\n        \"\"\"\n        distilleries = Distillery.objects.filter(alerts__in=queryset).distinct()\n\n        if distilleries:\n            queries = [self._get_data_query(distillery, value) \\\n                       for distillery in distilleries]\n            data_query = join_query(queries, 'OR')\n            title_query = self._get_title_query(value)\n            return queryset.filter(title_query | data_query)\n        else:\n            return queryset.none()\n\n    # @timeit\n    def filter_by_content(self, queryset, name, value):\n        \"\"\"\n        Takes a QuerySet of Alerts and a string value. Returns a filtered\n        QuerySet of Alerts whose data includes the given value.\n        \"\"\"\n        if not value:\n            return queryset\n\n        try:\n            return self._filter_by_value(queryset, value)\n\n        except ValueError:\n            LOGGER.error('An error occurred while filtering Alerts')\n            return queryset\n\n\nclass AlertFilterBackend(DjangoFilterBackend):\n    \"\"\"\n    Provides a filter backend to only show |Alerts| that are either\n    associated with at least one of a given user's |Group| or are not\n    associated with any |Group|.\n    \"\"\"\n\n    def filter_queryset(self, request, queryset, view):\n        \"\"\"Return a filtered queryset.\n\n        Implements `custom filtering`_.\n\n        Parameters\n        ----------\n        request : Request\n             A `Request`_ for a resource.\n\n        queryset : QuerySet\n            A |QuerySet| to be filtered.\n\n        view : ModelViewSet\n            A `ModelViewSet`_.\n\n        Returns\n        -------\n        QuerySet\n            A |QuerySet| filtered to only show |Alerts| that are either\n            associated with at least one of a given user's |Group| or\n            are not associated with any |Group|.\n\n        \"\"\"\n        user = request.user\n        return Alert.objects.filter_by_user(user, queryset)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, 1, 1, 1, 1, null, 1, 1, null, 1, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, 1, 1, null, null, null, 1, 1, null, 1, 1, null, 0, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, 1, null, 1, null, null, null, 1, 1, null, 0, null, 1, 1, 1, null, 0, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, 1, 1, 1, 1, null, null, null, null, null, 1, null, null, null, null, null, null, 1, 1, 1, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, 1, 1, 1, 1, null, 1, null, 1, 1, null, null, 1, null, 1, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, 1, 1, null, null, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, 1, null, 1, null, null, null, 1, null, 1, null, null, null, 1, 1, null, 1, null, null, null, 1, null, 1, null, null, null, 1, 1, null, 1, null, null, null, null, 1, 1, 1, 1, 1, null, 1, null, null, null, 1, null, 1, null, 1, null, null, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, 1, null, 1, null, null, null, 1, null, 1, null, 1, null, null, null, null, 1, 1, 1, 1, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, 1, null, 1, 1, null, 1, 1, 1, 1, 1, 1, null, 1, null, 1, null, null, null, 1, 1, null, 0, null, null, 1, null, null, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, 1, 1, 1, null, 1, null, 1, 1, null, null, 1, null, 1, null, null, null, 1, 1, 1, 1, null], "name": "alerts/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines Alert class.\n\"\"\"\n\n# standard library\nimport json\nimport logging\nimport urllib\n\n# third party\nimport dateutil.parser\nfrom django.conf import settings\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.contrib.contenttypes.fields import GenericForeignKey\nfrom django.contrib.gis.db.models import PointField\nfrom django.contrib.postgres.fields import JSONField\nfrom django.db import models\nfrom django.forms import fields\nfrom django.utils.functional import cached_property\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.choices import (\n    ALERT_LEVEL_CHOICES,\n    ALERT_STATUS_CHOICES,\n    ALERT_OUTCOME_CHOICES,\n)\nfrom distilleries.models import Distillery\nfrom tags.models import Tag\nfrom utils.dbutils.dbutils import json_encodeable\nfrom utils.parserutils.parserutils import format_fields\n\n_ALERT_SETTINGS = settings.ALERTS\n_PRIVATE_FIELD_SETTINGS = settings.PRIVATE_FIELDS\n\n_LOGGER = logging.getLogger(__name__)\n\n# allow parsing of ISO8601 datetime strings\nfields.DateTimeField.strptime = lambda o, v, f: \\\n                                dateutil.parser.parse(v)  # pragma: no cover\n\n\nclass AlertManager(models.Manager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def api_queryset(self):\n        \"\"\"\n        Overrides the default get_queryset method to select the related\n        Distillery and AppUser.\n        \"\"\"\n        default_queryset = super(AlertManager, self).get_queryset()\n        return default_queryset.select_related('distillery__collection',\n                                               'distillery__container__bottle',\n                                               'distillery__container__label')\n    def with_codebooks(self):\n        \"\"\"\n        Overrides the default get_queryset method to select the related\n        Distillery and AppUser.\n        \"\"\"\n        default_queryset = self.api_queryset()\n        return default_queryset.select_related('distillery__company__codebook')\\\n                .prefetch_related('distillery__company__codebook__codenames')\n\n    @staticmethod\n    def _filter_by_group(user, queryset):\n        \"\"\"\n\n        \"\"\"\n        user_groups = user.groups.all()\n        annotated_qs = queryset.annotate(\n            monitor__group_cnt=models.Count('monitor__groups'),\n            watchdog__group_cnt=models.Count('watchdog__groups')\n        )\n        no_groups_q = models.Q(monitor__group_cnt=0, watchdog__group_cnt=0)\n        shared_groups_q = models.Q(monitor__groups__in=user_groups) | \\\n                          models.Q(watchdog__groups__in=user_groups)\n        if user_groups:\n            filtered_qs = annotated_qs.filter(no_groups_q | shared_groups_q)\n        else:\n            filtered_qs = annotated_qs.filter(no_groups_q)\n\n        return filtered_qs.distinct()\n\n    @staticmethod\n    def _filter_by_company(user, queryset):\n        \"\"\"\n\n        \"\"\"\n        if not user.is_staff:\n            query = models.Q(distillery__company=user.company) | \\\n                    models.Q(distillery__company__isnull=True)\n            return queryset.filter(query).distinct()\n        else:\n            return queryset\n\n    def filter_by_user(self, user, queryset=None):\n        \"\"\"\n        queryset : None or QuerySet of Alerts\n        \"\"\"\n        if queryset is not None:\n            alert_qs = queryset\n        else:\n            alert_qs = self.get_queryset()\n\n        if user:\n            filtered_qs = self._filter_by_company(user, alert_qs)\n            return self._filter_by_group(user, filtered_qs)\n        else:\n            return alert_qs.none()\n\n\nclass Alert(models.Model):\n    \"\"\"\n    Alerts generated by the backend and surfaced on the front end.\n\n    Attributes\n    ----------\n    alarm : Watchdog or Monitor\n        the object that generated the Alert\n    level : str\n        The priority of the Alert. Options are constrained to ALERT_LEVEL_CHOICES.\n\n    \"\"\"\n    _WATCHDOG = models.Q(app_label='watchdogs', model='watchdog')\n    _MONITOR = models.Q(app_label='monitors', model='monitor')\n    _ALARMS = _WATCHDOG | _MONITOR\n\n    level = models.CharField(\n        max_length=20,\n        choices=ALERT_LEVEL_CHOICES,\n        db_index=True\n    )\n    status = models.CharField(\n        max_length=20,\n        choices=ALERT_STATUS_CHOICES,\n        default='NEW',\n        db_index=True\n    )\n    outcome = models.CharField(\n        max_length=20,\n        choices=ALERT_OUTCOME_CHOICES,\n        null=True,\n        blank=True,\n        db_index=True\n    )\n    created_date = models.DateTimeField(auto_now_add=True, db_index=True)\n    content_date = models.DateTimeField(blank=True, null=True, db_index=True)\n    last_modified = models.DateTimeField(auto_now=True, blank=True, null=True)\n    assigned_user = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        blank=True,\n        null=True,\n        on_delete=models.PROTECT\n    )\n    alarm_type = models.ForeignKey(\n        ContentType,\n        limit_choices_to=_ALARMS,\n        blank=True,\n        null=True,\n        on_delete=models.PROTECT\n    )\n    alarm_id = models.PositiveIntegerField(blank=True, null=True)\n    alarm = GenericForeignKey('alarm_type', 'alarm_id')\n    distillery = models.ForeignKey(\n        Distillery,\n        blank=True,\n        null=True,\n        related_name='alert',\n        related_query_name='alerts',\n        db_index=True,\n        on_delete=models.PROTECT\n    )\n    doc_id = models.CharField(\n        max_length=255,\n        blank=True,\n        null=True,\n        db_index=True\n    )\n    data = JSONField(blank=True, null=True, default=dict)\n    location = PointField(blank=True, null=True)\n    title = models.CharField(max_length=255, blank=True, null=True)\n    incidents = models.PositiveIntegerField(default=1)\n    notes = models.TextField(blank=True, null=True)\n    tags = models.ManyToManyField(Tag, blank=True)\n\n    objects = AlertManager()\n\n    class Meta:\n        permissions = (\n            ('view_alert', 'Can see existing alerts'),\n        )\n        ordering = ['-id']\n\n    def __str__(self):\n        if self.title:\n            return 'PK %s: %s' % (self.pk, self.title)\n        elif self.pk:\n            return 'PK %s'  % self.pk\n        else:\n            return super(Alert, self).__str__()\n\n    def save(self, *args, **kwargs):\n        \"\"\"\n        Overrides the save() method to assign a title, content_date,\n        location, and data to a new Alert.\n        \"\"\"\n        if not self.data:\n            self._add_data()\n            self._add_location()\n            self._add_content_date()\n\n        # add a title if saving for the first time\n        if not self.pk:\n            self._add_title()\n\n        super(Alert, self).save(*args, **kwargs)\n\n    @property\n    def link(self):\n        \"\"\"\n\n        \"\"\"\n        base_url = settings.BASE_URL\n        alert_url = _ALERT_SETTINGS['ALERT_URL']\n        return urllib.parse.urljoin(base_url, alert_url + str(self.id))\n\n    @property\n    def coordinates(self):\n        \"\"\"\n\n        \"\"\"\n        if self.location:\n            return json.loads(self.location.json)\n\n    def _add_content_date(self):\n        \"\"\"\n        Adds a content_date from the teaser's date if it exists.\n        \"\"\"\n        self.content_date = self.teaser.get('date')\n\n    def _add_data(self):\n        \"\"\"\n\n        \"\"\"\n        self.data = json_encodeable(self.saved_data)\n\n    def _add_title(self):\n        \"\"\"\n        Adds a title if the Alert does not already have one.\n        \"\"\"\n        if not self.title:\n            self.title = self._format_title()\n\n    def _add_location(self):\n        \"\"\"\n        Adds a location if the Alert has one.\n        \"\"\"\n        self.location = self.teaser.get('location')\n\n    def _get_codebook(self):\n        \"\"\"\n        returns the Codebook for the Distillery associated with the Alert.\n        \"\"\"\n        if self.distillery:\n            return self.distillery.codebook\n\n    def _format_title(self):\n        \"\"\"\n        If the Alert's teaser has title defined, returns the title.\n        If not, returns an empty string.\n        \"\"\"\n        title = self.teaser.get('title', '')\n        max_length = Alert._meta.get_field('title').max_length\n        if title and len(title) > max_length:\n            return title[:max_length]\n        return title\n\n    def display_title(self):\n        \"\"\"\n        Return the Alert's title or a default title.\n        \"\"\"\n        return self.title or 'No title available'\n\n    display_title.short_description = _('title')\n\n    def redacted_title(self):\n        \"\"\"\n        Return a redacted version of the Alert's title or a default title.\n        \"\"\"\n        codebook = self._get_codebook()\n        if self.title and codebook:\n            return codebook.redact(self.title)\n        else:\n            return self.display_title()\n\n    @cached_property\n    def company(self):\n        \"\"\"\n        Returns the Company associated with the Alert's Distillery.\n        \"\"\"\n        if self.distillery:\n            return self.distillery.company\n\n    @cached_property\n    def saved_data(self):\n        \"\"\"\n        Attempts to locate the document which triggered the Alert.\n        If successful, returns a data dictionary of the document.\n        If not, returns an empty dictionary.\n        \"\"\"\n        if self.distillery and self.doc_id:\n            data = self.distillery.find_by_id(self.doc_id)\n            if data:\n                return data\n            else:\n                _LOGGER.warning('The document associated with id %s cannot be ' \\\n                               + 'found in %s.', self.doc_id, self.distillery)\n        return {}\n\n    def get_data_str(self):\n        \"\"\"\n        Returns the Alert data as a pretty-print string.\n        \"\"\"\n        return json.dumps(self.data, sort_keys=True, indent=4)\n\n    get_data_str.short_description = 'data'\n\n    def get_public_data_str(self):\n        \"\"\"\n        Returns the Alert data as a pretty-print string, with private\n        fields removed.\n        \"\"\"\n        public_data = {}\n        for (key, val) in self.data.items():\n            if key not in _PRIVATE_FIELD_SETTINGS:\n                public_data[key] = val\n        return json.dumps(public_data, sort_keys=True, indent=4)\n\n    @cached_property\n    def teaser(self):\n        \"\"\"\n        Returns a Taste representing teaser data for the document which\n        generated the Alert.\n        \"\"\"\n        if self.distillery:\n            return self.distillery.get_sample(self.data)\n        else:\n            return {}\n\n    def add_incident(self):\n        \"\"\"\n        Increments the number of incidents associated with the Alert.\n        \"\"\"\n        # using F instead of += increments the value using a SQL query\n        # and avoids race conditions\n        self.incidents = models.F('incidents') + 1\n        self.save()\n\n    def _summarize(self, include_empty=False):\n        \"\"\"\n\n        \"\"\"\n        source_data = self.get_public_data_str()\n\n        field_data = [\n            ('Alert ID', self.id),\n            ('Title', self.title),\n            ('Level', self.level),\n            ('Incidents', self.incidents),\n            ('Created date', self.created_date),\n            ('\\nCollection', self.distillery),\n            ('Document ID', self.doc_id),\n            ('Source Data', '\\n' + source_data),\n            ('\\nNotes', '\\n' + str(self.notes)),\n        ]\n\n        return format_fields(field_data, include_empty=include_empty)\n\n    def _summarize_with_comments(self, include_empty=False):\n        \"\"\"\n\n        \"\"\"\n        summary = self._summarize(include_empty=include_empty)\n\n        separator = '\\n\\n'\n        division = '-----'\n\n        if self.comments.count() > 0:\n            summary += separator\n            summary += division\n            for comment in self.comments.all():\n                summary += separator\n                summary += comment.summary()\n\n        return summary\n\n    def summary(self, include_empty=False, include_comments=False):\n        \"\"\"\n\n        \"\"\"\n        if include_comments:\n            return self._summarize_with_comments(include_empty=include_empty)\n        else:\n            return self._summarize(include_empty=include_empty)\n\n\nclass CommentManager(models.Manager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def get_queryset(self):\n        \"\"\"\n        Overrides the default get_queryset method to select related objects.\n        \"\"\"\n        default_queryset = super(CommentManager, self).get_queryset()\n        return default_queryset.select_related()\n\n\nclass Comment(models.Model):\n    \"\"\"\n    Comments for alert objects.\n    \"\"\"\n    alert = models.ForeignKey(\n        Alert,\n        db_index=True,\n        related_name='comments',\n        related_query_name='comment'\n    )\n    user = models.ForeignKey(settings.AUTH_USER_MODEL)\n    created_date = models.DateTimeField(auto_now_add=True)\n    content = models.TextField()\n\n    objects = CommentManager()\n\n    class Meta:\n        permissions = (\n            ('view_alert', 'Can see existing alerts'),\n        )\n        ordering = ['id']\n\n    def summary(self):\n        \"\"\"\n\n        \"\"\"\n        user = self.user.get_full_name()\n        date = self.created_date\n        content = self.content\n        return '%s commented at %s:\\n%s' % (user, date, content)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, 1, 1, 1, null, null, null, 1, 1, null, 1, null, null, null, 1, 1, 1, null, null, null, null, null, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, null, 1, 1, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, null, 1, 1, 1, null, null, null, null, null, null, null, null, 1, null, null, null, 1, 1, 1, 1, 1, 1, null, 1, 1, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, 1], "name": "alerts/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nSerializers for Alerts.\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom cyphon.choices import (\n    ALERT_LEVEL_CHOICES,\n    ALERT_OUTCOME_CHOICES,\n    ALERT_STATUS_CHOICES,\n)\nfrom appusers.models import AppUser\nfrom appusers.serializers import AppUserSerializer\nfrom distilleries.serializers import (\n    DistilleryDetailSerializer,\n    DistilleryListSerializer,\n)\nfrom responder.dispatches.serializers import DispatchSerializer\nfrom .models import Alert, Comment\n\nclass CommentSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Base serializer for the Comment class.\n    \"\"\"\n    class Meta:\n        model = Comment\n        fields = (\n            'id',\n            'alert',\n            'user',\n            'created_date',\n            'content',\n        )\n\nclass CommentDetailSerializer(CommentSerializer):\n    \"\"\"\n    Extended Comment serializer that shows the user object.\n    \"\"\"\n    user = AppUserSerializer()\n\n\nclass AlertListSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Alert list views.\n    \"\"\"\n    assigned_user = AppUserSerializer()\n    distillery = DistilleryListSerializer()\n    title = serializers.CharField(source='display_title')\n\n    class Meta:\n        model = Alert\n        depth = 1\n        fields = (\n            'id',\n            'assigned_user',\n            'content_date',\n            'created_date',\n            'distillery',\n            'incidents',\n            'level',\n            'outcome',\n            'status',\n            'title',\n            'url',\n        )\n\n\nclass RedactedAlertListSerializer(AlertListSerializer):\n    \"\"\"\n    Redacted serializer for Alert list views.\n    \"\"\"\n    title = serializers.CharField(source='redacted_title')\n\n\nclass AlertUpdateSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer used to update an Alert Model.\n    \"\"\"\n    level = serializers.ChoiceField(\n        required=False,\n        choices=ALERT_LEVEL_CHOICES,\n    )\n    class Meta:\n        model = Alert\n        fields = (\n            'assigned_user',\n            'notes',\n            'outcome',\n            'status',\n            'level',\n        )\n\n\nclass AlertDetailSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Alert detail views.\n    \"\"\"\n    assigned_user = AppUserSerializer()\n    comments = CommentDetailSerializer(many=True)\n    dispatches = DispatchSerializer(many=True)\n    distillery = DistilleryDetailSerializer()\n    location = serializers.JSONField(source='coordinates')\n    title = serializers.CharField(source='display_title')\n\n    class Meta:\n        model = Alert\n        depth = 2\n        fields = (\n            'id',\n            'assigned_user',\n            'comments',\n            'content_date',\n            'created_date',\n            'data',\n            'dispatches',\n            'distillery',\n            'incidents',\n            'level',\n            'link',\n            'location',\n            'notes',\n            'outcome',\n            'status',\n            'title',\n            'url',\n        )\n\n\nclass RedactedAlertDetailSerializer(AlertDetailSerializer):\n    \"\"\"\n    Redacted serializer for Alert detail views.\n    \"\"\"\n    title = serializers.CharField(source='redacted_title')\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, 1, 1, 1, 1, 1, 1, 1, null, null, null, null, null, 1, 1, 1, 1, 1, 1, 1, 1, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, null, 1, 0, 0, null, 0, 0, 0, null, null, null, 0, 0, null, 1, null, null, null, null, 1, null, null, null, null, 1, null, 1, 1, 1, null, 1, null, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, 1, 1, null, 0, 0, null, 1, null, null, null, 1, null, 1, null, null, null, 1, null, 1, 1, null, 1, 1, null, 1, null, 1, null, null, null, 1, 1, null, 1, null, null, null, null, null, 1, null, null, null, null, 1, null, 1, null, null, null, 1, null, 1, 1, null, 1, 1, 1, 1, 1, null, null, null, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, 1, null, 1, 1, 1, 1, 1, 1, null, 1, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, null, 1, 1, 1, 1, 1, 1, null, 1, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, null, 1, 1, 1, 1, 1, 1, null, 1, 1, 1, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, 1, 1, 1, 1, null, 1, 1, 1, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, 1, null, 1, 1, 1, 1, 1, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, 1, 1, null, 1, 1, null, 1, null, 0, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, 1, 1, null, 1, 1, null, 1, 0, null, 1, null, 1, null, null, null, 1, 1, 1, 1, 1, null, 1, 1, null, 1], "name": "alerts/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nProvides views for Alerts.\n\"\"\"\n\n# standard library\nimport datetime\nimport importlib\nimport json\n\n# third party\nfrom django.shortcuts import get_object_or_404\nfrom django.core.exceptions import PermissionDenied\nfrom django.core.serializers import serialize\nfrom django.utils import timezone\nfrom rest_framework.decorators import list_route\nfrom rest_framework.filters import DjangoFilterBackend\nfrom rest_framework import status\nfrom rest_framework.response import Response\nfrom rest_framework.pagination import (\n    LimitOffsetPagination,\n    PageNumberPagination,\n)\n\n# local\nfrom cyphon.choices import ALERT_LEVEL_CHOICES, ALERT_STATUS_CHOICES\nfrom cyphon.views import CustomModelViewSet\nfrom distilleries.models import Distillery\nfrom distilleries.serializers import DistilleryListSerializer\nfrom utils.dbutils.dbutils import count_by_group\nfrom .filters import AlertFilter\nfrom .models import Alert, Comment\nfrom .serializers import (\n    AlertDetailSerializer,\n    AlertListSerializer,\n    AlertUpdateSerializer,\n    RedactedAlertDetailSerializer,\n    RedactedAlertListSerializer,\n    CommentSerializer,\n    CommentDetailSerializer,\n)\n\n\nclass AlertPagination(LimitOffsetPagination):\n    \"\"\"\n    Pagination class for overriding the default pagination for Alerts.\n    \"\"\"\n    default_limit = 20\n    max_limit = 100\n\n\nclass AlertViewSet(CustomModelViewSet):\n    \"\"\"\n    A simple ViewSet for viewing and editing Alerts.\n    \"\"\"\n    queryset = Alert.objects.api_queryset()\n    filter_class = AlertFilter\n    pagination_class = AlertPagination\n    serializer_class = AlertDetailSerializer\n    custom_filter_backends = ['alerts.filters.AlertFilterBackend']\n\n    MAX_DAYS = 30\n\n    def get_queryset(self):\n        \"\"\"\n        Overrides the default method for returning the ViewSet's\n        queryset.\n        \"\"\"\n        use_redaction = self.request.user.use_redaction\n        if use_redaction:\n            return Alert.objects.with_codebooks()\n        else:\n            # ensure queryset is re-evaluated on each request\n            return self.queryset.all()\n\n    def partial_update(self, request, pk):\n        alert = self.get_object()\n        serializer = AlertUpdateSerializer(alert, data=request.data)\n\n        if serializer.is_valid():\n            updated_alert = serializer.save()\n            detail_serializer = AlertDetailSerializer(\n                updated_alert,\n                context={'request': request},\n            )\n            return Response(detail_serializer.data)\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\n    def get_serializer_class(self):\n        \"\"\"\n        Overrides the default method for returning the ViewSet's\n        serializer.\n        \"\"\"\n        assert self.serializer_class is not None, (\n            \"'%s' should either include a `serializer_class` attribute, \"\n            \"or override the `get_serializer_class()` method.\"\n            % type(self).__name__\n        )\n        use_redaction = self.request.user.use_redaction\n\n        if self.action is 'list':\n            if use_redaction:\n                return RedactedAlertListSerializer\n            else:\n                return AlertListSerializer\n        else:\n            if use_redaction:\n                return RedactedAlertDetailSerializer\n            else:\n                return self.serializer_class\n\n    @staticmethod\n    def _get_date(days_ago):\n        \"\"\"\n\n        \"\"\"\n        try:\n            days = int(days_ago)\n            date_time = timezone.now() - datetime.timedelta(days=days)\n            return date_time.replace(hour=0, minute=0,\n                                     second=0, microsecond=0)\n        except (ValueError, TypeError):\n            return None\n\n    def _get_filtered_alerts(self):\n        \"\"\"\n\n        \"\"\"\n        return self.filter_queryset(self.get_queryset())\n\n    def _filter_by_timeframe(self, start_date=None, end_date=None):\n        \"\"\"\n\n        \"\"\"\n        queryset = self._get_filtered_alerts()\n\n        if start_date is not None:\n            queryset = queryset.filter(created_date__gte=start_date)\n\n        if end_date is not None:\n            queryset = queryset.filter(created_date__lt=end_date)\n\n        return queryset\n\n    def _filter_by_start_date(self, days_ago):\n        \"\"\"\n\n        \"\"\"\n        start_date = self._get_date(days_ago)\n        return self._filter_by_timeframe(start_date=start_date)\n\n    @staticmethod\n    def _counts_by_field(queryset, field_name, choices):\n        \"\"\"\n        Provides a REST API endpoint for GET requests for alert counts\n        by level.\n        \"\"\"\n        counts = count_by_group(\n            queryset=queryset,\n            column=field_name,\n            options=choices\n        )\n        return counts[field_name]\n\n    def _timeseries(self, days, field_name, choices):\n        \"\"\"\n\n        \"\"\"\n        counts = {'date': []}\n\n        for (value, dummy_text) in choices:\n            counts[value] = []\n\n        for day in reversed(range(1, days + 1)):\n            start_date = self._get_date(day)\n            end_date = self._get_date(day - 1)\n            queryset = self._filter_by_timeframe(start_date, end_date)\n            date_cnt = self._counts_by_field(\n                queryset=queryset,\n                field_name=field_name,\n                choices=choices\n            )\n            counts['date'].append(start_date.date())\n            for (value, dummy_text) in choices:\n                counts[value].append(date_cnt[value])\n\n        return counts\n\n    @staticmethod\n    def _handle_missing_days_param():\n        \"\"\"\n        Returns a Response containing an error message for a missing\n        or improper `days` parameter.\n        \"\"\"\n        msg = 'Please provide an integer for the days parameter'\n        return Response({'error': msg})\n\n    def _exceeds_max_days(self):\n        \"\"\"\n        Returns a Response containing an error message when a `days`\n        parameter exceeds the maximum allowed.\n        \"\"\"\n        msg = 'A maximum of %s days is permitted' % self.MAX_DAYS\n        return Response({'error': msg})\n\n    @list_route(methods=['get'], url_path='levels')\n    def counts_by_level(self, request):\n        \"\"\"\n        Provides a REST API endpoint for GET requests for alert counts\n        by level.\n        \"\"\"\n        days = request.query_params.get('days')\n\n        try:\n            days = int(days)\n            if days > self.MAX_DAYS:\n                return self._exceeds_max_days()\n        except (TypeError, ValueError):\n            return self._handle_missing_days_param()\n\n        queryset = self._filter_by_start_date(days)\n        counts = self._counts_by_field(\n            queryset=queryset,\n            field_name='level',\n            choices=ALERT_LEVEL_CHOICES\n        )\n        return Response(counts)\n\n    @list_route(methods=['get'], url_path='statuses')\n    def counts_by_status(self, request):\n        \"\"\"\n        Provides a REST API endpoint for GET requests for alert counts\n        by status.\n        \"\"\"\n        days = request.query_params.get('days')\n\n        try:\n            days = int(days)\n            if days > self.MAX_DAYS:\n                return self._exceeds_max_days()\n        except (TypeError, ValueError):\n            return self._handle_missing_days_param()\n\n        queryset = self._filter_by_start_date(days)\n        counts = self._counts_by_field(\n            queryset=queryset,\n            field_name='status',\n            choices=ALERT_STATUS_CHOICES\n        )\n        return Response(counts)\n\n    @list_route(methods=['get'], url_path='collections')\n    def counts_by_collection(self, request):\n        \"\"\"\n        Provides a REST API endpoint for GET requests for alert counts\n        by Collection.\n        \"\"\"\n        days = request.query_params.get('days')\n\n        try:\n            days = int(days)\n            if days > self.MAX_DAYS:\n                return self._exceeds_max_days()\n        except (TypeError, ValueError):\n            return self._handle_missing_days_param()\n\n        queryset = self._filter_by_start_date(days)\n        distilleries = Distillery.objects.filter(alerts__in=queryset)\n        counts = {}\n\n        for distillery in distilleries:\n            filtered_qs = queryset.filter(distillery=distillery)\n            counts[str(distillery)] = filtered_qs.count()\n\n        return Response(counts)\n\n    @list_route(methods=['get'], url_path='locations')\n    def locations(self, request):\n        \"\"\"\n        Provides a REST API endpoint for GET requests for alert\n        locations.\n\n        WARNING\n        -------\n        Alerts titles will not be redacted.\n\n        \"\"\"\n        days = request.query_params.get('days')\n\n        try:\n            days = int(days)\n            if days > self.MAX_DAYS:\n                return self._exceeds_max_days()\n        except (TypeError, ValueError):\n            return self._handle_missing_days_param()\n\n        queryset = self._filter_by_start_date(days)\n        location_qs = queryset.filter(location__isnull=False)\n        fields = (\n            'pk',\n            'location',\n            'title',\n            'level',\n            'incidents',\n        )\n        geojson = serialize('geojson', location_qs, fields=fields)\n        return Response(json.loads(geojson))\n\n    @list_route(methods=['get'], url_path='level-timeseries')\n    def level_timeseries(self, request):\n        \"\"\"\n        Provides a REST API endpoint for GET requests for a timeseries\n        of alert counts by level.\n        \"\"\"\n        days = request.query_params.get('days')\n\n        try:\n            days = int(days)\n            if days > self.MAX_DAYS:\n                return self._exceeds_max_days()\n        except (TypeError, ValueError):\n            return self._handle_missing_days_param()\n\n        counts = self._timeseries(\n            days=days,\n            field_name='level',\n            choices=ALERT_LEVEL_CHOICES\n        )\n        return Response(counts)\n\n    @list_route(methods=['get'], url_path='distilleries')\n    def distilleries(self, request):\n        \"\"\"\n        Provides a REST API endpoint for GET requests for Distilleries\n        associated with Alerts.\n        \"\"\"\n        alerts = self._get_filtered_alerts()\n        distilleries = Distillery.objects.filter(alerts__in=alerts).distinct()\n        page = self.paginate_queryset(distilleries)\n\n        if page is not None:\n            serializer = DistilleryListSerializer(page, many=True,\n                                                  context={'request': request})\n            return self.get_paginated_response(serializer.data)\n\n        return Response(serializer.data)\n\n\nclass CommentPagination(PageNumberPagination):\n    \"\"\"\n    Pagination for comments view.\n    \"\"\"\n    page_size = 100\n\n\nclass CommentViewSet(CustomModelViewSet):\n    \"\"\"\n    Viewset for viewing and editing Alert Comments.\n    \"\"\"\n    queryset = Comment.objects.all().order_by('created_date')\n    pagination_class = CommentPagination\n    serializer_class = CommentSerializer\n    filter_fields = ['alert', 'user']\n\n    def _is_user_protected_request(self):\n        \"\"\"\n        Checks to see if the request is protected per user.\n        \"\"\"\n        user_protected_requests = ['PATCH', 'PUT', 'DELETE']\n        return self.request.method in user_protected_requests\n\n    def get_serializer_class(self):\n        base_serializer_actions = ['create', 'update', 'partial_update']\n\n        if self.action in base_serializer_actions:\n            return CommentSerializer\n\n        return CommentDetailSerializer\n\n    def get_object(self):\n        \"\"\"\n        Gets an object for single object views.\n        \"\"\"\n        queryset = self.get_queryset()\n        primary_key = self.kwargs[self.lookup_field]\n        obj = get_object_or_404(queryset, pk=primary_key)\n        self.check_object_permissions(self.request, obj)\n        is_comment_user = self.request.user.id is obj.user.id\n\n        if self._is_user_protected_request() and not is_comment_user:\n            raise PermissionDenied()\n\n        return obj\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "ambassador/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "ambassador/emissaries/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, 1, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, 1, 1, null, 1, 1, null, 1, null, null, null, null, 0, null, 1, null, null, null, 0, null, 1, null, null, null, 0, null, 1, null, null, null, null, 0, 0, 0, 0, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, 0, 0, null, 1, null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, null, 1, null, null, null, null, null, null, null, null, null, null, 0, 0, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, null, 0, 0, 0, null, null, null, null, null, null, 0, 0, 0, 0, null, 0, null], "name": "ambassador/emissaries/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines an |Emissary| base class for interacting with third-party APIs.\n\nNote\n----\nThe |Emissary| class is the basis for the |Courier| and |Plumber|\nclasses.\n\n\"\"\"\n\n# standard library\nimport datetime\n\n# third party\nfrom django.db import models\nfrom django.utils import timezone\n\n# local\nfrom ambassador.passports.models import Passport\nfrom ambassador.visas.models import Visa\nfrom cyphon.models import SelectRelatedManager, GetByNameMixin\n\n\nclass EmissaryManager(SelectRelatedManager, GetByNameMixin):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def find_public(self, endpoint):\n        \"\"\"Get |Emissaries| that are available to all users.\n\n        Parameters\n        ----------\n        endpoint : |Endpoint|\n            An |Endpoint| used to find related |Emissaries|.\n\n        Returns\n        -------\n        |QuerySet|\n            A |QuerySet| containing |Emissaries| available to all\n            |AppUsers|.\n\n        \"\"\"\n        return self.filter(\n            passport__public=True,\n            endpoints=endpoint\n        )\n\n    def find_private(self, endpoint, user):\n        \"\"\"Find |Emissaries| that are assigned to the given user.\n\n        Parameters\n        ----------\n        endpoint : |Endpoint|\n            An |Endpoint| used to find related |Emissaries|.\n\n        user : |AppUser|\n            The |AppUser| used to find available |Emissaries|.\n\n        Returns\n        -------\n        |QuerySet|\n            A |QuerySet| containing |Emissaries| available to the `user`\n            that have a |Passport| that is not\n            :attr:`~ambassador.passports.models.Passport.public`.\n\n        \"\"\"\n        return self.filter(\n            passport__public=False,\n            endpoints=endpoint,\n            passport__users=user\n        )\n\n    def find_any(self, endpoint, user=None):\n        \"\"\"Find any |Emissary| that can be used for the API call.\n\n        Parameters\n        ----------\n        endpoint : |Endpoint|\n            An |Endpoint| used to find related |Emissaries|.\n\n        user : |AppUser| or |None|, optional\n            The |AppUser| used to find available |Emissaries|.\n\n        Returns\n        -------\n        |QuerySet|\n            A |QuerySet| containing |Emissaries| that are compatible\n            with the `endpoint` and `user`.\n\n        Note\n        ----\n        If `user` is |None| or the |AppUser| has no |Emissaries|\n        assigned to them, only |Emissaries| with a\n        :attr:`~ambassador.passports.models.Passport.public` |Passport|\n        will be returned.\n\n        \"\"\"\n        private_emissaries = self.find_private(endpoint, user)\n        if private_emissaries:\n            return private_emissaries\n        else:\n            return self.find_public(endpoint)\n\n\nclass Emissary(models.Model):\n    \"\"\"\n    Provides access to one or more API enpdoints.\n\n    Attributes\n    ----------\n    name : str\n        The identifier for the |Emissary|.\n\n    passport : Passport\n        The |Passport| used by the |Emissary| to access the |Emissary|'s\n        `endpoints`. (See note.)\n\n    visa : Visa\n        The |Visa| used to define a rate limit for the |Emissary| when\n        accessing any of the |Emissary|'s `endpoints`.\n\n    Note\n    ----\n    The `endpoints` attribute is defined in |Emissary| subclasses,\n    such as the |Courier| and |Plumber| classes.\n\n    \"\"\"\n    name = models.CharField(max_length=40, unique=True)\n    passport = models.ForeignKey(Passport, null=True)\n    visa = models.ForeignKey(Visa, blank=True, null=True)\n\n    class Meta:\n        abstract = True\n        unique_together = ('passport', 'visa')\n\n    def __str__(self):\n        return self.name\n\n    def _get_call_count(self, start_time):\n        \"\"\"\n        Takes a datetime and returns an int of the number of calls\n        recorded since that time.\n        \"\"\"\n        return self.passport.get_call_count(start_time)\n\n    def _get_allowed_calls(self):\n        \"\"\"\n        Returns the number of calls allowed in a request interval.\n        \"\"\"\n        return self.visa.calls\n\n    def _get_time_interval_in_minutes(self):\n        \"\"\"\n        Returns the number of minutes in a request interval.\n        \"\"\"\n        return self.visa.get_request_interval_in_minutes()\n\n    def _get_interval_start_time(self):\n        \"\"\"\n        Returns a datetime for the start of the current rate limit\n        interval.\n        \"\"\"\n        current_time = timezone.now()\n        minutes = self._get_time_interval_in_minutes()\n        time_delta = datetime.timedelta(minutes=minutes)\n        return current_time - time_delta\n\n    def _has_endpoint(self, endpoint):\n        \"\"\"\n        Takes an Endpoint and returns a Boolean indicating whether it\n        is associated with the Emissary.\n        \"\"\"\n        return self.endpoints.filter(pk=endpoint.pk).exists()\n\n    def _has_valid_visa(self):\n        \"\"\"\n        Returns a Boolean indiacting whether the Emissary has a valid\n        Visa.\n        \"\"\"\n        if self.visa is not None:\n            return self.visa_is_valid()\n        else:\n            return False\n\n    def _can_access_endpoint(self, endpoint):\n        \"\"\"\n        Takes an Endpoint and returns a Boolean indicating whether the\n        Emissary ia allowed to access it.\n        \"\"\"\n        if endpoint.visa_required:\n            return self._has_valid_visa()\n        else:\n            return True\n\n    def call_count(self):\n        \"\"\"Get the number of calls made in the current rate limit\n        interval.\n\n        Returns\n        -------\n        |int|\n            The number of calls made during the current rate limit\n            interval.\n\n        \"\"\"\n        start_time = self._get_interval_start_time()\n        return self._get_call_count(start_time)\n\n    def remaining_calls(self):\n        \"\"\"Get the number of calls that can be made in the current\n        interval.\n\n        Returns\n        -------\n        |int|\n            The number of additional calls that can be made in the\n            current request interval.\n\n        \"\"\"\n        assert self.visa is not None\n        calls_allowed = self._get_allowed_calls()\n        calls_made = self.call_count()\n        return calls_allowed - calls_made\n\n    def visa_is_valid(self):\n        \"\"\"Return |True| if the |Emissary| has not reached its |Visa|'s\n        limit.\n\n        Returns\n        -------\n        bool\n            Whether the |Emissary| can make additional calls in the\n            current rate limit interval.\n\n        \"\"\"\n        assert self.visa is not None\n        return self.remaining_calls() > 0\n\n    def enabled(self, endpoint):\n        \"\"\"Return |True| if the |Emissary| can make API calls to the\n        endpoint.\n\n        Parameters\n        ----------\n        endpoint : |Endpoint|\n            The |Endpoint| to be accessed by the |Emissary|.\n\n        Returns\n        -------\n        |bool|\n            Whether the |Emissary| can make API calls to the `endpoint`.\n\n        Note\n        ----\n        This method will return |False| if any of the following applies\n        to the |Emissary|:\n\n            - it is not associated with the `endpoint`\n            - it lacks a |Visa| and the `endpoint` requires a |Visa|\n            - it has exceeded the rate limit defined by its |Visa|\n\n        \"\"\"\n        if self._has_endpoint(endpoint):\n            return self._can_access_endpoint(endpoint)\n        else:\n            return False\n\n    def calculate_query_time_in_minutes(self, query_cnt):\n        \"\"\"Get the number of minutes required to execute the queries.\n\n        Parameters\n        ----------\n        query_cnt : |int|\n            The number of queries that need to be performed.\n\n        Returns\n        -------\n        |float|\n            The number of minutes required to fulfill all the queries\n            based on the |Emissary|'s |Visa|.\n\n        \"\"\"\n        remaining_calls = self._get_remaining_calls()\n        balance = remaining_calls - query_cnt\n\n        if balance < 0:\n            allowed_calls = self.get_allowed_calls()\n            needed_calls = abs(balance)\n\n            # get the floor of the number of intervals needed to fulfill\n            # all the requests; we use the floor because we assume we\n            # will make the next batch of requests as soon as a new\n            # interval starts, rather than spreading them out over the\n            # interval - so we don't count time from the last interval\n            num_intervals = needed_calls // allowed_calls\n            extra_time = num_intervals * self.get_time_interval_in_minutes()\n            time_left_in_current_intrvl = self.get_time_remaining_in_minutes()\n            return time_left_in_current_intrvl + extra_time\n        else:\n            return 0\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "ambassador/endpoints/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, 1, 1, 1, null, null, 1, 1, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, 1, null, 1, 1, 1, 1, null, 1, null, null, null, null, 1, null, null, null, null, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, 1, 1, null, null, 1, null, null, 1, 1, null, 1, null], "name": "ambassador/endpoints/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines the |Endpoint| base class. An |Endpoint| represents an API\nendpoint. It stores information about the API handler used to submit\nrequests to the endpoint.\n\nNote\n----\nThe |Endpoint| class is the basis for the |Action| and |Pipe| classes.\n\n\"\"\"\n\n# standard library\nimport importlib\nimport logging\n\n# third party\nfrom django.db import models\nfrom django.core.exceptions import ObjectDoesNotExist\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom platforms.registry import PLATFORMS_PACKAGE, HANDLERS_MODULE\nfrom utils.validators.validators import IDENTIFIER_VALIDATOR\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass EndpointManager(models.Manager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def get_by_natural_key(self, platform, api_class):\n        \"\"\"Allow retrieval of an |Endpoint| by its natural key.\n\n        Parameters\n        ----------\n        platform : str\n            The primary key of the |Platform| associated with the\n            |Endpoint|.\n\n        api_class : str\n            The |Endpoint|'s :attr:`~ambassador.endpoints.models.Endpoint.api_class`.\n\n        Returns\n        -------\n        |Endpoint|\n            The |Endpoint| associated with the `platform` and `api_class`.\n\n        \"\"\"\n        try:\n            return self.get(platform__name=platform, api_class=api_class)\n        except ObjectDoesNotExist:\n            LOGGER.error('%s for \"%s %s\" does not exist',\n                         self.model.__name__, platform, api_class)\n\n    def get_id_from_natural_key(self, natural_key):\n        \"\"\"Get an |Endpoint|'s primary key.\n\n        Parameters\n        ----------\n        natural_key : |list| of |str|\n            A |list| containing the primary key of the |Platform|\n            associated with the |Endpoint| and the |Endpoint|'s\n            :attr:`~ambassador.endpoints.models.Endpoint.api_class`..\n\n        Returns\n        -------\n        int\n            The |Endpoint|'s primary key.\n\n        \"\"\"\n        handler = self.get_by_natural_key(*natural_key)\n        return handler.pk\n\n\nclass Endpoint(models.Model):\n    \"\"\"\n    Specifies the module and |Transport| class that should be used to\n    access an API endpoint of a |Platform|, such as Twitter or JIRA.\n    An |Endpoint| can create a |Transport| object instance for handling\n    a request to the endpoint.\n\n    Since a |Platform| may be accessed through more than one API (e.g.,\n    Twitter Search API vs. Twitter Public API), |Endpoints| have a\n    many-to-one relationship with |Platforms|.\n\n    Attributes\n    ----------\n    api_module : str\n        The name of the module that will handle the API request\n        (i.e., the name of the Python file without the extension,\n        e.g., 'handlers').\n\n    api_class : str\n        The name of the class that will handle the API request\n        (e.g., 'SearchAPI').\n\n    visa_required : bool\n        Whether requests to the API endpoint are rate limited.\n        If |True|, an |Emissary| must have a |Visa| to access the\n        |Endpoint|. The |Visa| defines the rate limit that should\n        apply to the |Emissary|'s |Passport| (API key).\n\n    Note\n    ----\n    The `platform` attribute is defined in |Endpoint| subclasses,\n    such as the |Action| and |Pipe| classes.\n\n    \"\"\"\n    api_module = models.CharField(\n        max_length=32,\n        validators=[IDENTIFIER_VALIDATOR],\n        default=HANDLERS_MODULE,\n        help_text=_('The module that will handle the API request.')\n    )\n    api_class = models.CharField(\n        max_length=32,\n        validators=[IDENTIFIER_VALIDATOR],\n        help_text=_('The class that will handle the API request.')\n    )\n    visa_required = models.BooleanField(\n        default=False,\n        help_text=_('Whether API calls are restricted by a Visa.')\n    )\n\n    class Meta:\n        abstract = True\n\n    def __str__(self):\n        api = self.api_class\n        platform = str(self.platform).title()\n        return '%s %s' % (platform, api)\n\n    def _get_module(self):\n        \"\"\"\n        Returns the module for handling the API.\n        \"\"\"\n        # e.g., 'platforms.twitter.handler'\n        module_full_name = '%s.%s.%s' % (PLATFORMS_PACKAGE,\n                                         self.platform.name,\n                                         self.api_module)\n\n        # load the module (will raise ImportError if module cannot be loaded)\n        module = importlib.import_module(module_full_name)\n\n        return module\n\n    def create_request_handler(self, user, params=None):\n        \"\"\"Create a handler to send a request to an API enpoint.\n\n        Returns\n        -------\n        |Transport|\n            A |Transport| subclass that will send the request to the API\n            endpoint and process the result.\n\n        \"\"\"\n        class_name = self.api_class\n        module = self._get_module()\n\n        # get the API class (will raise AttributeError if class cannot be found)\n        api = getattr(module, class_name)\n\n        # create an instance of the class\n        params = params or {}\n        request_handler = api(endpoint=self, user=user, **params)\n\n        return request_handler\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, 1, null, null, null, 1, null], "name": "ambassador/exceptions.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nExceptions related to the :doc:`/modules/ambassador` package.\n\"\"\"\n\nclass EmissaryDoesNotExist(Exception):\n    \"\"\"\n    Raised when a requested |Emissary| does not exist.\n    \"\"\"\n    pass\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "ambassador/passports/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null], "name": "ambassador/passports/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclass for Passports and registers them with\nDjango Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom .models import Passport\n\n\nclass PassportAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Passports.\n    \"\"\"\n    exclude = []\n\n\nadmin.site.register(Passport, PassportAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, 1, 1, null, null, 1, 1, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, null, null, null, 1, 1, 1, 1, null, null, null, 1, null, null, null, null, null, null, null, 1, null, 1, 0, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0], "name": "ambassador/passports/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a |Passport| class for storing authentication information for\na third-party API.\n\"\"\"\n\n# third party\nfrom django.conf import settings\nfrom django.core.files.storage import FileSystemStorage\nfrom django.db import models\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.models import GetByNameManager\nfrom utils.validators.validators import key_file_validator\n\n_KEYS_DIR = settings.KEYS_DIR\n_KEYS_STORAGE = FileSystemStorage(location=_KEYS_DIR)\n\n\nclass Passport(models.Model):\n    \"\"\"\n    Provides a generalized set of credentials used by APIs to\n    authenticate a user or app. Different APIs may make use of different\n    fields in the Passport model.\n\n    Attributes\n    ----------\n    name : str\n        An identifier for the |Passport|.\n\n    key : `str` or `None`\n        The consumer/client/developer key used to authenticate requests.\n\n    file : `str` or `None`\n        Path to a file for a public or private key, depending on the\n        needs of the API authenticator. Acceptable extensions are\n        defined by :const:`~KEY_FILE_TYPES`.\n\n    secret : `str` or `None`\n        A client/consumer secret used to authenticate requests.\n\n    access_token : `str` or `None`\n        An access token used for OAuth authentication.\n\n    access_token_secret : `str` or `None`\n        An access token secret used for OAuth authentication.\n\n    public : bool\n        Whether the |Passport| can be used by any user.\n\n    users : AppUsers\n        Specific |AppUsers| who are allowed to use the Passport.\n\n    \"\"\"\n\n    KEY_FILE_TYPES = ['.pem', '.pub']\n    \"\"\"\n    A |list| of acceptable extensions for a :attr:`Passport.file`.\n    \"\"\"\n\n    name = models.CharField(max_length=40, unique=True)\n    key = models.CharField(max_length=255, null=True, blank=True)\n    file = models.FileField(\n        null=True,\n        blank=True,\n        storage=_KEYS_STORAGE,\n        validators=[key_file_validator]\n    )\n    secret = models.CharField(max_length=255, null=True, blank=True)\n    access_token = models.CharField(max_length=255, blank=True)\n    access_token_secret = models.CharField(max_length=255, blank=True)\n    public = models.BooleanField(\n        default=False,\n        help_text=_('Make available to all registered Users.')\n    )\n    users = models.ManyToManyField(\n        settings.AUTH_USER_MODEL,\n        related_name='passports',\n        related_query_name='passport',\n        blank=True,\n        help_text=_('If not Public, restrict use to these Users.')\n    )\n\n    objects = GetByNameManager()\n\n    def __str__(self):\n        return self.name\n\n    def get_call_count(self, start_time):\n        \"\"\"Get the number of times the |Passport| has been used since start_time.\n\n        Parameters\n        ----------\n        start_time : |datetime|\n            The start of the time frame in which calls should be counted.\n\n        Returns\n        -------\n        int\n            The number of |Stamps| associated with the |Passport| that\n            have a :attr:`~ambassador.stamps.models.Stamp.job_start`\n            greater or equal to `start_time`. This represents the number\n            of API calls made with the |Passport| in that time.\n\n        \"\"\"\n        return self.stamps.filter(job_start__gte=start_time).count()\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "ambassador/platforms/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, 1, 1, null, 1, 1, null], "name": "ambassador/platforms/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a |Platform| base class. Handles settings for which third-party\nplatforms are enabled.\n\nNote\n----\nThe |Platform| class is the basis for the |Destination| and |Reservoir|\nclasses.\n\n\"\"\"\n\n# third party\nfrom django.db import models\n\n# local\nfrom cyphon.models import GetByNameManager, FindEnabledMixin\nfrom platforms.registry import PLATFORM_CHOICES\n\n\nclass PlatformManager(GetByNameManager, FindEnabledMixin):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n    pass\n\n\nclass Platform(models.Model):\n    \"\"\"\n    Determines whether a third-party platform (such as Twitter) is\n    enabled for use. A |Platform| corresponds to a subpackage in the\n    :doc:`/modules/platforms` package.\n\n    Attributes\n    ----------\n    name : str\n        The name of the :doc:`/modules/platforms` subpackage for\n        accessing a third-party API (e.g., 'twitter').\n\n    enabled : bool\n        Whether the |Platform| is available for use.\n\n    \"\"\"\n    name = models.CharField(max_length=16, unique=True,\n                            choices=PLATFORM_CHOICES)\n    enabled = models.BooleanField(default=True)\n\n    class Meta:\n        abstract = True\n\n    def __str__(self):\n        return self.name\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "ambassador/records/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, 0, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, null], "name": "ambassador/records/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a |Record| base class for storing a record of an API call.\n\nNote\n----\nThe |Record| class is the basis for the |Dispatch| and |Invoice| classes.\n\n\"\"\"\n\n# third party\nfrom django.db import models\n\n# local\nfrom ambassador.stamps.models import Stamp\nfrom cyphon.models import SelectRelatedManager\n\n\nclass RecordManager(SelectRelatedManager):\n    \"\"\"\n    A model manager for |Records|.\n    \"\"\"\n    pass\n\n\nclass Record(models.Model):\n    \"\"\"\n    Provides a record of an API call.\n\n    Attributes\n    ----------\n    stamp : Stamp\n        A |Stamp| recording the details of the API call.\n\n    Note\n    ----\n    Much of the information about the API call is stored in the\n    |Record|'s |Stamp|, rather than in the |Record| itself. This is\n    to permit development of |Record| subclasses -- such as |Dispatches|\n    and |Invoices| -- that have more specialized attributes, while still\n    allowing information common to all API calls to be stored in the\n    same database table -- the one for |Stamps|.\n\n    \"\"\"\n    stamp = models.ForeignKey(Stamp, null=True, blank=True)\n\n    class Meta:\n        abstract = True\n\n    def get_endpoint(self):\n        \"\"\"Get the |Endpoint| associated with the |Record|.\n\n        Returns\n        -------\n        |Endpoint|\n            The |Endpoint| associated with the |Record|.\n\n        \"\"\"\n        return self.stamp.endpoint\n\n    def finalize(self, cargo):\n        \"\"\"Update the |Record|'s |Stamp| with the response from the API.\n\n        Parameters\n        ----------\n        cargo : |Cargo|\n              The |Cargo| returned by a |Transport| after calling an API.\n\n        Returns\n        -------\n        |Record|\n            self\n\n        \"\"\"\n        self.stamp.finalize(status_code=cargo.status_code, notes=cargo.notes)\n        return self\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "ambassador/stamps/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null], "name": "ambassador/stamps/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclass for Stamps and registers them with\nDjango Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom .models import Stamp\n\n\nclass StampAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Stamps.\n    \"\"\"\n    exclude = []\n    readonly_fields = [\n        'content_type',\n        'object_id',\n        'passport',\n        'user',\n        'job_start',\n        'job_end',\n        'status_code',\n        'notes'\n    ]\n\n\nadmin.site.register(Stamp, StampAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, 1, 1, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, 1, 1, 1, null, null, null, null, 1, 1, 1, 1, 1, null, 1, 1, null, 1, 0, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, 0, 0, 0, null, 1, null, null, null, null, 1, null, null, null, 1, null], "name": "ambassador/stamps/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Visa class for the documenting API calls. \n\"\"\"\n\n# third party\nfrom django.conf import settings\nfrom django.contrib.contenttypes.fields import GenericForeignKey\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.db import models\nfrom django.utils import timezone\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom ambassador.passports.models import Passport\n\n\nclass Stamp(models.Model):\n    \"\"\"\n    Stores a record of an API request and its response.\n\n    Attributes\n    ----------\n    content_type : ContentType\n        The |ContentType| of the model representing the API endpoint.\n        This can be either an |Action| or a |Pipe|.\n\n    object_id : int\n        A positive |int| representing the Object Id of the `endpoint`.\n\n    endpoint : `Action` or `Pipe`\n        An |Action| or |Pipe| representing an API endpoint.\n\n    passport : Passport\n        A |Passport| used to access the API endpoint.\n\n    user : `AppUser` or `None`\n        The |AppUser| who initiated the call to the API endpoint.\n\n    job_start : datetime\n        A |datetime| representing when the request to the API was made.\n        The default is the current time.\n\n    job_end : `datetime` or `None`\n        A |datetime| when the response from the API was recieved. In the\n        case of a streaming API, indicates when the stream was closed.\n\n    status_code : `str` or `None`\n        The HTTP status code for the API response (e.g., '200').\n\n    notes : `str` or `None`\n        Additional information about the API response, such as an error\n        message.\n\n    \"\"\"\n    _ACTION = models.Q(app_label='actions', model='action')\n    _PIPE = models.Q(app_label='pipes', model='pipe')\n    _CONTENT_TYPES = _ACTION | _PIPE\n\n    content_type = models.ForeignKey(\n        ContentType,\n        limit_choices_to=_CONTENT_TYPES,\n        verbose_name=_('endpoint type')\n    )\n    object_id = models.PositiveIntegerField(verbose_name=_('endpoint id'))\n    endpoint = GenericForeignKey()\n    passport = models.ForeignKey(\n        Passport,\n        related_name='stamps',\n        related_query_name='stamp'\n    )\n    user = models.ForeignKey(settings.AUTH_USER_MODEL, null=True, blank=True)\n    job_start = models.DateTimeField(default=timezone.now)\n    job_end = models.DateTimeField(null=True, blank=True)\n    status_code = models.CharField(max_length=3, null=True, blank=True)\n    notes = models.TextField(null=True, blank=True)\n\n    class Meta:\n        ordering = ['-id']\n\n    def __str__(self):\n        return 'PK %s: %s (%s) %s' % (self.pk, self.endpoint, self.status_code,\n                                      self.job_start)\n\n    def finalize(self, status_code=None, notes=None):\n        \"\"\"Update the |Stamp| with status_code and notes about the API response.\n\n        Parameters\n        ----------\n        status_code : |str| or |None|\n            The HTTP status code (e.g., '200') for the API response.\n\n        notes : |str| or |None|\n            Notes about the API response, such as an error message.\n\n        Returns\n        -------\n        self : |Stamp|\n\n        \"\"\"\n        self.job_end = timezone.now()\n        if status_code is not None:\n            self.status_code = status_code\n        if notes is not None:\n            self.notes = notes\n        self.save()\n        return self\n\n    def is_obsolete(self):\n        \"\"\"\n        Returns a Boolean indicating whether a more recent call has been\n        made to the same endpoint with the same credentials.\n        \"\"\"\n        last_success = Stamp.objects.filter(\n            passport=self.passport,\n            object_id=self.object_id,\n            content_type=self.content_type).first()\n        return self != last_success\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, null, null, 0, null, null, 0, null, null, null, 0, null, 0, 0, 0, null], "name": "ambassador/stamps/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nSerializers for Stamps.\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom .models import Stamp\n\n\nclass StampSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Stamps.\n    \"\"\"\n    error_msg = serializers.CharField(source='notes')\n\n    class Meta:\n        model = Stamp\n        fields = ('id', 'status_code', 'error_msg')\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, null, 1, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, 1, 1, 1, 1, null, 1, 1, null, null, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, 1, null, 0, null, 1, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, 0, 0, 0, 0, 0, null, 0, 0, null, 1, null, null, null, null, null, null, null, null, 0, null, 1, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, 1, 1, null, 0, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, 0, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, null], "name": "ambassador/transport.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a |Cargo| class and a |Transport| base class.\n\nNote\n----\nThe |Transport| class is the basis for the |Carrier| and |Faucet|\nclasses.\n\n\"\"\"\n\n# standard library\nimport logging\n\n# third party\nfrom django.utils.functional import cached_property\n\n# local\nfrom ambassador.exceptions import EmissaryDoesNotExist\nfrom ambassador.stamps.models import Stamp\nfrom cyphon.baseclass import BaseClass\nfrom cyphon.transaction import close_old_connections\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass Cargo(object):\n    \"\"\"\n    Holds the result of an API request.\n\n    Attributes\n    ----------\n    status_code : str, optional\n        The HTTP status code received in response to the API request.\n\n    data : dict, optional\n        Data of interest recieved in response to the API call.\n\n    notes : str, optional\n        Notes about the API response, such as an error message.\n\n    \"\"\"\n\n    def __init__(self, status_code=None, data=None, notes=None):\n        self.status_code = status_code\n        self.data = data or []\n        self.notes = notes\n\n\nclass Transport(BaseClass):\n    \"\"\"\n    Sends a request to an API and processes the result.\n\n    Attributes\n    ----------\n    endpoint : Endpoint\n        The |Endpoint| for the API endpoint where requests will be sent.\n\n    user : AppUser\n        The |AppUser| making the API requests to the `endpoint`.\n\n    cargo : `None` or `Cargo`\n        The results of the API call. This will be |None| when the\n        |Transport| is initialized. It will be a |Cargo| object when the\n        response from the API is received.\n\n    record : `None` or `Record`\n        A record of the API call. This will be |None| when the\n        |Transport| is initialized. It will be a |Record| when the API\n        request is made.\n\n    \"\"\"\n\n    def __init__(self, endpoint, user=None):\n        self.endpoint = endpoint\n        self.user = user\n        self.cargo = None\n        self.record = None\n\n    def _get_emissary_type(self):\n        \"\"\"\n        Returns the type of Emissary associated with teh Endpoint, such\n        as a Courier or Plumber.\n        \"\"\"\n        endpoint_model = type(self.endpoint)\n        emissary_field = endpoint_model._meta.get_field('emissary')\n        return emissary_field.related_model\n\n    @cached_property\n    def emissary(self):\n        \"\"\"\n        |Emissary|: The |Emissary| that will be used to access the API endpoint.\n        \"\"\"\n        emissary_model = self._get_emissary_type()\n        emissaries = emissary_model.objects.find_any(self.endpoint, self.user)\n        if emissaries:\n            return emissaries.order_by('pk').first()\n        else:\n            user_str = self.user or 'an anonymous user'\n            raise EmissaryDoesNotExist('No %s exists to handle the request to '\n                                       '%s by %s' % (emissary_model.__name__,\n                                                     self.endpoint, user_str))\n\n    @cached_property\n    def passport(self):\n        \"\"\"\n        The |Passport| that will be used to access the API endpoint.\n        \"\"\"\n        return self.emissary.passport\n\n    def _emissary_enabled(self):\n        \"\"\"\n        Returns a Boolean indicating whether the Emissary can be used\n        for an API request to the Transport's Endpoint.\n        \"\"\"\n        if self.emissary:\n            return self.emissary.enabled(endpoint=self.endpoint)\n        else:\n            return False\n\n    def _stamp_passport(self):\n        \"\"\"\n        Creates a Stamp associated with the Transport's Endpoint,\n        Passport, and AppUser. Saves it to the database and returns the\n        saved object.\n        \"\"\"\n        return Stamp.objects.create(\n            endpoint=self.endpoint,\n            passport=self.passport,\n            user=self.user\n        )\n\n    def get_key(self):\n        \"\"\"Get the consumer/client/developer key used to authenticate requests.\n\n        Returns\n        -------\n        |str|\n            The consumer/client/developer key used to authenticate requests.\n\n        \"\"\"\n        return self.passport.key\n\n    def get_key_cert(self):\n        \"\"\"Get the certificate for authenticating requests.\n\n        Returns\n        -------\n        |str|\n            The certificate used to authenticate requests.\n\n        \"\"\"\n        key_cert = self.passport.file\n        key_cert_data = None\n        try:\n            key_cert.open()\n            key_cert_data = key_cert.read()\n        finally:\n            key_cert.close()\n        return key_cert_data\n\n    def get_secret(self):\n        \"\"\"Get the client/consumer secret used to authenticate requests.\n\n        Returns\n        -------\n        |str|\n            The client/consumer secret used to authenticate requests.\n\n        \"\"\"\n        return self.passport.secret\n\n    def get_access_token(self):\n        \"\"\"Get the access token used for OAuth authentication.\n\n        Returns\n        -------\n        |str|\n            The access token used for OAuth authentication.\n\n        \"\"\"\n        return self.passport.access_token\n\n    def get_access_token_secret(self):\n        \"\"\"Get the access token secret used for OAuth authentication.\n\n        Returns\n        -------\n        |str|\n            The access token secret used for OAuth authentication.\n\n        \"\"\"\n        return self.passport.access_token_secret\n\n    def create_record(self, stamp, obj):\n        \"\"\"Create a |Record| of the API call.\n\n        Parameters\n        ----------\n        stamp : |Stamp|\n            A |Stamp| containing details of the API request.\n\n        obj : |object|\n            An object related to the API request, such as an |Alert| or\n            |dict| of query parameters. The type of object is determined\n            in derived classes.\n\n        Note\n        ----\n        This method needs to be implemented in derived classes.\n\n        \"\"\"\n        raise self.raise_method_not_implemented()\n\n    def process_request(self, obj):\n        \"\"\"Submit a request to the API and return the results.\n\n        Parameters\n        ----------\n        obj : |object|\n            The object used to create the API request, such as an\n            |Alert| or |ReservoirQuery|. The type of object is\n            determined in derived classes.\n\n        Returns\n        -------\n        |Cargo|\n            The results of the API call packaged as a |Cargo| object.\n\n        Note\n        ----\n        This method needs to be implemented in derived classes so it can\n        be customized for specific APIs.\n\n        \"\"\"\n        raise self.raise_method_not_implemented()\n\n    def prepare(self, obj):\n        \"\"\"Create a |Record| for an the API call prior to issuing the call.\n\n        If the value of the |Transport|'s :attr:`~Transport.record` is\n        |None|, creates a |Record| of the API call and updates the\n        |Transport|'s :attr:`~Transport.record` with it.\n\n        Parameters\n        ----------\n        obj : |object|\n            The object used to create the API request, such as an\n            |Alert| or |ReservoirQuery|. The type of object is\n            determined in derived classes.\n\n        Returns\n        -------\n        |Transport|\n            self\n\n        Note\n        ----\n        This method separates the creation of a |Record| from the\n        :meth:`~Transport.start` method which actually calls the API.\n        In cases where we wish to call the API within a daemon thread,\n        this makes it possible to get a preliminary |Record| of the\n        request prior to issuing the API call through a background\n        process.\n\n        However, this means care should be taken to always call\n        :meth:`~Transport.prepare` just prior to calling\n        :meth:`~Transport.start`, to ensure a |Record| of the API\n        request is created.\n\n        \"\"\"\n        if self._emissary_enabled():\n\n            # create a Record if one does not already exist\n            if self.record is None:\n                stamp = self._stamp_passport()\n                self.record = self.create_record(stamp=stamp, obj=obj)\n        else:\n            LOGGER.error('Emissary is not enabled')\n\n        return self\n\n    @close_old_connections\n    def start(self, obj):\n        \"\"\"Issue the API call and update the |Transport|'s\n        :attr:`~Transport.cargo` with the result.\n\n        Parameters\n        ----------\n        obj : |object|\n            The object used to create the API request, such as an\n            |Alert| or |ReservoirQuery|. The type of object is\n            determined in derived classes.\n\n        Returns\n        -------\n        |Transport|\n            self\n\n        Warning\n        -------\n        The :meth:`~Transport.prepare` method should always be called\n        prior to calling :meth:`~Transport.start`.\n\n        \"\"\"\n        self.cargo = self.process_request(obj)\n        return self\n\n    @close_old_connections\n    def stop(self):\n        \"\"\"Update the |Transport|'s :attr:`~Transport.record` with\n        information about the API response.\n\n        Returns\n        -------\n        |Transport|\n            self\n\n        Raises\n        ------\n        :obj:`~AssertionError`\n            If either the |Transport|'s :attr:`~Transport.record`\n            or :attr:`~Transport.cargo` is |None|.\n\n        Warning\n        -------\n        The :meth:`~Transport.prepare` and :meth:`~Transport.start`\n        methods must be called prior to calling :meth:`~Transport.stop`.\n\n        \"\"\"\n        msg = ('The prepare() and start() methods must be called first')\n        assert self.record is not None, msg\n        assert self.cargo is not None, msg\n        self.record.finalize(self.cargo)\n        return self\n\n    def run(self, obj):\n        \"\"\"Issue an API call and update the |Transport|'s\n        :attr:`~Transport.record` and :attr:`~Transport.cargo`\n        with the result.\n\n        Parameters\n        ----------\n        obj : |object|\n            The object used to create the API request, such as an\n            |Alert| or |ReservoirQuery|. The type of object is\n            determined in derived classes.\n\n        Returns\n        -------\n        |Transport|\n            self\n\n        Note\n        ----\n        The :meth:`~Transport.run` method bundles together the\n        :meth:`~Transport.prepare`, :meth:`~Transport.start`, and\n        :meth:`~Transport.stop` methods. It can be used for convienence\n        in cases where there is no need to access the |Transport|'s\n        :attr:`~Transport.record` prior to the API call's return.\n\n        \"\"\"\n        self.prepare(obj)\n        self.start(obj)\n        self.stop()\n        return self\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "ambassador/visas/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null], "name": "ambassador/visas/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclass for Visas and registers them with\nDjango Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom .models import Visa\n\n\nclass VisaAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Visas.\n    \"\"\"\n    exclude = []\n\n\nadmin.site.register(Visa, VisaAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, 1, null, null], "name": "ambassador/visas/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a |Visa| class for storing an API rate limit.\n\"\"\"\n\n# third party\nfrom django.db import models\n\n# local\nfrom cyphon.choices import TIME_UNIT_CHOICES\nfrom cyphon.models import GetByNameManager\nfrom utils.dateutils import dateutils as dt\n\n\nclass Visa(models.Model):\n    \"\"\"\n    Defines an API rate limit. Specifies the number of requests (calls)\n    that can be made in a given time interval.\n\n    Attributes\n    ----------\n    name : str\n        The identifier for the |Visa|.\n\n    calls : int\n        The number of requests allowed in the rate limit interval.\n\n    time_interval : int\n        The number of units in the rate limit interval. The type of\n        unit is specified by the :attr:`~Visa.time_unit` attribute.\n\n    time_unit : str\n        Defines the units of measure for the :attr:`~Visa.time_interval`.\n        Choices are limited to |TIME_UNIT_CHOICES|.\n\n    \"\"\"\n    name = models.CharField(max_length=40, unique=True)\n    calls = models.IntegerField()\n    time_interval = models.IntegerField()\n    time_unit = models.CharField(max_length=3, choices=TIME_UNIT_CHOICES)\n\n    objects = GetByNameManager()\n\n    def __str__(self):\n        return self.name\n\n    def get_request_interval_in_minutes(self):\n        \"\"\"Get the number of minutes in the rate limit interval.\n\n        Returns\n        -------\n        int\n            The number of minutes in the rate limit interval.\n\n        \"\"\"\n        return dt.convert_time_to_whole_minutes(self.time_interval,\n                                                self.time_unit)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1], "name": "appusers/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\ndefault_app_config = 'appusers.apps.AppUserConfig'\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, 1, null, null, null, null, null, 1, 1, null, 1], "name": "appusers/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\nfrom django.contrib.auth.admin import UserAdmin\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom appusers.models import AppUser\nfrom appusers.forms import CustomUserChangeForm, CustomUserCreationForm\n\n\nclass AppUserAdmin(UserAdmin):\n    \"\"\"\n    The forms to add and change user instances.\n\n    The fields to be used in displaying the User model. These override\n    the definitions on the base UserAdmin that reference the removed\n    'username' field.\n    \"\"\"\n    fieldsets = (\n        (None, {\n            'fields': (\n                'email',\n                'password',\n            )\n        }),\n        (_('Personal info'), {\n            'fields': (\n                'first_name',\n                'last_name',\n            )\n        }),\n        (_('Permissions'), {\n            'fields': (\n                'is_active',\n                'is_staff',\n                'is_superuser',\n                'groups',\n                'user_permissions',\n            )\n        }),\n        (_('Important dates'), {\n            'fields': (\n                'last_login',\n                'date_joined',\n            )\n        }),\n    )\n    add_fieldsets = (\n        (None, {\n            'classes': ('wide',),\n            'fields': ('email',)\n        }),\n    )\n    form = CustomUserChangeForm\n    add_form = CustomUserCreationForm\n    list_display = (\n        'email',\n        'first_name',\n        'last_name',\n        'is_staff',\n    )\n    search_fields = ('email', 'first_name', 'last_name')\n    ordering = ('email',)\n\nadmin.site.register(AppUser, AppUserAdmin)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, 1, null, 1, null, null, null, 1, null], "name": "appusers/apps.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.apps import AppConfig\n\n\nclass AppUserConfig(AppConfig):\n    \"\"\"\n    Application configuration for AppUser.\n    \"\"\"\n    name = 'appusers'\n    verbose_name = 'App User'\n\n    def ready(self):\n        \"\"\"\n        Registers the signals submodule once app is loaded.\n        \"\"\"\n        import appusers.signals\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, null, null, 1, null, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, null, null, null, 1, 0, null, 1, 1, 1, null, null, 1, null, null, null, 1, null, 1, null, null, 1, null, null, null, 1, null, null, null, 0, 0, 0, 0, 0, 0, 0, null, null, 1, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, 0, 0, 0, null, null, null, 0, null, null, 1, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, 0, 0, 0, null, null, null, 0, null], "name": "appusers/forms.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDjango forms for AppUser app.\n\"\"\"\n\n# third party\nfrom django import forms\nfrom django.contrib.auth import forms as auth_forms\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom appusers.models import AppUser\n\n\nclass CustomUserCreationForm(forms.ModelForm):\n    \"\"\"\n    A form that creates a user, with no privileges, from the given username.\n    Password is automatically set as unusable until the user responds\n    to a confirmation email.\n    \"\"\"\n    class Meta:\n        model = AppUser\n        fields = ('email', )\n\n\nclass CustomUserChangeForm(auth_forms.UserChangeForm):\n    \"\"\"\n    A form for updating users. Includes all the fields on\n    the user, but replaces the password field with admin's\n    password hash display field.\n    \"\"\"\n\n    def __init__(self, *args, **kargs):\n        super(CustomUserChangeForm, self).__init__(*args, **kargs)\n\n    class Meta:\n        model = AppUser\n        fields = '__all__'\n\n\nclass UserRegistrationForm(auth_forms.SetPasswordForm):\n    \"\"\"\n    The form used for the initial registration of a user.\n    \"\"\"\n    new_password2 = forms.CharField(widget=forms.PasswordInput(),\n                                    label=_(\"Password Confirmation\"))\n    first_name = forms.CharField(label=_(\"First Name\"),\n                                 required=True, widget=forms.TextInput,\n                                 max_length=30)\n    last_name = forms.CharField(label=_(\"Last Name\"),\n                                required=True, widget=forms.TextInput,\n                                max_length=30)\n\n    def save(self, commit=True):\n        \"\"\"\n        Saves the user to the database.\n        \"\"\"\n        self.user.set_password(self.cleaned_data['new_password1'])\n        self.user.first_name = self.cleaned_data['first_name']\n        self.user.last_name = self.cleaned_data['last_name']\n        self.user.is_active = True\n        if commit:\n            self.user.save()\n        return self.user\n\n\nclass CustomSetPasswordForm(auth_forms.SetPasswordForm):\n    \"\"\"\n    Custom form for setting passwords.\n    \"\"\"\n    error_messages = dict(auth_forms.SetPasswordForm.error_messages, **{\n        'same_password_as_old': _(\"You entered the same password as your \"\n                                  \"current password. Please enter a new \"\n                                  \"password.\"),\n    })\n    new_password1 = forms.CharField(widget=forms.PasswordInput(),\n                                    label=_(\"New Password\"))\n\n    def clean_new_password1(self):\n        \"\"\"\n        Checks to make sure that the new password isn't the same as\n        the old one.\n        \"\"\"\n        password1 = self.cleaned_data.get('new_password1')\n        if self.user.check_password(password1):\n            raise forms.ValidationError(\n                self.error_messages['same_password_as_old'],\n                code='same_password_as_old',\n            )\n        return password1\n\n\nclass CustomPasswordChangeForm(auth_forms.PasswordChangeForm):\n    \"\"\"\n    Custom form for changing passwords by an admin panel.\n    \"\"\"\n    error_messages = dict(auth_forms.PasswordChangeForm.error_messages, **{\n        'same_password_as_old': _(\"You entered the same password as your \"\n                                  \"current password. Please enter a new \"\n                                  \"password.\"),\n    })\n    new_password1 = forms.CharField(widget=forms.PasswordInput(),\n                                    label=_(\"New Password\"))\n\n    def clean_new_password1(self):\n        \"\"\"\n        Checks to make sure that the new password isn't the same as\n        the old one.\n        \"\"\"\n        password1 = self.cleaned_data.get('new_password1')\n        if self.user.check_password(password1):\n            raise forms.ValidationError(\n                self.error_messages['same_password_as_old'],\n                code='same_password_as_old',\n            )\n        return password1\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, 1, 1, 1, 1, 1, 1, null, null, 1, null, 1, null, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, null, 1, 1, 1, 0, 1, 1, null, null, 1, 1, 1, 0, 0, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 0, null, null, null, 1, null, null, null, null, null, null, 1, 1, 1, 1, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, null, null, 1, null, 1, 1, null, 1, 1, 1, 1, null, 1, null, null, null, null, 0, 0, 0, null, 1, null, null, null, 1, null, 1, null, null, null, 1, 1, null, 1, null, null, null, 1, null, 1, null, null, null, 0], "name": "appusers/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nModels for appuser application\n\"\"\"\n\n# standard library\nimport logging\n\n# third party\nfrom django.core.mail import send_mail\nfrom django.contrib.auth.models import AbstractBaseUser, PermissionsMixin\nfrom django.contrib.auth.models import BaseUserManager\nfrom django.db import models\nfrom django.db.utils import IntegrityError\nfrom django.utils import timezone\nfrom django.utils.http import urlquote\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom companies.models import Company\n\n_LOGGER = logging.getLogger(__name__)\n\n\nclass AppUserManager(BaseUserManager):\n    \"\"\"\n    Custom user manager for application. Upon creation, the password\n    is not given unless it's a superuser. This allows admins to create\n    users easily without having direct access to their account.\n    \"\"\"\n    use_in_migrations = True\n\n    def _create_user(self, email, password, is_staff,\n                     is_superuser, is_active, **extra_fields):\n        \"\"\"\n        Creates and saves a User with the given email and password.\n        \"\"\"\n        try:\n            now = timezone.now()\n            if not email:\n                raise ValueError('The given email must be set')\n            email = self.normalize_email(email)\n            user = self.model(email=email, is_staff=is_staff,\n                              is_active=is_active, is_superuser=is_superuser,\n                              date_joined=now, **extra_fields)\n            user.set_password(password)\n            user.save(using=self._db)\n            return user\n        except IntegrityError:\n            _LOGGER.error('Cannot create new user with email %s. '\n                         'A user with that email already exists.', email)\n\n    def create_user(self, email, password=None, **extra_fields):\n        \"\"\"\n        Public method for creating a user.\n        \"\"\"\n        return self._create_user(email, password, False, False, False,\n                                 **extra_fields)\n\n    def create_superuser(self, email, password, **extra_fields):\n        \"\"\"\n        Public method for creating a superuser.\n        \"\"\"\n        return self._create_user(email, password, True, True, True,\n                                 **extra_fields)\n\n\nclass AppUser(AbstractBaseUser, PermissionsMixin):\n    \"\"\"\n    Custom user model that uses email for authentication rather than\n    a username. Email and password are required upon initialization.\n    Other fields are optional in this model, but first and last name\n    are required for certain application operations.\n    \"\"\"\n    email = models.EmailField(_('email address'), max_length=254, unique=True)\n    first_name = models.CharField(_('first name'), max_length=30, blank=True)\n    last_name = models.CharField(_('last name'), max_length=30, blank=True)\n    is_staff = models.BooleanField(\n        _('staff status'),\n        default=False,\n        help_text=_('Designates whether the user can log into this '\n                    'admin site.'))\n    is_active = models.BooleanField(\n        _('active'),\n        default=False,\n        help_text=_('Designates whether this user should be treated as '\n                    'active. Unselect this instead of deleting accounts.'))\n    date_joined = models.DateTimeField(_('date joined'), default=timezone.now)\n    company = models.ForeignKey(Company, blank=True, null=True)\n    use_redaction = models.BooleanField(default=True)\n    push_notification_id = models.CharField(max_length=254, blank=True,\n                                            null=True, unique=True)\n\n    objects = AppUserManager()\n\n    USERNAME_FIELD = 'email'\n    REQUIRED_FIELDS = []\n\n    class Meta:\n        verbose_name = _('user')\n        verbose_name_plural = _('users')\n        ordering = ['last_name', 'first_name']\n\n    def clean(self):\n        \"\"\"\n        Overrides the default clean() method. Stores a null value for\n        push_notification_id if an empty string is submitted.\n        \"\"\"\n        if self.push_notification_id == '':\n            self.push_notification_id = None\n        super(AppUser, self).clean()\n\n    def get_absolute_url(self):\n        \"\"\"\n        Returns the url where the users info resides.\n        \"\"\"\n        return \"/users/%s/\" % urlquote(self.email)\n\n    def get_full_name(self):\n        \"\"\"\n        Returns the first_name plus the last_name, with a space in between.\n        \"\"\"\n        full_name = '%s %s' % (self.first_name, self.last_name)\n        return full_name.strip()\n\n    def get_short_name(self):\n        \"\"\"\n        Returns the short name for the user.\n        \"\"\"\n        return self.first_name\n\n    def email_user(self, subject, message, from_email=None):\n        \"\"\"\n        Sends an email to this User.\n        \"\"\"\n        send_mail(subject, message, from_email, [self.email])\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, null, 0, null, 0, null, null, null, null, null, null, null, null, null, null, 0, null, 0, 0, null, 0, null, 0, 0, 0, null, 0], "name": "appusers/registration.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nA collection of classes and functions that help register a user.\n\"\"\"\n\n# third party\nfrom django.conf import settings\nfrom django.contrib.auth.tokens import default_token_generator\nfrom django.utils.http import urlsafe_base64_encode\nfrom django.utils.encoding import force_bytes\nfrom django.template import loader\nfrom django.core.mail import EmailMultiAlternatives\n\n\ndef send_registration_email(\n        user, domain_override=None, use_https=False, from_email=None,\n        subject_template_name='appuser/user_registration_subject.txt',\n        email_template_name='appuser/user_registration_email.html',\n        token_generator=default_token_generator,\n        html_email_template_name=None):\n    \"\"\"\n    Generates a one-use only link for a user to register their profile.\n\n    Args:\n        domain_override (str, optional):\n            **Default**: None\n\n            The domain url. If given, this will override the default domain \n            url thatwill be placed in the registration link given to the user.\n\n        use_https (bool, optional):\n            **Default**: False\n\n            Use https in registration link.\n            If true, will place https:// at the beginning of the \n            registration url.\n\n        from_email (str, optional):\n            **Default**: None\n\n            The return email address. \n\n        subject_template_name (str, optional): \n            **Default**: 'appuser/user_registration_subject.txt'\n\n            The template that will be used to create the subject line.\n\n        email_template_name (str, optional): \n            **Default**: 'appuser/user_registration_email.html'\n\n            The template that will be used to create the email content.\n\n        token_generator (module, optional): \n            **Default**: django.contrib.auth.tokens.default_token_generator\n\n            Generator used to create custom tokens for the registration\n            email.\n\n        html_email_template_name (str, optional):\n            **Default**: None\n\n            The template to use to display the information in an html email.\n    \"\"\"\n    if not domain_override:\n        site_name = domain = settings.HOSTNAME\n    else:\n        site_name = domain = domain_override\n\n    context = {\n        'email': user.email,\n        'domain': domain,\n        'site_name': site_name,\n        'uid': urlsafe_base64_encode(force_bytes(user.pk)),\n        'user': user,\n        'registration_path': settings.REGISTRATION_PATH,\n        'token': token_generator.make_token(user),\n        'protocol': 'https' if use_https else 'http',\n    }\n\n    subject = loader.render_to_string(subject_template_name, context)\n    # Email subject *must not* contain newlines\n    subject = ''.join(subject.splitlines())\n    body = loader.render_to_string(email_template_name, context)\n\n    email_message = EmailMultiAlternatives(subject, body,\n                                           from_email, [user.email])\n    if html_email_template_name is not None:\n        html_email = loader.render_to_string(html_email_template_name, context)\n        email_message.attach_alternative(html_email, 'text/html')\n\n    email_message.send()\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, 1, 1, 1, null, null, 1, null, null, 1, null, null, null, null, 1, 1, 1, null, null, null, null, null, null, null, 1, 1, null, null, null, null, null, null, null, 1, null, null, null, 1, null, null, null, null, 1, null, null, null, 0, 0, 0, 0, 0, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, null, null, 1, null, null, null, 0, null, 0, 0, 0, 0, 0, null, 0, null, 1, null, null, null, 0, null, 0, null, 0, 0, 0, 0, null, null, 0, 0, 0, null, 0, 0, null, null, 0, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, 1, 1, null, 1, null, null, null, 0, null, null, null, null, null, 0, 0, null, 0, 0, null, null, 0, null], "name": "appusers/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nSerializers related to the custom user object\n\"\"\"\n\n# third party\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.auth.tokens import default_token_generator\nfrom django.core.exceptions import ObjectDoesNotExist\nfrom django.utils.encoding import force_text, DjangoUnicodeDecodeError\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.translation import ugettext as _\nfrom rest_framework import serializers\n\n# local\nfrom . import models\n\n\nclass AppUserSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for the AppUser object\n    \"\"\"\n\n    class Meta:\n        model = models.AppUser\n        fields = (\n            'id',\n            'email',\n            'first_name',\n            'last_name',\n            'is_staff',\n            'company'\n        )\n        write_only_fields = ('password',)\n        read_only_fields = (\n            'is_staff',\n            'is_superuser',\n            'is_active',\n            'date_joined',\n        )\n\n\nclass UserEmailSerializer(serializers.Serializer):\n    \"\"\"\n    Serializes an email associated with a User account\n    \"\"\"\n    email = serializers.EmailField(\n        label=_('User Email'),\n        help_text=_('Enter the email associated with your account'))\n\n\ndef valid_uidb64(value):\n    \"\"\"\n    Determines if a uidb64 value is valid.\n    \"\"\"\n    try:\n        force_text(urlsafe_base64_decode(value))\n    except (DjangoUnicodeDecodeError, ValueError) as error:\n        raise serializers.ValidationError(str(error))\n    return value\n\n\nclass UserTokenAuthentication(serializers.Serializer):\n    \"\"\"\n    Serializes a token and uidb64 associated with a user and validates if an\n    intended action is possible base on their current user status.\n    \"\"\"\n    token = serializers.CharField(\n        label=_('Token'),\n        help_text=_('Temporary token associated with a user account.'))\n    uidb64 = serializers.CharField(\n        label=_('uidb64'),\n        help_text=_('Encoded user id associated with a user account.'),\n        validators=[valid_uidb64])\n    action = serializers.ChoiceField(\n        choices=[_(\"password-reset\"), _(\"register\")],\n        label=_(\"User Action\"),\n        help_text=_(\"The action the user wishes to perform on their account.\"))\n\n    def action_authorized(self, action, user):\n        \"\"\"\n        Determines if an action is authorized for a certain user\n        \"\"\"\n        authorized = False\n\n        if not user.has_usable_password():\n            if action is 'password-reset':\n                authorized = user.is_active\n            if action is 'register':\n                authorized = not user.is_active\n\n        return authorized\n\n    def validate(self, data):\n        \"\"\"\n        Check that the user token matches the decoded user id\n        \"\"\"\n        user_model = get_user_model()\n\n        uid = force_text(urlsafe_base64_decode(data['uidb64']))\n\n        try:\n            user = user_model.objects.get(pk=uid)\n        except ObjectDoesNotExist:\n            raise serializers.ValidationError(\n                \"Not a valid token and uidb64 combination\")\n\n        if user is not None:\n            if not default_token_generator.check_token(user, data['token']):\n                raise serializers.ValidationError(\n                    \"Not a valid token and uidb64 combination\")\n            if not self.action_authorized(data['action'], user):\n                raise serializers.ValidationError(\n                    \"User not authorized for {0}\".format(data['action']))\n\n        return data\n\n\nclass UserRegistrationSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for user registration.\n    \"\"\"\n    token = serializers.CharField(\n        label=_('Token'),\n        help_text=_('Temporary token associated with a user account.'))\n    uidb64 = serializers.CharField(\n        label=_('uidb64'),\n        help_text=_('Encoded user id associated with a user account.'),\n        validators=[valid_uidb64])\n    password1 = serializers.CharField(\n        min_length=8, max_length=20, label=_(\"Password\"),\n        style={'input_type': 'password'})\n    password2 = serializers.CharField(\n        min_length=8, max_length=20, label=_(\"Repeat Password\"),\n        style={'input_type': 'password'})\n    first_name = serializers.CharField(label=_(\"First Name\"), max_length=30)\n    last_name = serializers.CharField(label=_(\"Last Name\"), max_length=30)\n\n    def validate(self, data):\n        \"\"\"\n        Validates multiple field errors\n        \"\"\"\n        tokenData = {\n            'token': data['token'],\n            'uidb64': data['uidb64'],\n            'action': 'register'\n        }\n\n        if data['password1'] != data['password2']:\n            raise serializers.ValidationError(\n                \"The passwords you entered did not match.\")\n        if not UserTokenAuthentication(data=tokenData).is_valid():\n            raise serializers.ValidationError(\n                \"User token not valid.\")\n\n        return data\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null], "name": "appusers/signals.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.db.models.signals import post_save\nfrom django.dispatch import receiver\nfrom django.conf import settings\n\n# local\nfrom appusers import registration\nfrom appusers.models import AppUser\n\n\n@receiver(post_save, sender=AppUser)\ndef email_user_confirmation(sender, **kwargs):\n    \"\"\" \n    Email a user when they're created the first time so they can\n    set up their password and change their first/last name if\n    they need to.\n    \"\"\"\n    pass\n    # if kwargs['created'] and kwargs['instance'].last_login is None:\n    #     registration.send_registration_email(\n    #         kwargs['instance'],\n    #         html_email_template_name='appuser/user_registration_html_email.html')\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, 1, null, null, 1, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "appusers/urls.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.conf.urls import url\nfrom django.contrib.auth import views as auth_views\nfrom django.core.urlresolvers import reverse_lazy\nfrom django.views.generic import TemplateView\nfrom django.contrib.auth.decorators import login_required, user_passes_test\n\n# local\nfrom appusers import forms\nfrom . import views\n\n\n# Helper function that brings up a 404 page if a user attempts to access it\n# when logged in.\nlogin_forbidden = user_passes_test(lambda u: u.is_anonymous(), '/')\n\n\nurlpatterns = [\n    # url(r'^login/$',\n    #     'appusers.views.custom_login',\n    #     {\n    #         'template_name': 'appuser/login.html'\n    #     },\n    #     name='login'),\n    # url(r'^logout/$',\n    #     'django.contrib.auth.views.logout',\n    #     {\n    #         'template_name': 'appuser/logout.html'\n    #     },\n    #     name='logout'),\n    # url(r'^logout_then_login/$',\n    #     'django.contrib.auth.views.logout_then_login',\n    #     {\n    #         'extra_context': {\n    #             'logged_out': True,\n    #         },\n    #     },\n    #     name='logout_then_login'),\n    # url(r'^password_change/$',\n    #     'django.contrib.auth.views.password_change',\n    #     {\n    #         'template_name': 'appuser/password_change.html',\n    #         'password_change_form': forms.CustomPasswordChangeForm,\n    #         'post_change_redirect': reverse_lazy(\n    #             'password_change_done'),\n    #     },\n    #     name='password_change'),\n    # url(r'^password_change_done/$',\n    #     'django.contrib.auth.views.password_change_done',\n    #     {\n    #         'template_name': 'appuser/password_change_done.html',\n    #     },\n    #     name='password_change_done'),\n    # url(r'^password_reset/$',\n    #     login_forbidden(auth_views.password_reset),\n    #     {\n    #         'template_name': 'appuser/password_reset.html',\n    #         'email_template_name': 'appuser/password_reset_email.html',\n    #         'subject_template_name': 'appuser/password_reset_subject.txt',\n    #         'current_app': 'appusers',\n    #         'post_reset_redirect': reverse_lazy('password_reset_done'),\n    #     },\n    #     name='password_reset'),\n    # url(r'^password_reset_done/$',\n    #     'django.contrib.auth.views.password_reset_done',\n    #     {\n    #         'template_name': 'appuser/password_reset_done.html',\n    #     },\n    #     name='password_reset_done'),\n    # url(r'^password_reset_confirm/(?P<uidb64>[0-9A-Za-z_\\-]+)/'\n    #     '(?P<token>[0-9A-Za-z]{1,13}-[0-9A-Za-z]{1,20})/$',\n    #     'appusers.views.password_reset_confirm',\n    #     {\n    #         'template_name': 'appuser/password_reset_confirm.html',\n    #         'set_password_form': forms.CustomSetPasswordForm,\n    #         'post_reset_redirect': reverse_lazy(\n    #             'password_reset_complete'),\n    #         'current_app': 'appusers',\n    #     },\n    #     name='password_reset_confirm'),\n    # url(r'^password_reset_complete/$',\n    #     login_forbidden(auth_views.password_reset_complete),\n    #     {\n    #         'template_name': 'appuser/password_reset_complete.html',\n    #     },\n    #     name='password_reset_complete'),\n    # url(r'^user_registration/(?P<uidb64>[0-9A-Za-z_\\-]+)/'\n    #     '(?P<token>[0-9A-Za-z]{1,13}-[0-9A-Za-z]{1,20})/$',\n    #     'appusers.views.user_registration',\n    #     {\n    #         'template_name': 'appuser/user_registration.html',\n    #         'user_registration_form': forms.UserRegistrationForm,\n    #         'post_reset_redirect': reverse_lazy(\n    #             'user_registration_complete'),\n    #         'current_app': 'appusers',\n    #     },\n    #     name='user_registration'),\n    # url(r'^user_registration_complete/$',\n    #     TemplateView.as_view(\n    #         template_name='appuser/user_registration_complete.html'),\n    #     name='user_registration_complete'),\n    # url(r'^profile/$',\n    #     login_required(TemplateView.as_view(\n    #         template_name='appuser/profile.html')),\n    #     name='profile'),\n    url(r'^token-authenticated/$', views.UserTokenAuthenticatedFor.as_view(),\n        name='user_token_authentication'),\n    url(r'^registration/$', views.UserRegistration.as_view(),\n        name='user_registration'),\n]\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, null, null, 1, 1, 1, null, 1, null, null, 1, 0, 0, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, null, 0, 0, null, 0, 0, 0, 0, null, 0, 0, 0, null, 0, 0, 0, 0, 0, 0, 0, null, 0, null, 0, null, 0, null, null, null, null, null, 0, 0, null, 0, 0, null, 0, null, null, 1, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, 0, null, 0, 0, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, 1, null, null, null, 0, null, null, 0, 0, null, 0, 0, 0, 0, 0, 0, 0, null, 0, null, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, null, 1, null, null, 1, 1, null, null, 1, 0, null, null, null], "name": "appusers/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nViews for the appuser package\n\"\"\"\n\n# third party\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.auth.tokens import default_token_generator\nfrom django.contrib.auth.views import login\nfrom django.core.urlresolvers import reverse\nfrom django.http import HttpResponseRedirect, Http404\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.translation import ugettext_lazy as _\nfrom django.utils.encoding import force_text\nfrom django.shortcuts import resolve_url\nfrom django.template.response import TemplateResponse\nfrom django.views.decorators.cache import never_cache\nfrom django.views.decorators.debug import sensitive_post_parameters\nfrom rest_framework.response import Response\nfrom rest_framework.pagination import PageNumberPagination\nfrom rest_framework.views import APIView\nfrom rest_framework import status\nfrom rest_framework import viewsets\n\n# local\nfrom cyphon.views import CustomModelViewSet\nfrom . import forms\nfrom . import serializers\n\n_USER_SETTINGS = settings.APPUSERS\n\n\ndef custom_login(request, **kwargs):\n    if request.user.is_authenticated:\n        return HttpResponseRedirect(settings.LOGIN_REDIRECT_URL)\n    else:\n        return login(request, **kwargs)\n\n\n# @sensitive_post_parameters()\n# @never_cache\n# def user_registration(request, uidb64=None, token=None,\n#                       template_name='appuser/user_registration.html',\n#                       token_generator=default_token_generator,\n#                       user_registration_form=forms.UserRegistrationForm,\n#                       post_reset_redirect=None,\n#                       current_app=None, extra_context=None):\n#     \"\"\"\n#     Presents the user with a form to register if the given token and\n#     uid are correct. If not, it returns a 404.\n\n#     This view is copied from django.contrib.auth.views.password_reset_confirm.\n#     There are some slight variable changes, and most of them can\n#     be passed in as optional parameters to the original view.\n#     I have the actual URL pointing to the the original view, but I have\n#     this here in case there is an update to django breaks the original\n#     view.\n#     \"\"\"\n#     user_model = get_user_model()\n#     assert uidb64 is not None and token is not None  # checked by URLconf\n#     if post_reset_redirect is None:\n#         post_reset_redirect = reverse('user_registration_complete')\n#     else:\n#         post_reset_redirect = resolve_url(post_reset_redirect)\n#     try:\n#         # urlsafe_base64_decode() decodes to bytestring on Python 3\n#         uid = force_text(urlsafe_base64_decode(uidb64))\n#         user = user_model._default_manager.get(pk=uid)\n#     except (TypeError, ValueError, OverflowError, user_model.DoesNotExist):\n#         user = None\n\n#     if user is not None and token_generator.check_token(user, token):\n#         if user.is_active:\n#             raise Http404\n\n#         validlink = True\n#         title = _('Enter new password')\n#         if request.method == 'POST':\n#             form = user_registration_form(user, request.POST)\n#             if form.is_valid():\n#                 form.save()\n#                 return HttpResponseRedirect(post_reset_redirect)\n#         else:\n#             form = user_registration_form(user)\n#     else:\n#         raise Http404\n        \n#     context = {\n#         'form': form,\n#         'title': title,\n#         'validlink': validlink,\n#         'user': user,\n#     }\n\n#     if extra_context is not None:\n#         context.update(extra_context)\n\n#     if current_app is not None:\n#         request.current_app = current_app\n\n#     return TemplateResponse(request, template_name, context)\n\n\n@sensitive_post_parameters()\n@never_cache\ndef password_reset_confirm(request, uidb64=None, token=None,\n                           template_name='registration/password_reset_confirm.html',\n                           token_generator=default_token_generator,\n                           set_password_form=forms.CustomSetPasswordForm,\n                           post_reset_redirect=None,\n                           current_app=None, extra_context=None):\n    \"\"\"\n    This view is copied from django.contrib.auth.views.password_reset_confirm.\n    I wasn't too fond of how it showed a page without the form if\n    the person guessed the token and the uid. I changed it so that\n    it raises an 404 error instead.\n    \"\"\"\n    UserModel = get_user_model()\n    assert uidb64 is not None and token is not None  # checked by URLconf\n    if post_reset_redirect is None:\n        post_reset_redirect = reverse('password_reset_complete')\n    else:\n        post_reset_redirect = resolve_url(post_reset_redirect)\n    try:\n        # urlsafe_base64_decode() decodes to bytestring on Python 3\n        uid = force_text(urlsafe_base64_decode(uidb64))\n        user = UserModel._default_manager.get(pk=uid)\n    except (TypeError, ValueError, OverflowError, UserModel.DoesNotExist):\n        user = None\n\n    if user is not None and token_generator.check_token(user, token):\n        if not user.is_active:\n            raise Http404\n\n        validlink = True\n        title = _('Enter new password')\n        if request.method == 'POST':\n            form = set_password_form(user, request.POST)\n            if form.is_valid():\n                form.save()\n                return HttpResponseRedirect(post_reset_redirect)\n        else:\n            form = set_password_form(user)\n    else:\n        raise Http404\n\n    context = {\n        'form': form,\n        'title': title,\n        'validlink': validlink,\n    }\n\n    if extra_context is not None:\n        context.update(extra_context)\n\n    if current_app is not None:\n        request.current_app = current_app\n\n    return TemplateResponse(request, template_name, context)\n\n\nclass UserTokenAuthenticatedFor(APIView):\n    \"\"\"\n    View that determines if a user is able to perform a one time link action,\n    such as registering for the first time, or resetting their password.\n    \"\"\"\n    serializer_class = serializers.UserTokenAuthentication\n    permission_classes = []\n    authentication_classes = []\n\n    def post(self, request):\n        \"\"\"\n        Determines if a user token is associated with a the given user id\n        that has been encoded in base 64.\n        \"\"\"\n        token_auth = serializers.UserTokenAuthentication(data=request.data)\n\n        if token_auth.is_valid():\n            return Response(True)\n        else:\n            return Response(token_auth.errors,\n                            status=status.HTTP_400_BAD_REQUEST)\n\n\n# class SendPasswordResetEmail(APIView):\n#     \"\"\"\n#     Sends the user a password reset email\n#     \"\"\"\n\n#     def post(self, request):\n#         user_email = serializers.UserEmailSerializer(data=request.data)\n#         if user_email.is_valid():\n#             user_model = get_user_model()\n#             user = user_model.objects.get(email=user_email)\n\n#             if user:\n\n\nclass UserRegistration(APIView):\n    \"\"\"\n    View that registers a user that has been added into the system by a\n    cyphon admin.\n    \"\"\"\n    serializer_class = serializers.UserRegistrationSerializer\n    permission_classes = []\n    authentication_classes = []\n\n    def post(self, request):\n        \"\"\"\n        Update a user.\n        \"\"\"\n        user_registration = serializers.UserRegistrationSerializer(\n            data=request.data)\n\n        if user_registration.is_valid():\n            uid = force_text(urlsafe_base64_decode(\n                user_registration.validated_data['uidb64']))\n            user = get_user_model().objects.get(pk=uid)\n            user.first_name = user_registration.validated_data['first_name']\n            user.last_name = user_registration.validated_data['last_name']\n            user.set_password(user_registration.validated_data['password2'])\n            user.is_active = True\n            user.save()\n            return Response(serializers.AppUserSerializer(user).data)\n        else:\n            return Response(user_registration.errors,\n                            status=status.HTTP_400_BAD_REQUEST)\n\n\nclass AppUserPagination(PageNumberPagination):\n    \"\"\"\n    Pagination class for appusers\n    \"\"\"\n    page_size = 50\n\n\nclass AppUserViewSet(CustomModelViewSet):\n    \"\"\"\n    A simple ViewSet for viewing and editing alerts.\n    \"\"\"\n    queryset = get_user_model().objects.all()\n    serializer_class = serializers.AppUserSerializer\n    pagination_class = AppUserPagination\n\n    def __init__(self, *args, **kwargs):\n\n        # configure filter backends here so we can mock APPUSERS in tests\n        self.custom_filter_backends = _USER_SETTINGS['CUSTOM_FILTER_BACKENDS']\n        super(AppUserViewSet, self).__init__(*args, **kwargs)\n\n\ndef jwt_response_payload_handler(token, user=None, request=None):\n    return {\n        'token': token,\n        'user': serializers.AppUserSerializer(user).data\n    }\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "bottler/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, null, null, 1, 1, null, null, null, null, 1, null, null, null, 1, 1, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "bottler/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines ModelAdmin base classes for Bottles, Labels, and their fields.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\nfrom django.utils.translation import ugettext_lazy as _\n\n\nclass ContainerFieldBaseAdmin(admin.ModelAdmin):\n    \"\"\"\n    Base class for customizing admin pages for BottleFields and LabelFields.\n    \"\"\"\n    list_display = [\n        'field_name',\n        'field_type',\n        'target_type',\n    ]\n    list_display_links = ['field_name', ]\n    related_lookup_fields = {\n        'generic': [['content_type', 'object_id']],\n    }\n\n\nclass ContainerBaseAdmin(admin.ModelAdmin):\n    \"\"\"\n    Base class for customizing admin pages for Bottles and Labels.\n    \"\"\"\n    filter_horizontal = ['fields']\n    readonly_fields = ['preview']\n    save_as = True\n    fieldsets = (\n        (None, {\n            'fields': ['name', 'fields', ]\n        }),\n        ('Preview', {\n            'description': _('A preview of your data model with field names '\n                             'mapped to field types. <br>'\n                             'If the target type of a field is defined, it is '\n                             'shown in parentheses after the field type. <br>'\n                             'After making changes, save the model '\n                             'to update the preview.'),\n            'classes': ('collapse', 'pre'),\n            'fields': ('preview', ),\n        }),\n    )\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "bottler/bottles/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, 1, null], "name": "bottler/bottles/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines ModelAdmin subclasses for Bottles and BottleFields, and registers them\nwith Django Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom bottler.admin import ContainerBaseAdmin, ContainerFieldBaseAdmin\nfrom .models import BottleField, Bottle\n\n\nclass BottleFieldAdmin(ContainerFieldBaseAdmin):\n    \"\"\"\n    Customizes admin pages for BottleFields.\n    \"\"\"\n    list_display = ContainerFieldBaseAdmin.list_display + ['embedded_doc']\n\n\nclass BottleAdmin(ContainerBaseAdmin):\n    \"\"\"\n    Customizes admin pages for Bottles.\n    \"\"\"\n    list_display = ['name']\n\n\nclass BottleFieldInLineAdmin(admin.TabularInline):\n    \"\"\"\n    Customizes admin inline tables for BottleFields.\n    \"\"\"\n    model = BottleField\n\n\nadmin.site.register(BottleField, BottleFieldAdmin)\nadmin.site.register(Bottle, BottleAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, 1, 1, null, null, 1, 1, 1, null, null, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, null, null, null, 1, null, null, null, 1, null, 1, null, 1, 1, null, 1, 1, null, null, 1, 1, null, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, null, 1, 1, null, 1, 1, null, 1, null, null, null, null, 1, 1, null, 1, 1, null, 1, 1, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, 1, null, 1, null, null, 1, 1, 1, null, null, null, 1, null, 1, null, null, null, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, 1, null, null, 1, 1, 1, null, null, null, 1, null, null, null, 1, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, 1, 1, 1, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, null], "name": "bottler/bottles/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nProvides DataField and Bottle classes for defining a standard data\nmodel. These are used for displaying data in a standard format across data\nsources.\n\"\"\"\n\n# standard library\nfrom collections import OrderedDict\nimport json\nimport logging\n\n# third party\nfrom django.db import models\nfrom django.core.exceptions import ValidationError\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.models import SelectRelatedManager, GetByNameMixin\nfrom bottler.datafields.models import DataField\nfrom utils.validators.validators import field_name_validator\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass BottleFieldManager(models.Manager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def get_by_natural_key(self, field_name):\n        \"\"\"\n        Allow retrieval of a BottleField by its natural key instead of its\n        primary key.\n        \"\"\"\n        try:\n            return self.get(field_name=field_name)\n        except BottleField.DoesNotExist:\n            LOGGER.error('%s \"%s\" does not exist',\n                         self.model.__name__, field_name)\n\n\nclass BottleField(DataField):\n    \"\"\"\n    Defines a field in a custom data model (Bottle).\n    \"\"\"\n    embedded_doc = models.ForeignKey('Bottle', blank=True, null=True)\n\n    objects = BottleFieldManager()\n\n    def clean(self):\n        super(BottleField, self).clean()\n\n        if self.field_type == 'EmbeddedDocument' and self.embedded_doc is None:\n            raise ValidationError(_('An embedded doc must be defined for an ' \\\n                                  + 'EmbeddedDocument field.'))\n\n        if self.field_type != 'EmbeddedDocument' and self.embedded_doc:\n            raise ValidationError(_('If an embedded doc is defined, ' \\\n                                  + 'the field type must be EmbeddedDocument.'))\n\n\nclass BottleManager(SelectRelatedManager, GetByNameMixin):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n    pass\n\n\nclass Bottle(models.Model):\n    \"\"\"\n    Defines a data model for displaying data in a standard format across\n    different social media platforms. Consists of a set of DataFields,\n    which define the field names and types in the data model.\n\n    The Bottle's name may be used as a field name for an embedded MongoDB\n    document, so it should conform to MongoDB naming conventions for fields.\n    \"\"\"\n    name = models.CharField(max_length=40, unique=True,\n                            validators=[field_name_validator])\n    fields = models.ManyToManyField(\n        BottleField,\n        related_name='bottles',\n        related_query_name='bottle'\n    )\n\n    objects = BottleManager()\n\n    class Meta:\n        ordering = ['name']\n\n    def __str__(self):\n        return self.name\n\n    def _get_bottlefields(self, bottle_name):\n        \"\"\"\n        Takes the primary key of a Bottle and eturns a QuerySet of its\n        BottleFields.\n        \"\"\"\n        if bottle_name is None:\n            return self.fields.all()\n        else:\n            bottle = Bottle.objects.get_by_natural_key(bottle_name)\n            return bottle.fields.all()\n\n    @staticmethod\n    def _create_key(field_name, parent_name=None):\n        \"\"\"\n        Takes the name of a document field and, optionally, the name of a\n        parent field. Returns a key to the field using dot notation.\n        \"\"\"\n        if parent_name:\n            return '%s.%s' % (parent_name, field_name)\n        else:\n            return field_name\n\n    def field_exists(self, bottlefield):\n        \"\"\"\n        Takes a BottleField and returns a Boolean indicating whether the\n        field is present in the Bottle.\n        \"\"\"\n        return self.fields.filter(pk=bottlefield.pk).exists()\n\n    def get_fields(self, bottle_name=None, parent_name=None):\n        \"\"\"\n        Takes the primary key of a Bottle and, optionally, a string\n        representing the name of a parent Bottle. Returns a list of data\n        dictionaries describing the field_name, field_type, and target_type of\n        each BottleField in the Bottle. This includes any nested BottleFields\n        associated with embedded Bottles (i.e., BottleFields that are\n        ForeignKeys to other Bottles).\n        \"\"\"\n        fields = []\n\n        for bottlefield in self._get_bottlefields(bottle_name):\n\n            # base case: not a ForeignKey\n            if bottlefield.field_type != 'EmbeddedDocument':\n                datafield = bottlefield.to_nested_datafield(parent_name)\n                fields.append(datafield)\n\n            # recursive case: DataField refers to a Bottle\n            else:\n                field_label = self._create_key(bottlefield.field_name,\n                                               parent_name)\n                nested_fields = self.get_fields(\n                    bottle_name=bottlefield.field_name,\n                    parent_name=field_label,\n                )\n                fields.extend(nested_fields)\n\n        return fields\n\n    def get_field_choices(self, bottle_name=None, parent_name=None):\n        \"\"\"\n        Takes the primary key of a Bottle and, optionally, a string\n        representing the name of a parent Bottle. Returns a list of 2-tuples\n        representing (value, label) pairs for DataFields associated with\n        the Bottle. This includes any nested DataFields associated with\n        embedded Bottles (i.e., DataFields that are ForeignKeys to other\n        Bottles).\n\n        Returns choices in a format suitable for use in a limit_choices_to\n        argument for a ForeignKey Field in a Django Model, e.g.:\n\n        >>> bottle.get_bottlefield_choices()\n        >>> [('created_date:DateTimeField', 'created_date'),\n            ('text:textCharField', 'text'),\n            ('user.screen_name:CharField', 'user.screen_name'),\n            ('user.profile_pic:CharField', 'user.profile_pic')]\n\n        \"\"\"\n        fields = []\n\n        for bottlefield in self._get_bottlefields(bottle_name):\n\n            field_label = self._create_key(bottlefield.field_name, parent_name)\n\n            # base case: not a ForeignKey or other excluded field type\n            if bottlefield.field_type != 'EmbeddedDocument':\n                value = '%s:%s' % (field_label, bottlefield.field_type)\n                fields.append((value, field_label))\n\n            # recursive case: DataField refers to a Bottle\n            else:\n                nested_fields = self.get_field_choices(\n                    bottle_name=bottlefield.field_name,\n                    parent_name=field_label,\n                )\n                fields.extend(nested_fields)\n\n        return fields\n\n    def get_structure(self, bottle_name=None):\n        \"\"\"\n        Takes a Bottle primary key and returns an OrderedDict representing\n        the data model defined by the Bottle.\n        \"\"\"\n        fields = {}\n\n        for bottlefield in self._get_bottlefields(bottle_name):\n\n            # base case: not a ForeignKey\n            if bottlefield.field_type != 'EmbeddedDocument':\n                field_info = bottlefield.to_key_val()\n                fields.update(field_info)\n\n            # recursive case: DataField refers to a Bottle\n            else:\n                nested_fields = self.get_structure(bottlefield.field_name)\n                fields[bottlefield.field_name] = nested_fields\n\n        return OrderedDict(sorted(fields.items()))\n\n    def preview(self):\n        \"\"\"\n        Returns a JSON string representing the data model defined by\n        the Bottle.\n        \"\"\"\n        structure = self.get_structure()\n        return json.dumps(structure, indent=4)\n\n    preview.short_description = _('Bottle preview')\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, 1, 1, 1, null, null, 1, null, null, null, 1, 1, 1, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, 1, null], "name": "bottler/bottles/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom bottler.bottles.models import Bottle, BottleField\nfrom distilleries.models import Distillery\n\n\nclass DistilleryDetailSerializer(serializers.ModelSerializer):\n    \"\"\"\n\n    \"\"\"\n    name = serializers.CharField(source='__str__')\n\n    class Meta:\n        model = Distillery\n        fields = ('pk', 'name')\n\n\nclass BottleFieldSerializer(serializers.HyperlinkedModelSerializer):\n    \"\"\"\n\n    \"\"\"\n    class Meta:\n        model = BottleField\n        fields = (\n            'id',\n            'field_name',\n            'field_type',\n            'target_type',\n            'embedded_doc',\n            'url',\n            'bottles'\n        )\n\n\nclass BottleSerializer(serializers.HyperlinkedModelSerializer):\n    \"\"\"\n\n    \"\"\"\n    # get the collection's pk (distillery.pk = distillery.collection.pk)\n    collections = DistilleryDetailSerializer(source='container__distilleries',\n                                       many=True, read_only=True)\n\n    class Meta:\n        model = Bottle\n        fields = ('id', 'name', 'fields', 'collections', 'url')\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, 1, null], "name": "bottler/bottles/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom rest_framework import viewsets\n\n# local\nfrom bottler.bottles.models import Bottle, BottleField\nfrom bottler.bottles.serializers import BottleSerializer, BottleFieldSerializer\n\n\nclass BottleViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"\n    Read only viewset for Bottles.\n    \"\"\"\n    queryset = Bottle.objects.all()\n    serializer_class = BottleSerializer\n\n\nclass BottleFieldViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"\n    Read only viewset for BottleFields.\n    \"\"\"\n    queryset = BottleField.objects.all()\n    serializer_class = BottleFieldSerializer\n    filter_fields = ['bottle']\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "bottler/containers/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null], "name": "bottler/containers/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclass for Containers and registers them with\nDjango Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom bottler.containers.models import Container\nfrom bottler.tastes.admin import TasteInLineAdmin\n\n\nclass ContainerAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Containers.\n    \"\"\"\n    list_display = ['name', 'bottle', 'label']\n    readonly_fields = ['preview']\n    inlines = [TasteInLineAdmin, ]\n    fieldsets = (\n        (None, {\n            'fields': ['name', 'bottle', 'label']\n        }),\n        ('Preview', {\n            'description': _('Below is a preview of your model, '\n                             'with field names mapped to field types. <br>'\n                             'If the target type of a field is defined, it is '\n                             'shown in parentheses after the field type. <br>'\n                             'After making changes, save the model '\n                             'to update the preview.'),\n            'classes': ('collapse', 'pre'),\n            'fields': ('preview', ),\n        }),\n    )\n    save_as = True\n\n\nadmin.site.register(Container, ContainerAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, 1, 1, null, null, 1, 1, 1, 1, null, 1, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, 1, 1, 1, null, null, null, null, null, null, 1, null, 1, 1, 1, null, 1, 1, null, null, null, 1, null, null, null, null, null, null, null, 1, null, 1, 1, 1, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, 1, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, 1, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, null, 1, null, null, null, null, 1, null, 1, 1, 1, 1, null, 1, 1, 1, null, 1, null, 1, null, null, null, 1, 1, null, 1], "name": "bottler/containers/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# standard library\nfrom collections import OrderedDict\nimport json\nimport logging\n\n# third party\nfrom django.conf import settings\nfrom django.db import models\nfrom django.utils.functional import cached_property\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.models import GetByNameManager\nfrom cyphon.choices import TEXT_FIELDS\nfrom bottler.bottles.models import Bottle\nfrom bottler.labels.models import Label\n\n_DISTILLERY_SETTINGS = settings.DISTILLERIES\n\n_LOGGER = logging.getLogger(__name__)\n\n\nclass ContainerManager(GetByNameManager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def get_queryset(self):\n        \"\"\"\n        Overrides the default get_queryset method to select the related\n        Bottle and Label.\n        \"\"\"\n        default_queryset = super(ContainerManager, self).get_queryset()\n        return default_queryset.select_related()\n\n\nclass Container(models.Model):\n    \"\"\"\n    Attributes:\n        name: a string representing the name of the Container\n        bottle: a Bottle in which to store data\n        label: a Label containing metadata about the contents of a Bottle\n    \"\"\"\n    name = models.CharField(max_length=40, unique=True)\n    bottle = models.ForeignKey(Bottle, on_delete=models.PROTECT)\n    label = models.ForeignKey(\n        Label,\n        blank=True,\n        null=True,\n        on_delete=models.SET_NULL\n    )\n\n    objects = ContainerManager()\n\n    class Meta:\n        ordering = ['name']\n        unique_together = ('bottle', 'label')\n\n    def __str__(self):\n        return self.name\n\n    # TODO(LH): need vaildation between label and bottle\n\n    @cached_property\n    def fields(self):\n        \"\"\"\n        Returns\n        -------\n        list of DataFields\n\n        \"\"\"\n        fields = []\n\n        if self.label:\n            label_fields = self.label.get_fields()\n            fields.extend(label_fields)\n\n        bottle_fields = self.bottle.get_fields()\n        fields.extend(bottle_fields)\n\n        return fields\n\n    @property\n    def field_dicts(self):\n        \"\"\"\n        Returns a list of data dictionaries describing the field_name,\n        field_type, and target_type of each BottleField and LabelField\n        associated with the Container.\n        \"\"\"\n        return [field.to_dict() for field in self.fields]\n\n    def get_bottle_structure(self):\n        \"\"\"\n        Returns a dictionary representing the data model defined by the\n        Container's Bottle.\n        \"\"\"\n        return self.bottle.get_structure()\n\n    def get_label_structure(self):\n        \"\"\"\n        Returns a dictionary representing the Container's Label.\n        \"\"\"\n        assert self.label, 'Container \"%s\" has no Label' % self.name\n        return self.label.get_structure()\n\n    def add_label(self, data):\n        \"\"\"\n        Takes a dictionary of data, adds a '_metadata' field containing a\n        dictionary of metadata, and returns the 'labeled' data.\n        \"\"\"\n        if self.label:\n            return self.label.add(data)\n        else:\n            return data\n\n    def get_sample(self, data):\n        \"\"\"\n        Takes a dictionary of bottled data and returns a dictionary of 'teaser'\n        data.\n        \"\"\"\n        if hasattr(self, 'taste'):\n            return self.taste.get_sample(data)\n        else:\n            _LOGGER.warning('Container \"%s\" has no Taste to sample data',\n                            str(self))\n            return {}\n\n    def get_blind_sample(self, data, codebook):\n        \"\"\"\n        Takes a dictionary of bottled data and returns a dictionary of redacted\n        'teaser' data, using the Distillery's CodeBook.\n        \"\"\"\n        if hasattr(self, 'taste'):\n            return self.taste.get_blind_sample(data, codebook)\n        else:\n            _LOGGER.warning('Container \"%s\" has no Taste to sample data',\n                            str(self))\n            return {}\n\n    def get_taste_text_fields(self):\n        \"\"\"\n        Returns a list of DataFields for searchable text fields\n        associated with the Taste.\n        \"\"\"\n        field_names = self.taste.get_text_fields()\n        return [field for field in self.fields \\\n                if field.field_name in field_names]\n\n    def get_text_fields(self):\n        \"\"\"\n        Returns a list of DataFields for searchable text fields\n        associated with the Container.\n        \"\"\"\n        return [field for field in self.fields \\\n                if field.field_type in TEXT_FIELDS]\n\n    def get_field_list(self):\n        \"\"\"\n\n        \"\"\"\n        return [field.field_name for field in self.fields]\n\n    def get_structure(self):\n        \"\"\"\n        Returns an OrderedDict representing the data model defined by the\n        Container.\n        \"\"\"\n        structure = OrderedDict()\n\n        if self.label:\n            label_structure = self.get_label_structure()\n            label_fields = OrderedDict(sorted(label_structure.items()))\n            structure.update({_DISTILLERY_SETTINGS['LABEL_KEY']: label_fields})\n\n        bottle_structure = self.get_bottle_structure()\n        bottle_fields = OrderedDict(sorted(bottle_structure.items()))\n        structure.update(bottle_fields)\n\n        return structure\n\n    def preview(self):\n        \"\"\"\n        Returns a JSON string representing the Container.\n        \"\"\"\n        structure = self.get_structure()\n        return json.dumps(structure, indent=4)\n\n    preview.short_description = _('container peview')\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, 1, 1, null, 1, 1, 1, null, null, null, null, null, null, null, null, null], "name": "bottler/containers/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom bottler.containers.models import Container\nfrom bottler.tastes.serializers import TasteSerializer\n\n\nclass ContainerSerializer(serializers.ModelSerializer):\n\n    fields = serializers.ReadOnlyField(source='field_dicts')\n    taste = TasteSerializer()\n\n    class Meta:\n        model = Container\n        fields = (\n            'bottle',\n            'id',\n            'fields',\n            'label',\n            'name',\n            'url',\n            'taste'\n        )\n        # depth = 2 # show datafield objects, not just datafield foreign keys\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, null, null, 1, 1, 1, null, null, 1, null, null, null, 1, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, 1, 1, 1, null, 1, null, null, null, null, null, 1, null, null, 1, 1, 1, null, 1, null, 1, null, 1, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, null, 1, null, 1, null, 1, null, 1, null, null, null, null, null, null, null, 1, null, 1, null, 1, 1, 1, 1, 1, 1, null, 1, 1], "name": "bottler/containers/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nimport django_filters\nfrom rest_framework import viewsets\nfrom rest_framework.decorators import list_route\nfrom rest_framework.response import Response\n\n# local\nfrom bottler.containers.models import Container\nfrom bottler.containers.serializers import ContainerSerializer\nfrom warehouses.models import Warehouse\n\n\nclass ContainerFilter(django_filters.FilterSet):\n    \"\"\"\n    Filters Container by Warehouse.\n    \"\"\"\n    name = django_filters.AllValuesFilter(name='name')\n\n    warehouse = django_filters.ModelChoiceFilter(\n        name='distillery__collection__warehouse',\n        queryset=Warehouse.objects.all()\n    )\n\n    class Meta:\n        model = Container\n        fields = ['name', 'warehouse']\n\n\nclass ContainerViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    REST API for Containers.\n    \"\"\"\n    queryset = Container.objects.all().order_by('name')\n    serializer_class = ContainerSerializer\n    filter_class = ContainerFilter\n\n    @staticmethod\n    def _filter_by_names(queryset, names):\n        \"\"\"\n        Takes a Queryset of Containers and a comma-separated list of Container\n        names. Returns a filtered Queryset containing only the Containers listed.\n        \"\"\"\n        if names is not None:\n\n            # convert string to list and clean up any whitespaces\n            names = names.split(',')\n            for index, name in enumerate(names):\n                names[index] = name.strip()\n\n            queryset = queryset.filter(name__in=names)\n\n        return queryset\n\n    def _get_data_by_name(self, request):\n        \"\"\"\n        Takes a REST API request with an optional names argument consisting of\n        a comma-separated list of Container names. Returns the serialized data\n        for the specified Containers or the data for all Containers if no names\n        were given.\n        \"\"\"\n        queryset = Container.objects.all().order_by('name')\n        names = self.request.query_params.get('names', None)\n        filtered_queryset = self._filter_by_names(queryset, names)\n        serializer = ContainerSerializer(filtered_queryset, many=True,\n                                         context={'request': request})\n        return serializer.data\n\n    @list_route(methods=['get'], url_path='in-use')\n    def containers_in_use(self, request, *args, **kwargs):\n        \"\"\"\n        Returns a list of Containers that are associated with Distilleries.\n        This filters out any Containers that are unused.\n        \"\"\"\n        filtered_queryset = Container.objects.filter(\n            distillery__isnull=False)\n        parents = filtered_queryset.distinct()\n\n        serializer = ContainerSerializer(parents, many=True,\n                                         context={'request': request})\n        return Response(serializer.data)\n\n    @list_route(methods=['get'], url_path='targets')\n    def targets(self, request, *args, **kwargs):\n        \"\"\"\n        Returns a list of target types (categories) of BottleFields and\n        LabelFields present in a queryset of Containers. The results can\n        be restricted to a subset of Containers by provided the 'names'\n        argument with a comma-separated list of Container names.\n        \"\"\"\n        data = self._get_data_by_name(request)\n\n        targets = []\n\n        for doc in data:\n            container = Container.objects.get(name=doc['name'])\n            for field in container.fields:\n                target = field.target_type\n                if target and target not in targets:\n                    targets.append(target)\n\n        targets.sort()\n        return Response(targets)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "bottler/datafields/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, 1, null, null, null, 1, null, null, null, 1, 1, null, 1, 0, null, 1, 1, 1, 1, null, 1, null, null, null, 1, 1, null, 0, null, 1, null, null, null, 1, 1, null, 0, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, 1, null], "name": "bottler/datafields/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.choices import FIELD_TYPE_CHOICES, TARGET_TYPE_CHOICES\nfrom utils.validators.validators import field_name_validator\n\n\nclass DataField(models.Model):\n    \"\"\"\n    Defines a field in a custom data model (Container).\n\n    Attributes\n    ----------\n    field_name : str\n        The name of the field in which the data will be stored.\n        If the `field_type` is \"ForeignKey,\" then the `field_name`\n        also represents the primary key of an embedded |Bottle|.\n\n    field_type : str\n        The name of a Django :class:`~django.db.models.Field` subclass.\n\n    target_type : str\n        The type of target the |DataField| represents. Corresponds to a\n        value in |TARGET_TYPE_CHOICES|.\n\n    \"\"\" \n    field_name = models.CharField(\n        max_length=40,\n        unique=True,\n        validators=[field_name_validator]\n    )\n    field_type = models.CharField(max_length=40,\n                                  choices=FIELD_TYPE_CHOICES)\n    target_type = models.CharField(max_length=40,\n                                   choices=TARGET_TYPE_CHOICES,\n                                   blank=True, null=True)\n\n    class Meta:\n        \"\"\"\n        Metadata options.\n        \"\"\"\n        abstract = True\n        ordering = ['field_name']\n\n    def __str__(self):\n        return \"%s (%s)\" % (self.field_name, self.field_type)\n\n    def clean(self):\n        super(DataField, self).clean()\n        self._validate_field_type()\n        self._validate_target_type()\n\n    def _validate_field_type(self):\n        \"\"\"\n        Returns a Boolean indicating whether the field_type is valid.\n        \"\"\"\n        valid_field_types = [field[0] for field in FIELD_TYPE_CHOICES]\n        if self.field_type is not None \\\n                and self.field_type not in valid_field_types:\n            raise ValidationError(_('Please provide a valid field_type.'))\n\n    def _validate_target_type(self):\n        \"\"\"\n        Returns a Boolean indiacting whether the target_type is valid.\n        \"\"\"\n        valid_target_types = [target[0] for target in TARGET_TYPE_CHOICES]\n        if self.target_type is not None \\\n                and self.target_type not in valid_target_types:\n            raise ValidationError(_('Please provide a valid target_type.'))\n\n    def to_nested_datafield(self, parent_name=None):\n        \"\"\"Return a new |DataField| representing the current object.\n\n        Parameters\n        ----------\n        parent_name : |str| or |None|\n            The name of a field containing an embedded document that\n            includes the field represented by current object.\n\n        Returns\n        -------\n        |DataField|\n            A new |DataField| instance based on the current object's\n            `field_name`, `field_type` and `target_type`. If a\n            `parent_name` is provided, the |DataField|'s `field_name` is\n            the `parent_name` prepended to the object's `field_name`\n            using dot notation.\n\n        \"\"\"\n        if parent_name is not None:\n            field_name = '%s.%s' % (parent_name, self.field_name)\n        else:\n            field_name = self.field_name\n\n        return DataField(\n            field_name=field_name,\n            field_type=self.field_type,\n            target_type=self.target_type,\n        )\n\n    def to_dict(self, parent_name=None):\n        \"\"\"Return a dict representing the object.\n\n        Parameters\n        ----------\n        parent_name : |str| or |None|\n            The name of a field containing an embedded document that\n            includes the field represented by current object.\n\n        Returns\n        -------\n        |dict|\n            A |dict| containing the object's `field_name`, `field_type`,\n            and `target_type`. If a `parent_name` is provided, the\n            `parent_name` prepended to the object's `field_name`\n            using dot notation.\n\n        \"\"\"\n        if parent_name is not None:\n            field_name = '%s.%s' % (parent_name, self.field_name)\n        else:\n            field_name = self.field_name\n\n        field = {\n            'field_name': field_name,\n            'field_type': self.field_type,\n            'target_type': self.target_type,\n        }\n\n        return field\n\n    def to_key_val(self):\n        \"\"\"Return a key, value pair for the name and type of field.\n\n        Returns\n        -------\n        |dict|\n            A |dict| item mapping the object's `field_name` to its\n            `field_type` and `target_type` (if any). For example,\n            `{'name': 'CharField (Keyword)'`.\n\n        \"\"\"\n        if self.target_type:\n            target = ' (%s)' % self.target_type\n        else:\n            target = ''\n        return {self.field_name: self.field_type + target}\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "bottler/labels/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, null, 1, null, null, null, 1, null, null, 1, 1, null], "name": "bottler/labels/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines ModelAdmin subclasses for Labels and LabelFields, and registers them\nwith Django Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom bottler.admin import ContainerBaseAdmin, ContainerFieldBaseAdmin\nfrom . import models\n\n\nclass LabelFieldAdmin(ContainerFieldBaseAdmin):\n    \"\"\"\n    Customizes admin pages for LabelFields.\n    \"\"\"\n    list_display = ContainerFieldBaseAdmin.list_display + \\\n                   ['analyzer', 'analyzer_type']\n\n\nclass LabelAdmin(ContainerBaseAdmin):\n    \"\"\"\n    Customizes admin pages for Labels.\n    \"\"\"\n    pass\n\n\nadmin.site.register(models.LabelField, LabelFieldAdmin)\nadmin.site.register(models.Label, LabelAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, 1, 1, 1, null, null, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, 1, null, null, null, 1, null, 1, 1, null, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, 1, 1, null, 1, null, 1, 1, null, 1, null, null, null, null, 1, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, 1, null, 1, 1, 1, 1, null, 1, null, 1, null, null, null, 1, null, 1, 1, 1, null, 1, null, 1, null, null, null, 1, 1, null, 1], "name": "bottler/labels/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# standard library\nfrom collections import OrderedDict\nimport copy\nimport json\n\n# third party\nfrom django.conf import settings\nfrom django.db import models\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.contrib.contenttypes.fields import GenericForeignKey\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.models import GetByNameManager\nfrom bottler.datafields.models import DataField\n\n_DISTILLERY_SETTINGS = settings.DISTILLERIES\n\n\nclass LabelField(DataField):\n    \"\"\"\n    Defines a field in a Label.\n\n    Assigns a Procedure or Inspection to a Bottle to allow data enhancements\n    for bottled data.\n\n    \"\"\"\n    PROCEDURE = models.Q(app_label='procedures', model='procedure')\n    INSPECTION = models.Q(app_label='inspections', model='inspection')\n    CONTENT_TYPES = PROCEDURE | INSPECTION\n\n    content_type = models.ForeignKey(\n        ContentType,\n        limit_choices_to=CONTENT_TYPES,\n        verbose_name=_('analyzer type'),\n        help_text=_('Inspections determine whether data match a set of rules, '\n                    'defined by regular expressions. <br>Procedures perform more '\n                    'complex analyses, such as sentiment analysis or '\n                    'geolocation.')\n    )\n    object_id = models.PositiveIntegerField(\n        verbose_name=_('analyzer id'),\n        help_text=_('The id of the inspection or procedure that will '\n                    'analyze the data.')\n    )\n    analyzer = GenericForeignKey()\n\n    class Meta:\n        \"\"\"\n        Metadata options.\n        \"\"\"\n        unique_together = ('field_name', 'content_type', 'object_id')\n\n    def __str__(self):\n        return \"%s:%s <- %s (%s)\" % (self.field_name, self.field_type,\n                                     self.analyzer, self.analyzer_type)\n\n    @property\n    def analyzer_type(self):\n        \"\"\"\n        Returns the name of the class for the type of analyzer, which can be\n        either an Inspection or a Procedure.\n        \"\"\"\n        return self.content_type.model\n\n    def _get_result(self, data):\n        \"\"\"\n        Takes a data dictionary of bottled data and returns the result of the\n        the analysis performed by the Analyzer's Procedure or Inspection.\n\n        This method requires that both Inspections and Procedures\n        have a method with this name.\n        \"\"\"\n        return self.analyzer.get_result(data)\n\n    def create(self, data):\n        \"\"\"\n        Takes a dictionary of bottled data and returns a dictionary object\n        containing the result of the analysis.\n        \"\"\"\n        key = self.field_name\n        value = self._get_result(data)\n        return {key: value}\n\n\nclass LabelManager(GetByNameManager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def get_queryset(self):\n        \"\"\"\n        Overrides the default get_queryset method to select the related\n        BottleFields.\n        \"\"\"\n        default_queryset = super(LabelManager, self).get_queryset()\n        return default_queryset.prefetch_related('fields')\n\n\nclass Label(models.Model):\n    \"\"\"\n    A Label defines a collection of LabelFields used to analyze and add\n    metadata to a dictionary of bottled data.\n    \"\"\"\n    name = models.CharField(max_length=40, unique=True)\n    fields = models.ManyToManyField(LabelField)\n\n    objects = LabelManager()\n\n    def __str__(self):\n        return self.name\n\n    def create(self, data):\n        \"\"\"\n        Takes a dictionary of bottled data and returns a dictionary of metadata\n        containing the results of analyses for the Label's LabelFields.\n        \"\"\"\n        label = {}\n\n        for field in self.fields.all():\n            item = field.create(data)\n            label.update(item)\n\n        return {_DISTILLERY_SETTINGS['LABEL_KEY']: label}\n\n    def add(self, data):\n        \"\"\"\n        Takes a dictionary of bottled data and returns the dictionary updated\n        with metadata containing the results of analyses for the Label's\n        fields.\n        \"\"\"\n        data_copy = copy.deepcopy(data)\n        label = self.create(data_copy)\n        data_copy.update(label)\n        return data_copy\n\n    def get_fields(self):\n        \"\"\"\n        Returns a list of data dictionaries containing the field_name,\n        field_type, and target_type of each of the Label's fields.\n        \"\"\"\n        fields = []\n\n        for field in self.fields.all():\n            label_key = _DISTILLERY_SETTINGS['LABEL_KEY']\n            nested_datafield = field.to_nested_datafield(label_key)\n            fields.append(nested_datafield)\n\n        return fields\n\n    def get_structure(self):\n        \"\"\"\n        Returns an OrderedDict representing the Label.\n        \"\"\"\n        fields = {}\n\n        for labelfield in self.fields.all():\n            field_info = labelfield.to_key_val()\n            fields.update(field_info)\n\n        return OrderedDict(sorted(fields.items()))\n\n    def preview(self):\n        \"\"\"\n        Returns a JSON string representing the Label.\n        \"\"\"\n        structure = self.get_structure()\n        return json.dumps(structure, indent=4)\n\n    preview.short_description = _('label preview')\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, null, 1, 1, 1, 1, null], "name": "bottler/labels/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nSerializer for Labels\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom . import models\n\n\nclass LabelSerializer(serializers.HyperlinkedModelSerializer):\n    \"\"\"\n\n    \"\"\"\n\n    class Meta:\n        model = models.Label\n        fields = ('fields', 'id', 'name', 'url')\n\n\nclass LabelFieldSerializer(serializers.ModelSerializer):\n    \"\"\"\n\n    \"\"\"\n\n    class Meta:\n        model = models.LabelField\n        fields = '__all__'\n        depth = 1\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null], "name": "bottler/labels/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nViews for Labels and LabelFields.\n\"\"\"\n\n# third party\nfrom rest_framework import viewsets\n\n# local\nfrom .serializers import LabelSerializer, LabelFieldSerializer\nfrom .models import Label, LabelField\n\n\nclass LabelViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"\n    Read only viewset for Labels.\n    \"\"\"\n    queryset = Label.objects.all()\n    serializer_class = LabelSerializer\n\n\nclass LabelFieldViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"\n    Read only viewset for LabelFields.\n    \"\"\"\n    queryset = LabelField.objects.all()\n    serializer_class = LabelFieldSerializer\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "bottler/tastes/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, 1, 1, 1, 1, 1, 1, null, null, 1, null], "name": "bottler/tastes/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom .forms import TasteForm, TasteInlineForm\nfrom .models import Taste\n\n\nclass TasteAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes the admin page for Tastes.\n    \"\"\"\n    model = Taste\n    form = TasteForm\n\n\nclass TasteInLineAdmin(admin.StackedInline):\n    \"\"\"\n    Customizes inline admin forms for Tastes.\n    \"\"\"\n    model = Taste\n    form = TasteInlineForm\n    classes = ('grp-open', )\n    inline_classes = ('grp-open', )\n    max_num = 1\n    min_num = 1\n    verbose_name_plural = 'taste'\n    can_delete = False\n\n\nadmin.site.register(Taste, TasteAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, 1, 1, null, null, 1, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, 1, 1, null, 1, null, null, 1, null, null, null, 1, null, null, null, null, 1, null, null, null, 0, null, 0, null, null, 0, null, null, 0, null, 0, 0, 0, 0, 0, null, 0, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, null, null, null, null, 0, null, 0, null, null, 0, null, null, 0, null, null, 0, null, 0, 0, 0, 0, 0, null, 0, 0, 0, 0, 0, null, 0, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, 1, null, null, 1, 1, 1, 1, 1, 1, null], "name": "bottler/tastes/autocomplete_light_registry.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines Autocomplete models for use with admin forms for Tastes.\n\"\"\"\n\n# third party\nimport autocomplete_light.shortcuts as autocomplete_light\nfrom django.utils.encoding import force_text\n\n# local\nfrom cyphon.choices import TEXT_FIELDS, DATE_FIELDS, LOCATION_FIELDS\nfrom bottler.bottles.models import Bottle\nfrom bottler.containers.models import Container\nfrom bottler.labels.models import Label\n\n\nclass FilterFieldsAutocompleteBase(autocomplete_light.AutocompleteListBase):\n    \"\"\"\n    Defines autocomplete rules for source on the Container admin page.\n    \"\"\"\n    choices = []\n    field_types = []\n\n    @staticmethod\n    def _query_is_match(field, query):\n        \"\"\"\n        Takes a DataField and a query string. Returns a Boolean\n        indicating whether the DataField's field_name contains the query\n        string.\n        \"\"\"\n        if query and query not in force_text(field.field_name).lower():\n            return False\n        else:\n            return True\n\n    def _field_type_is_match(self, field, query):\n        \"\"\"\n        Takes a DataField and a query string. Returns a Boolean\n        indicating whether the DataField's field_type matches one of\n        the Autocomplete's field_types and the DataField's field_name\n        contains the query string.\n        \"\"\"\n        if self.field_types and field.field_type not in self.field_types:\n            return False\n        else:\n            return self._query_is_match(field, query)\n\n\nclass FilterFieldsByContainer(FilterFieldsAutocompleteBase):\n    \"\"\"\n    Defines autocomplete rules for source fields on the Taste admin page.\n    \"\"\"\n    attrs = {\n        'data-autocomplete-minimum-characters': 0,\n        'placeholder': 'select a container and click to see options...'\n    }\n\n    def choices_for_request(self):\n        \"\"\"\n        Filters field options based on a selected Container.\n        \"\"\"\n        assert self.choices is not None, 'autocomplete.choices is not set'\n\n        request_choices = []\n\n        # text typed in autocomplete input\n        query = self.request.GET.get('q', '').lower().strip()\n\n        # selected bottle on Container admin page\n        container_id = self.request.GET.get('container', None)\n\n        if container_id:\n            container = Container.objects.get(pk=container_id)\n            for field in container.fields:\n                if self._field_type_is_match(field, query):\n                    request_choices.append(field.field_name)\n\n        return self.order_choices(request_choices)[0:self.limit_choices]\n\n\nclass FilterCharFieldsByContainer(FilterFieldsByContainer):\n    \"\"\"\n    Defines autocomplete rules for CharFields/TextFields on the Container\n    admin page.\n    \"\"\"\n    field_types = TEXT_FIELDS\n\n\nclass FilterDateTimeFieldsByContainer(FilterFieldsByContainer):\n    \"\"\"\n    Defines autocomplete rules for DataTimeFields on the Container admin page.\n    \"\"\"\n    field_types = DATE_FIELDS\n\n\nclass FilterLocationFieldsByContainer(FilterFieldsByContainer):\n    \"\"\"\n    Defines autocomplete rules for LocationFields on the Container admin page.\n    \"\"\"\n    field_types = LOCATION_FIELDS\n\n\nclass FilterFieldsByBottleAndLabel(FilterFieldsAutocompleteBase):\n    \"\"\"\n    Defines autocomplete rules for source fields for an inline\n    Taste on the Container admin page.\n    \"\"\"\n    attrs = {\n        'data-autocomplete-minimum-characters': 0,\n        'placeholder': 'select a bottle/label and click to see options...'\n    }\n\n    def choices_for_request(self):\n        \"\"\"\n        Filters field options based on a selected Bottle and\n        (optionally) Label.\n        \"\"\"\n        assert self.choices is not None, 'autocomplete.choices is not set'\n\n        request_choices = []\n\n        # text typed in autocomplete input\n        query = self.request.GET.get('q', '').lower().strip()\n\n        # selected bottle on Container admin page\n        bottle_id = self.request.GET.get('bottle', None)\n\n        # selected label on Container admin page\n        label_id = self.request.GET.get('label', None)\n\n        if bottle_id:\n            bottle = Bottle.objects.get(pk=bottle_id)\n            for bottle_field in bottle.get_fields():\n                if self._field_type_is_match(bottle_field, query):\n                    request_choices.append(bottle_field.field_name)\n\n        if label_id:\n            label = Label.objects.get(pk=label_id)\n            for label_field in label.get_fields():\n                if self._field_type_is_match(label_field, query):\n                    request_choices.append(label_field.field_name)\n\n        return self.order_choices(request_choices)[0:self.limit_choices]\n\n\nclass FilterCharFieldsByBottleAndLabel(FilterFieldsByBottleAndLabel):\n    \"\"\"\n    Defines autocomplete rules for CharFields/TextFields for an inline\n    Taste on the Container admin page.\n    \"\"\"\n    field_types = TEXT_FIELDS\n\n\nclass FilterDateTimeFieldsByBottleAndLabel(FilterFieldsByBottleAndLabel):\n    \"\"\"\n    Defines autocomplete rules for DataTimeFields for an inline\n    Taste on the Container admin page.\n    \"\"\"\n    field_types = DATE_FIELDS\n\n\nclass FilterLocationFieldsByBottleAndLabel(FilterFieldsByBottleAndLabel):\n    \"\"\"\n    Defines autocomplete rules for LocationFields for an inline\n    Taste on the Container admin page.\n    \"\"\"\n    field_types = LOCATION_FIELDS\n\n\nautocomplete_light.register(FilterCharFieldsByContainer)\nautocomplete_light.register(FilterDateTimeFieldsByContainer)\nautocomplete_light.register(FilterLocationFieldsByContainer)\nautocomplete_light.register(FilterCharFieldsByBottleAndLabel)\nautocomplete_light.register(FilterDateTimeFieldsByBottleAndLabel)\nautocomplete_light.register(FilterLocationFieldsByBottleAndLabel)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, 1, null, null, null, null, 1, 1, 1, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, 0, 0, 0, 0, 0, 0, 0, null, null, 1, null, null, null, null, null, 1, 1, null, null, null, null, 1, 1, 1, 1, null, null, null, null, null, null, null, null, 1, 0, 0, 0, 0, 0, 0, 0, null], "name": "bottler/tastes/forms.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines forms for Tastes.\n\"\"\"\n\n# third party\nfrom autocomplete_light import forms as auto_forms\nfrom autocomplete_light.widgets import ChoiceWidget\n# from autocomplete_light.widgets import ChoiceWidget\n\n# local\nfrom cyphon.autocomplete import AutoCompleteModelFormMixin\nfrom .models import Taste\n\n\nclass TasteForm(auto_forms.ModelForm, AutoCompleteModelFormMixin):\n    \"\"\"\n    Defines a form for adding or updating a Taste using autocomplete\n    fields.\n    \"\"\"\n\n    class Media:\n        js = [\n            'js/dependent_autocomplete.js',\n            'js/taste_autocomplete.js',\n        ]\n\n    class Meta:\n        model = Taste\n        exclude = []\n        widgets = {\n            'author': ChoiceWidget('FilterCharFieldsByContainer'),\n            'title': ChoiceWidget('FilterCharFieldsByContainer'),\n            'content': ChoiceWidget('FilterCharFieldsByContainer'),\n            'location': ChoiceWidget('FilterLocationFieldsByContainer'),\n            'datetime': ChoiceWidget('FilterDateTimeFieldsByContainer'),\n            'date_string': ChoiceWidget('FilterCharFieldsByContainer'),\n        }\n        fields = [\n            'container',\n            'author',\n            'title',\n            'content',\n            'location',\n            'location_format',\n            'datetime',\n            'date_string',\n            'date_format',\n        ]\n\n    def __init__(self, *args, **kwargs):\n        super(TasteForm, self).__init__(*args, **kwargs)\n        self._restore_value('author', 'FilterCharFieldsByContainer')\n        self._restore_value('title', 'FilterCharFieldsByContainer')\n        self._restore_value('content', 'FilterCharFieldsByContainer')\n        self._restore_value('location', 'FilterLocationFieldsByContainer')\n        self._restore_value('datetime', 'FilterDateTimeFieldsByContainer')\n        self._restore_value('date_string', 'FilterCharFieldsByContainer')\n\n\nclass TasteInlineForm(auto_forms.ModelForm, AutoCompleteModelFormMixin):\n    \"\"\"\n    Defines an inline form for adding or updating a Taste using\n    autocomplete fields.\n    \"\"\"\n\n    class Media:\n        js = [\n            'js/dependent_autocomplete.js',\n            'js/taste_inline_autocomplete.js',\n        ]\n\n    class Meta:\n        model = Taste\n        exclude = []\n        widgets = {\n            'author': ChoiceWidget('FilterCharFieldsByBottleAndLabel'),\n            'title': ChoiceWidget('FilterCharFieldsByBottleAndLabel'),\n            'content': ChoiceWidget('FilterCharFieldsByBottleAndLabel'),\n            'location': ChoiceWidget('FilterLocationFieldsByBottleAndLabel'),\n            'datetime': ChoiceWidget('FilterDateTimeFieldsByBottleAndLabel'),\n            'date_string': ChoiceWidget('FilterCharFieldsByBottleAndLabel'),\n        }\n\n    def __init__(self, *args, **kwargs):\n        super(TasteInlineForm, self).__init__(*args, **kwargs)\n        self._restore_value('author', 'FilterCharFieldsByBottleAndLabel')\n        self._restore_value('title', 'FilterCharFieldsByBottleAndLabel')\n        self._restore_value('content', 'FilterCharFieldsByBottleAndLabel')\n        self._restore_value('location', 'FilterLocationFieldsByBottleAndLabel')\n        self._restore_value('datetime', 'FilterDateTimeFieldsByBottleAndLabel')\n        self._restore_value('date_string', 'FilterCharFieldsByBottleAndLabel')\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, 1, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, 1, 1, 1, 1, 1, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, 1, 1, null], "name": "bottler/tastes/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Taste class used to display a teaser for distilled data.\nA Taste provides basic information about the data, specifing \"Who,\"\n\"What,\" \"When,\" and \"Where.\"\n\"\"\"\n\n# standard library\nimport logging\n\n# third party\nfrom django.db import models\nfrom django.core.exceptions import ObjectDoesNotExist\n\n# local\nfrom bottler.containers.models import Container\nfrom teasers.models import Teaser\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass TasteManager(models.Manager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def get_by_natural_key(self, name):\n        \"\"\"\n        Allow retrieval of a Taste by its natural key instead of its primary key.\n        \"\"\"\n        container = Container.objects.get_by_natural_key(name)\n        try:\n            return self.get(container=container)\n        except ObjectDoesNotExist:\n            LOGGER.error('%s for Container \"%s\" does not exist',\n                         self.model.__name__, container)\n\n\nclass Taste(Teaser):\n    \"\"\"\n    The Taste class specifies which fields of distilled data should be\n    used to construct a teaser for those data. A Taste defines a\n    crosswalk between the fields of a teaser and the fields in a\n    |Container|. Nested fields (as for embedded documents) should be\n    indicated with dot notation (e.g. 'user.name').\n\n    The Taste is used to answer basic questions about a document, e.g.,\n    Who?, What?, When?, and Where?.\n\n    \"\"\"\n    container = models.OneToOneField(Container, primary_key=True)\n\n    objects = TasteManager()\n\n    def __str__(self):\n        return str(self.container)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, null, 1, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null], "name": "bottler/tastes/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nProvides a serializer for the Taste model.\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom .models import Taste\n\n\nclass TasteSerializer(serializers.ModelSerializer):\n    \"\"\"\n\n    \"\"\"\n    id = serializers.ReadOnlyField(source='pk')  # pylint: disable=C0103\n\n    class Meta:\n        model = Taste\n        fields = (\n            'id',\n            'author',\n            'title',\n            'container',\n            'content',\n            'location',\n            'location_format',\n            'datetime',\n            'date_string',\n            'date_format',\n            'url',\n        )\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, 1, null, null, 1, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, 1, 1, 1], "name": "bottler/tastes/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nProvides views for Tastes.\n\"\"\"\n\n# third party\nimport django_filters\nfrom rest_framework import viewsets\n\n# local\nfrom bottler.containers.models import Container\nfrom .models import Taste\nfrom .serializers import TasteSerializer\n\n\nclass TasteFilter(django_filters.FilterSet):\n    \"\"\"\n    Filters Tastes by Container.\n    \"\"\"\n    container = django_filters.ModelChoiceFilter(\n        name='container',\n        queryset=Container.objects.all()\n    )\n\n    class Meta:\n        model = Taste\n        fields = ['container']\n\n\nclass TasteViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    REST API for Tastes.\n    \"\"\"\n    queryset = Taste.objects.all()\n    serializer_class = TasteSerializer\n    filter_class = TasteFilter\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "categories/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1], "name": "categories/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom taxonomies.admin import TaxonomyAdmin\nfrom .models import Category\n\n\nadmin.site.register(Category, TaxonomyAdmin)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, 1, 1, 1], "name": "categories/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines Category class.\n\"\"\"\n\n# local\nfrom taxonomies.models import Taxonomy\n\n\nclass Category(Taxonomy):\n    \"\"\"\n\n    \"\"\"\n\n    class Meta(object):\n        verbose_name_plural = 'categories'\n        ordering = ['name']\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "codebooks/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, null, null, 1, 1, 1, 1, 1, null, null, 1, 1, null, 1, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, 1, 0, 0, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, 1, null, 1, null, 1, null, null, null, 1, null, 1, 1, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, 1, null, 1, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, null, 1, 1, 1, 1, 1, null, null, null, 1, null, null, null, 1, 1, null, 1, null, 1, null, null, null, 1, null, 1, 1, null, 1, null, null, null, null, null, 1, 1, 1, 1, 1, null, 1, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, null, 1, 1, 1], "name": "codebooks/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines CodeName, RealName, and CodeBook models for redacting text fields.\n\"\"\"\n\n# standard library\nfrom collections import OrderedDict\nimport json\nimport logging\nimport re\n\n# third party\nfrom django.conf import settings\nfrom django.db import models\nfrom django.core.exceptions import ObjectDoesNotExist\nfrom django.utils.functional import cached_property\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom companies.models import Company\nfrom utils.validators.validators import regex_validator\n\n_CODEBOOK_SETTINGS = settings.CODEBOOKS\n\n_LOGGER = logging.getLogger(__name__)\n\n\nclass CodeNameManager(models.Manager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def get_by_natural_key(self, code):\n        \"\"\"\n        Allow retrieval of a RealName by its natural key instead of its\n        primary key.\n        \"\"\"\n        try:\n            return self.get(code=code)\n        except ObjectDoesNotExist:\n            _LOGGER.error('%s \"%s\" does not exist', self.model.__name__, code)\n\n    def get_queryset(self):\n        \"\"\"\n        Overrides the default get_queryset method to select related\n        RealNames.\n        \"\"\"\n        default_queryset = super(CodeNameManager, self).get_queryset()\n        return default_queryset.prefetch_related('realnames')\n\n\nclass CodeName(models.Model):\n    \"\"\"\n    Defines a name and a code name that can be used in its place.\n\n    Attributes:\n        code: a string to be used in place of associated RealNames\n    \"\"\"\n    code = models.CharField(max_length=255, unique=True)\n\n    objects = CodeNameManager()\n\n    class Meta:\n        \"\"\"\n        Metadata options for a Django Model.\n        \"\"\"\n        ordering = ['code']\n\n    def __str__(self):\n        return self.code\n\n    @property\n    def formatted_codename(self):\n        \"\"\"\n        Returns a formatted version of the codename.\n        \"\"\"\n        prefix = _CODEBOOK_SETTINGS['CODENAME_PREFIX']\n        suffix = _CODEBOOK_SETTINGS['CODENAME_SUFFIX']\n        return prefix + self.code + suffix\n\n\nclass RealNameManager(models.Manager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def get_by_natural_key(self, regex):\n        \"\"\"\n        Allow retrieval of a RealName by its natural key instead of its\n        primary key.\n        \"\"\"\n        try:\n            return self.get(regex=regex)\n        except ObjectDoesNotExist:\n            _LOGGER.error('%s \"%s\" does not exist', self.model.__name__, regex)\n\n\nclass RealName(models.Model):\n    \"\"\"\n    Defines a string that should be replaced with a code name.\n\n    Attributes:\n        regex: a string representing a regular expression that should be replaced\n            with a CodeName\n        code: a ForeignKey to the CodeName which should be used in place of the\n            RealName\n        rank: an integer representing the order in which the RealName should\n            be replaced, relative to other RealNames. RealNames that are\n            substrings of other RealNames should be assigned a higher number\n            (lower rank).\n    \"\"\"\n    regex = models.CharField(\n        max_length=255,\n        unique=True,\n        verbose_name=_('regex'),\n        validators=[regex_validator],\n        help_text=_('The regular expression used to identify substrings that '\n                    'should be replaced with the code name.')\n    )\n    codename = models.ForeignKey(\n        CodeName,\n        related_name='realnames',\n        related_query_name='realname',\n        verbose_name=_('CodeName'),\n        help_text=_('The string that will replace the real name.')\n    )\n    rank = models.IntegerField(\n        default=0,\n        help_text=_('The order in which the regex should be '\n                    'searched for and replaced.'))\n\n    # NOTE: Real names that are substrings of other names should be assigned a\n    # larger number so they are searched for only after those longer names have\n    # been replaced. Conversely, longer real names should be assigned smaller\n    # numbers.\n\n    objects = RealNameManager()\n\n    class Meta:\n        \"\"\"\n        Metadata options for a Django Model.\n        \"\"\"\n        ordering = ['rank', 'regex']\n\n    def __str__(self):\n        return '%s: %s' % (self.codename, self.regex)\n\n    @property\n    def _formatted_codename(self):\n        \"\"\"\n        Returns a formatted version of the Realname's CodeName string.\n        \"\"\"\n        return self.codename.formatted_codename\n\n    def to_dict(self):\n        \"\"\"\n        Returns a dictionary in which the key is the RealName.name and the value\n        is the RealName.code.\n        \"\"\"\n        return {self.regex: str(self.codename)}\n\n    def redact(self, text):\n        \"\"\"\n        Takes a text string and returns a redacted version of the text\n        using the RealNames's formatted CodeName.\n        \"\"\"\n        pattern = re.compile(self.regex, re.IGNORECASE)\n        return pattern.sub(self._formatted_codename, text)\n\n\nclass CodeBookManager(models.Manager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def get_queryset(self):\n        \"\"\"\n        Overrides the default get_queryset method to prefetch related\n        CodeNames.\n        \"\"\"\n        default_queryset = super(CodeBookManager, self).get_queryset()\n        return default_queryset.prefetch_related('codenames__realnames')\n\n    def get_by_natural_key(self, company_name):\n        \"\"\"\n        Allow retrieval of a Codebook by its natural key instead of its\n        primary key.\n        \"\"\"\n        try:\n            company = Company.objects.get_by_natural_key(company_name)\n            return self.get(company=company)\n        except ObjectDoesNotExist:\n            _LOGGER.error('Codebook for Company \"%s\" does not exist',\n                          company_name)\n\n\nclass CodeBook(models.Model):\n    \"\"\"\n    Defines a collection of CodeNames that can be used to redact teaser data.\n    \"\"\"\n    company = models.OneToOneField(Company, primary_key=True)\n    codenames = models.ManyToManyField(CodeName)\n\n    objects = CodeBookManager()\n\n    class Meta:\n        \"\"\"\n        Metadata options for a Django Model.\n        \"\"\"\n        ordering = ['company']\n\n    def __str__(self):\n        return str(self.company)\n\n    @cached_property\n    def realnames(self):\n        \"\"\"\n        Returns a QuerySet of RealNames associated with the CodeBook,\n        sorted by rank.\n        \"\"\"\n        realnames = []\n        for codename in self.codenames.all():\n            realnames.extend(codename.realnames.all())\n        realnames.sort(key=lambda x: x.rank)\n        return realnames\n\n    def _get_codename_dict(self):\n        \"\"\"\n        Returns a dictionary in which the keys are RealNames and the values\n        are their corresponding CodeNames.\n        \"\"\"\n        codes = OrderedDict()\n        for realname in self.realnames:\n            codes.update(realname.to_dict())\n        return codes\n\n    def preview(self):\n        \"\"\"\n        Returns a string representation of a dictionary of the RealNames\n        and CodeNames associated with the CodeBook.\n        \"\"\"\n        codes = self._get_codename_dict()\n        return json.dumps(codes, indent=4)\n\n    def redact(self, text):\n        \"\"\"\n        Takes a text string and returns a redacted version of the text\n        using the CodeBook's CodeNames.\n        \"\"\"\n        for realname in self.realnames:\n            text = realname.redact(text)\n        return text\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "companies/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, 1, null, 1, null, 1, 1, 1, null, 1, 1, null], "name": "companies/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines Company class.\n\"\"\"\n\n# standard librray\nfrom uuid import uuid4\n\n# third party\nfrom django.db import models\n\n# local\nfrom cyphon.models import GetByNameManager\n\n\nclass Company(models.Model):\n    \"\"\"\n\n    \"\"\"\n    name = models.CharField(max_length=60, unique=True)\n    uuid = models.UUIDField(default=uuid4)\n\n    objects = GetByNameManager()\n\n    class Meta:\n        verbose_name_plural = 'companies'\n        ordering = ['name']\n\n    def __str__(self):\n        return self.name\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "contexts/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, 1, null, null, 1, 1, null], "name": "contexts/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclass for Contexts and registers Contexts with\nDjango Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom .forms import ContextFilterForm, ContextFilterInlineForm\nfrom .models import Context, ContextFilter\n\n\nclass ContextFilterInLineAdmin(admin.TabularInline):\n    \"\"\"\n    Customizes admin inline tables for Fittings.\n    \"\"\"\n    model = ContextFilter\n    extra = 1\n    form = ContextFilterInlineForm\n\n\nclass ContextFilterAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for ContextFilters.\n    \"\"\"\n    fieldsets = (\n        (None, {\n            'description': _(''),\n            'fields': (\n                'context',\n                'search_field',\n                'operator',\n                'value_field',\n            )\n        }),\n    )\n    list_display = (\n        'context',\n        'search_field',\n        'operator',\n        'value_field',\n    )\n    form = ContextFilterForm\n    save_as = True\n\n\nclass ContextAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Contexts.\n    \"\"\"\n    fieldsets = (\n        (None, {\n            'description': _(''),\n            'fields': (\n                'name',\n                'primary_distillery',\n                'related_distillery',\n            )\n        }),\n        (_('Time Frame'), {\n            'description': _(''),\n            'fields': (\n                ('before_time_interval', 'before_time_unit', ),\n                ('after_time_interval', 'after_time_unit', ),\n            )\n        }),\n        (_('Filters'), {\n            'description': _(''),\n            'fields': (\n                'filter_logic',\n            )\n        }),\n    )\n    list_display = (\n        'name',\n        'primary_distillery',\n        'related_distillery',\n        'before_time_interval',\n        'before_time_unit',\n        'after_time_interval',\n        'after_time_unit',\n    )\n    list_editable = (\n        'before_time_interval',\n        'before_time_unit',\n        'after_time_interval',\n        'after_time_unit',\n    )\n    list_filter = ('primary_distillery', )\n    inlines = [ContextFilterInLineAdmin]\n    save_as = True\n\n\nadmin.site.register(Context, ContextAdmin)\nadmin.site.register(ContextFilter, ContextFilterAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, 1, null, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, null, null, null, 0, 0, null, 0, 0, 0, null, 0, null, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, null, null, null, 0, 0, null, 0, 0, 0, null, 0, null, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, null, null, null, null, 0, 0, null, 0, 0, null, 0, null, 0, null, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, null, null, null, null, 0, 0, null, 0, 0, null, 0, null, 0, null, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, null, null, null, 0, 0, null, 0, 0, 0, null, 0, null, null, 1, 1, 1, 1, 1, null], "name": "contexts/autocomplete_light_registry.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines Autocomplete models for use in admin pages for the Contexts app.\n\"\"\"\n\n# third party\nimport autocomplete_light.shortcuts as autocomplete_light\n\n# local\nfrom distilleries.models import Distillery\nfrom utils.choices.choices import get_operator_choices, get_field_type\nfrom .models import Context\n\n\nclass FilterValueFieldsByFocalDistillery(autocomplete_light.AutocompleteListBase):\n    \"\"\"\n    Defines autocomplete rules for the value_field on the Context admin\n    page.\n    \"\"\"\n    choices = ()\n\n    attrs = {\n        'data-autocomplete-minimum-characters': 0,\n        'placeholder': 'select a distillery and click to see options...'\n    }\n\n    def choices_for_request(self):\n        \"\"\"\n        Overrides the choices_for_request method of the AutocompleteListBase\n        class. Filters options based on the selected primary_distillery.\n        \"\"\"\n        choices = self.choices\n        distillery_id = self.request.GET.get('primary_distillery', None)\n\n        if distillery_id:\n            distillery = Distillery.objects.get(pk=distillery_id)\n            choices = distillery.get_field_list()\n\n        return self.order_choices(choices)[0:self.limit_choices]\n\n\nclass FilterSearchFieldsByRelatedDistillery(autocomplete_light.AutocompleteListBase):\n    \"\"\"\n    Defines autocomplete rules for the value_field on the Context admin\n    page.\n    \"\"\"\n    choices = ()\n\n    attrs = {\n        'data-autocomplete-minimum-characters': 0,\n        'placeholder': 'select a related distillery and click to see options...'\n    }\n\n    def choices_for_request(self):\n        \"\"\"\n        Overrides the choices_for_request method of the AutocompleteListBase\n        class. Filters options based on the selected related_distillery.\n        \"\"\"\n        choices = self.choices\n        distillery_id = self.request.GET.get('related_distillery', None)\n\n        if distillery_id:\n            distillery = Distillery.objects.get(pk=distillery_id)\n            choices = distillery.get_field_list()\n\n        return self.order_choices(choices)[0:self.limit_choices]\n\n\nclass FilterValueFieldsByContext(autocomplete_light.AutocompleteListBase):\n    \"\"\"\n    Defines autocomplete rules for the value_field on the ContextFilter\n    admin page.\n    \"\"\"\n    choices = ()\n\n    attrs = {\n        'data-autocomplete-minimum-characters': 0,\n        'placeholder': 'select a distillery and click to see options...'\n    }\n\n    def choices_for_request(self):\n        \"\"\"\n        Overrides the choices_for_request method of the AutocompleteListBase\n        class. Filters options based on the primary_distillery of the selected\n        Context.\n        \"\"\"\n        choices = self.choices\n        context_id = self.request.GET.get('context', None)\n\n        if context_id:\n            context = Context.objects.select_related('primary_distillery')\\\n                             .get(pk=context_id)\n            choices = context.primary_distillery.get_field_list()\n\n        return self.order_choices(choices)[0:self.limit_choices]\n\n\nclass FilterSearchFieldsByContext(autocomplete_light.AutocompleteListBase):\n    \"\"\"\n    Defines autocomplete rules for the value_field on the ContextFilter\n    admin page.\n    \"\"\"\n    choices = ()\n\n    attrs = {\n        'data-autocomplete-minimum-characters': 0,\n        'placeholder': 'select a distillery and click to see options...'\n    }\n\n    def choices_for_request(self):\n        \"\"\"\n        Overrides the choices_for_request method of the AutocompleteListBase\n        class. Filters options based on the related_distillery of the\n        selected Context.\n        \"\"\"\n        choices = self.choices\n        context_id = self.request.GET.get('context', None)\n\n        if context_id:\n            context = Context.objects.select_related('related_distillery')\\\n                             .get(pk=context_id)\n            choices = context.related_distillery.get_field_list()\n\n        return self.order_choices(choices)[0:self.limit_choices]\n\n\nclass FilterOperatorsBySearchField(autocomplete_light.AutocompleteChoiceListBase):\n    \"\"\"\n    Defines autocomplete rules for the operator field on the ContextFilter\n    admin page.\n    \"\"\"\n    choices = ()\n\n    attrs = {\n        'data-autocomplete-minimum-characters': 0,\n        'placeholder': 'select a search field and click to see options...'\n    }\n\n    def choices_for_request(self):\n        \"\"\"\n        Overrides the choices_for_request method of the AutocompleteListBase\n        class. Filters options based on the selected search_field.\n        \"\"\"\n        choices = self.choices\n        search_field = self.request.GET.get('search_field', None)\n\n        if search_field:\n            field_type = get_field_type(search_field)\n            choices = get_operator_choices(field_type)\n\n        return self.order_choices(choices)[0:self.limit_choices]\n\n\nautocomplete_light.register(FilterValueFieldsByFocalDistillery)\nautocomplete_light.register(FilterSearchFieldsByRelatedDistillery)\nautocomplete_light.register(FilterValueFieldsByContext)\nautocomplete_light.register(FilterSearchFieldsByContext)\nautocomplete_light.register(FilterOperatorsBySearchField)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, 1, null, 1, 0, 0, null, null, null, 0, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, 1, null, 1, 0, 0, null, null, null, 0, null, 1, null], "name": "contexts/filters.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a custom permission class.\n\"\"\"\n\n# third party\nfrom django_filters.rest_framework import DjangoFilterBackend\n\n\nclass ContextFilterFilterBackend(DjangoFilterBackend):\n    \"\"\"\n\n    \"\"\"\n\n    def filter_queryset(self, request, queryset, view):\n        \"\"\"\n\n        \"\"\"\n        user = request.user\n\n        if not user.is_staff:\n            if user.company:\n                return queryset.filter(context__primary_distillery__company=user.company,\n                                       context__related_distillery__company=user.company)\\\n                               .distinct()\n            else:\n                return queryset.none()\n        else:\n            return queryset\n\n\nclass ContextFilterBackend(DjangoFilterBackend):\n    \"\"\"\n\n    \"\"\"\n\n    def filter_queryset(self, request, queryset, view):\n        \"\"\"\n\n        \"\"\"\n        user = request.user\n\n        if not user.is_staff:\n            if user.company:\n                return queryset.filter(primary_distillery__company=user.company,\n                                       related_distillery__company=user.company)\\\n                               .distinct()\n            else:\n                return queryset.none()\n        else:\n            return queryset\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, 1, null, null, 1, null, null, null, null, null, 1, 0, 0, 0, 0, null, 1, 1, null, null, null, null, 1, 1, 1, 1, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 0, 0, 0, 0, null, 1, 1, null, null, null, null, 1, 1, 1, 1, null, null, null, null, null], "name": "contexts/forms.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines forms for ContextFilters.\n\"\"\"\n\n# third party\nfrom autocomplete_light import forms as auto_forms\nfrom autocomplete_light import widgets as auto_widgets\n\n# local\nfrom cyphon.choices import OPERATOR_CHOICES\nfrom cyphon.autocomplete import AutoCompleteModelFormMixin\nfrom .models import ContextFilter\n\n\nclass ContextFilterForm(auto_forms.ModelForm, AutoCompleteModelFormMixin):\n    \"\"\"\n    Defines a form for adding or updating a ContextFilter using\n    autocomplete fields.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super(ContextFilterForm, self).__init__(*args, **kwargs)\n        self._restore_value('search_field', 'FilterSearchFieldsByContext')\n        self._restore_value('value_field', 'FilterValueFieldsByContext')\n        self._restore_choice('operator', OPERATOR_CHOICES, 'FilterOperatorsBySearchField')\n\n    class Media:\n        js = [\n            'js/dependent_autocomplete.js',\n            'js/contextfilter_autocomplete.js',\n        ]\n\n    class Meta:\n        model = ContextFilter\n        fields = ['context', 'search_field', 'operator', 'value_field']  # reorder\n        widgets = {\n            'search_field': auto_widgets.ChoiceWidget('FilterSearchFieldsByContext'),\n            'operator': auto_widgets.ChoiceWidget('FilterOperatorsBySearchField'),\n            'value_field': auto_widgets.ChoiceWidget('FilterValueFieldsByContext'),\n        }\n\n\nclass ContextFilterInlineForm(auto_forms.ModelForm, AutoCompleteModelFormMixin):\n    \"\"\"\n    Defines an inline form for adding or updating a ContextFilter using\n    autocomplete fields.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super(ContextFilterInlineForm, self).__init__(*args, **kwargs)\n        self._restore_value('search_field', 'FilterSearchFieldsByRelatedDistillery')\n        self._restore_value('value_field', 'FilterValueFieldsByFocalDistillery')\n        self._restore_choice('operator', OPERATOR_CHOICES, 'FilterOperatorsBySearchField')\n\n    class Media:\n        js = [\n            'js/dependent_autocomplete.js',\n            'js/contextfilter_inline_autocomplete.js',\n        ]\n\n    class Meta:\n        model = ContextFilter\n        fields = ['context', 'search_field', 'operator', 'value_field']  # reorder\n        widgets = {\n            'search_field': auto_widgets.ChoiceWidget('FilterSearchFieldsByRelatedDistillery'),\n            'operator': auto_widgets.ChoiceWidget('FilterOperatorsBySearchField'),\n            'value_field': auto_widgets.ChoiceWidget('FilterValueFieldsByFocalDistillery'),\n        }\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, 1, 1, 1, null, null, 1, 1, null, null, null, null, null, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, null, null, 1, 1, 1, null, 1, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, 1, null, 1, 1, 1, 1, 1, null, null, null, 1, 1, 1, null, null, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, null, null, 1, null, 1, 1, 1, null, 1, 1, null, null, null, null, null, null, 1, 1, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, 1, null, 1, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, 1, 1, 1, 1, 1, null, null, null, null, null, 1, 1, null, 1, null, null, null, 1, 1, 1, 1, 1, 1, null, 1, null, null, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, 1, 1, null, 1, 1, null, 1, null, null, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, null, null, null, 1, null, 1, 1, 1, null, 1, null, null, null, null, null, null, null, 1, 1, 1, null, null, 1, null, 1, 1, null, null, 1, null, 1, null, null, null, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, 1, 1, 1, null, null, null, null, null, null], "name": "contexts/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines Context and ContextFilter classes for finding documents related\nto a given reference document.\n\"\"\"\n\n# standard library\nfrom datetime import timedelta\n\n# third party\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.utils.functional import cached_property\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.fieldsets import QueryFieldset\nfrom cyphon.choices import (\n    LOGIC_CHOICES,\n    MINUTES,\n    OPERATOR_CHOICES,\n    TIME_UNIT_CHOICES,\n)\nfrom distilleries.models import Distillery\nfrom engines.queries import EngineQuery\nfrom engines.sorter import SortParam, Sorter\nfrom utils.choices.choices import get_field_type\nfrom utils.dateutils import dateutils as dt\n\n\nclass Context(models.Model):\n    \"\"\"\n    A Context takes a reference document that was distilled by one\n    Distillery and returns related documents from another Distillery.\n\n    The Context's optional time_interval defines a time frame in which\n    to search for related documents. A Context may also have one or more\n    ContextFilters. A ContextFilter filters related documents by a value\n    in the reference document.\n\n    Attributes\n    ----------\n    name : str\n        The name of the Context.\n\n    primary_distillery : Distillery\n        The Distillery in which the reference documents reside.\n\n    related_distillery : Distillery\n        A Distillery that should be searched for documents related to\n        documents in the primary_distillery.\n\n    before_time_interval : int\n        An int which, when combined with before_time_units, defines a\n        time frame in which to search for related documents. Captures\n        data generated prior to the data associated with the Alert.\n\n    before_time_unit : str\n        The time units for the before_time_interval. Possible values are\n        constrained to TIME_UNIT_CHOICES.\n\n    after_time_interval : int\n        An int which, when combined with after_time_units, defines a\n        time frame in which to search for related documents. Captures\n        data generated after the data associated with the Alert.\n\n    after_time_unit : str\n        The time units for the before_time_interval. Possible values are\n        constrained to TIME_UNIT_CHOICES.\n\n    Notes\n    -----\n\n    The Context's optional time_interval is relative to the date\n    associated with the reference document.\n\n    If a Context has neither a time_interval nor a ContextFilter, it\n    will not attempt to find related data. Instead, search requests\n    will return an error message asking the user to define a\n    time_interval or ContextFilter.\n\n    \"\"\"\n    name = models.CharField(max_length=60)\n    primary_distillery = models.ForeignKey(\n        Distillery,\n        related_name='contexts',\n        related_query_name='context'\n    )\n    related_distillery = models.ForeignKey(Distillery)\n    before_time_interval = models.PositiveIntegerField(null=True, default=0)\n    before_time_unit = models.CharField(max_length=3, choices=TIME_UNIT_CHOICES,\n                                        null=True, default=MINUTES)\n    after_time_interval = models.PositiveIntegerField(null=True, default=0)\n    after_time_unit = models.CharField(max_length=3, choices=TIME_UNIT_CHOICES,\n                                       null=True, default=MINUTES)\n    filter_logic = models.CharField(\n        max_length=40,\n        choices=LOGIC_CHOICES,\n        default='AND'\n    )\n\n    class Meta:\n        unique_together = ['name', 'primary_distillery']\n\n    def __str__(self):\n        return self.name\n\n    def clean(self):\n        super(Context, self).clean()\n        if self._has_time_interval():\n            if not self._focal_date_field:\n                msg = _('A time frame is specified, but the primary '\n                        'distillery\\'s Container has no designated date '\n                        'field. Please make sure the Container has a Taste '\n                        'with a date field.')\n                raise ValidationError(msg)\n            if not self._related_date_field:\n                msg = _('A time frame is specified, but the related '\n                        'distillery\\'s Container has no designated date '\n                        'field. Please make sure the Container has a Taste '\n                        'with a date field.')\n                raise ValidationError(msg)\n\n    @cached_property\n    def _focal_date_field(self):\n        \"\"\"\n\n        \"\"\"\n        return self.primary_distillery.get_date_field()\n\n    @cached_property\n    def _related_date_field(self):\n        \"\"\"\n        Returns the name of a date field in the related_distillery's\n        Container for filtering documents by time. If no such field\n        exists, returns the name of the field for storing the date\n        on which a distilled document is saved.\n        \"\"\"\n        return self.related_distillery.get_searchable_date_field()\n\n    def _has_before_interval(self):\n        \"\"\"\n        Returns a Boolean indicating whether the Context contains a\n        \"before\" time interval.\n        \"\"\"\n        return bool(self.before_time_interval and self.before_time_unit)\n\n    def _has_after_interval(self):\n        \"\"\"\n        Returns a Boolean indicating whether the Context contains an\n        \"after\" time interval.\n        \"\"\"\n        return bool(self.after_time_interval and self.after_time_unit)\n\n    def _has_time_interval(self):\n        \"\"\"\n        Returns a Boolean indicating whether the Context has a time\n        interval.\n        \"\"\"\n        return self._has_before_interval() or self._has_after_interval()\n\n    def _get_before_interval_in_seconds(self):\n        \"\"\"\n        If the Context has a time_interval and time_unit, returns the\n        number of seconds in the Context's time interval. Otherwise,\n        returns 0.\n        \"\"\"\n        if self._has_before_interval():\n            return dt.convert_time_to_seconds(self.before_time_interval,\n                                              self.before_time_unit)\n        else:\n            return 0\n\n    def _get_after_interval_in_seconds(self):\n        \"\"\"\n        If the Context has a time_interval and time_unit, returns the\n        number of seconds in the Context's time interval. Otherwise,\n        returns 0.\n        \"\"\"\n        if self._has_after_interval():\n            return dt.convert_time_to_seconds(self.after_time_interval,\n                                              self.after_time_unit)\n        else:\n            return 0\n\n    def _get_reference_time(self, data):\n        \"\"\"\n        Takes a dictionary of reference data and attempts to return a\n        datetime object from the designated date field in the dictionary.\n        \"\"\"\n        if self._focal_date_field:\n            return self.primary_distillery.get_date(data)\n\n    def _get_end_time(self, data):\n        \"\"\"\n        Takes a dictionary of data that was distilled by the Context's\n        primary_distillery and returns a datetime for the end of a time\n        frame for searching related data.\n        \"\"\"\n        reference_time = self._get_reference_time(data)\n        if reference_time:\n            seconds = self._get_after_interval_in_seconds()\n            return reference_time + timedelta(seconds=seconds)\n\n    def _get_start_time(self, data):\n        \"\"\"\n        Takes a dictionary of data that was distilled by the Context's\n        primary_distillery. Returns a datetime for the start of a time\n        frame for searching related data.\n        \"\"\"\n        reference_time = self._get_reference_time(data)\n        if reference_time:\n            seconds = self._get_before_interval_in_seconds()\n            return reference_time - timedelta(seconds=seconds)\n\n    def _create_timeframe_query(self, data):\n        \"\"\"\n        Takes a dictionary of data that was distilled by the Context's\n        primary_distillery. If the Context has a time_interval and\n        time_unit, returns a list of fieldset dictionaries for a\n        time-frame query. Otherwise, returns an empty list.\n        \"\"\"\n        timeframe = []\n\n        if self._has_time_interval():\n            start_time = self._get_start_time(data)\n            end_time = self._get_end_time(data)\n\n            if start_time:\n                timeframe.append(QueryFieldset(\n                    field_name=self._related_date_field,\n                    field_type='DateTimeField',\n                    operator='gt',\n                    value=start_time\n                ))\n\n            if end_time:\n                timeframe.append(QueryFieldset(\n                    field_name=self._related_date_field,\n                    field_type='DateTimeField',\n                    operator='lte',\n                    value=end_time\n                ))\n\n        if timeframe:\n            return EngineQuery(timeframe, 'AND')\n\n    def _create_filter_query(self, data):\n        \"\"\"\n        Takes a dictionary of data that was distilled by the Context's\n        primary_distillery. Returns a list of fieldset dictionaries for\n        query terms defined by the Context's ContextFilters. If the\n        Context has no ContextFilters, returns an empty list.\n        \"\"\"\n        fieldsets = [cfilter.create_fieldset(data) \\\n                     for cfilter in self.filters.all()]\n        if fieldsets:\n            return EngineQuery(fieldsets, self.filter_logic)\n\n    def _get_text_fields(self):\n        \"\"\"\n        Returns a list of text DataFields associated with the\n        primary_distillery's Container.\n        \"\"\"\n        return self.related_distillery.get_text_fields()\n\n    def _create_keyword_query(self, keyword):\n        \"\"\"\n\n        \"\"\"\n        keyword_search = []\n        if keyword:\n            fields = self._get_text_fields()\n            for field in fields:\n                keyword_search.append(QueryFieldset(\n                    field_name=field.field_name,\n                    field_type=field.field_type,\n                    operator='regex',\n                    value=keyword\n                ))\n        if keyword_search:\n            return EngineQuery(keyword_search, 'OR')\n\n    def _get_query(self, data, keyword):\n        \"\"\"\n\n        \"\"\"\n        filter_q = self._create_filter_query(data)\n        keyword_q = self._create_keyword_query(keyword)\n        timeframe_q = self._create_timeframe_query(data)\n        subqueries = [q for q in [filter_q, keyword_q, timeframe_q] if q]\n        if subqueries:\n            return EngineQuery(subqueries, 'AND')\n\n    def _get_sorter(self):\n        \"\"\"\n\n        \"\"\"\n        sort = SortParam(\n            field_name=self._related_date_field,\n            field_type='DateTimeField',\n            order='DESC',\n        )\n        return Sorter(sort_list=[sort])\n\n    def _find_related_data(self, data, keyword, page, page_size):\n        \"\"\"\n        Takes a dictionary of data that was distilled by the Context's\n        primary_distillery and an integer specifying the page in a\n        paginated result set. Returns a list of data dictionaries for\n        related documents that match the Context's time frame and\n        ContextFilters. If the Context has neither a time frame nor any\n        ContextFilters, returns a dictionary containing an error message.\n        \"\"\"\n        query = self._get_query(data, keyword)\n        sorter = self._get_sorter()\n\n        if query:\n            return self.related_distillery.find(query, sorter, page, page_size)\n        else:\n            return {'error': 'No query parameters available for searching '\n                             'related data. Please define a time interval, '\n                             'keyword, or filters for the Context.'}\n\n    def _get_reference_data(self, doc_id):\n        \"\"\"\n        Takes a document id and returns the matching document from the\n        Context's primary_distillery,\n        \"\"\"\n        return self.primary_distillery.find_by_id(doc_id)\n\n    def get_primary_distillery_fields(self):\n        \"\"\"\n        Returns a list of field names for fields in the\n        primary_distillery's Container.\n        \"\"\"\n        return self.primary_distillery.get_field_list()\n\n    def get_related_distillery_fields(self):\n        \"\"\"\n        Returns a list of field names for fields in the\n        related_distillery's Container.\n        \"\"\"\n        return self.related_distillery.get_field_list()\n\n    def get_related_data(self, data, keyword=None, page=None, page_size=None):\n        \"\"\"\n        Takes a dictionary of data that was distilled by the Context's\n        primary_distillery. Returns a dictionary that includes the name of\n        the related_distillery and a list of documents from that\n        distillery's Collection that match the Context's time frame and\n        ContextFilters. E.g.::\n\n            {\n                'distillery': 'mongodb.mydatabase.mycollection',\n                'results': [\n                    {\n                        'date': '1463150162',\n                        'username': 't-rex',\n                        'post': 'I hate pushups'\n                    }\n                ]\n            }\n\n        \"\"\"\n        results = self._find_related_data(data, keyword, page, page_size)\n        results['distillery'] = str(self.related_distillery)\n        return results\n\n    def get_related_data_by_id(self, doc_id, keyword=None,\n                               page=None, page_size=None):\n        \"\"\"\n        Takes a document id for a document distilled by the Context's\n        primary_distillery. Returns a dictionary that includes the name\n        of the related_distillery and a list of relevant documents from\n        that distillery. If a document matching the doc_id can't be\n        found in the primary_distillery's Collection, returns a dictionary\n        containing an error message.\n        \"\"\"\n        data = self._get_reference_data(doc_id)\n        if data:\n            return self.get_related_data(data, keyword, page, page_size)\n        else:\n            msg = 'The document associated with the id could not be found.'\n            return {'error': msg}\n\n\nclass ContextFilter(models.Model):\n    \"\"\"\n    Defines parameters for constructing a query expression to filter\n    data for a Context.\n\n    Attributes\n    ----------\n    context : Context\n        The Context with which the ContextFilter is associated.\n\n    value_field : str\n        The name of a Container field in the Context's primary_distillery\n        whose value will be used to construct a query expression.\n\n    search_field : str\n        The name of a Container field in the Context's related_distillery\n        whose value will be compared to that of the value_field.\n\n    operator : str\n        The operator that should be used in the query expression.\n        Options are constrained to OPERATOR_CHOICES.\n\n    \"\"\"\n    context = models.ForeignKey(Context, related_name='filters',\n                                related_query_name='filter')\n    value_field = models.CharField(\n        max_length=255,\n        verbose_name=_('value field in Distillery'),\n        help_text=_('The Container field whose value should be used to '\n                    'search the field of the Related Distillery.'))\n    search_field = models.CharField(\n        max_length=255,\n        verbose_name=_('search field in Related Distillery'),\n        help_text=_('The field of the Related Distillery\\'s Container '\n                    'that should be used to filter results.'))\n    operator = models.CharField(max_length=40, choices=OPERATOR_CHOICES)\n\n    class Meta:\n        unique_together = ('context', 'value_field', 'search_field')\n        ordering = ['search_field', 'value_field']\n\n    def clean(self):\n        \"\"\"\n        Overrides Django's default clean method for a Model. Checks\n        that the value_field is a field in the Container used by the\n        Focal Distillery of the Context. Similarly, checks that the\n        search_field is a field in the Container used by the Related\n        Distillery of the Context.\n        \"\"\"\n        super(ContextFilter, self).clean()\n        if not self._value_field_is_valid():\n            msg = 'The value field \"%s\" is not a field in the Container '\\\n                  'used by the Focal Distillery %s.' \\\n                  % (self.value_field, self.context.primary_distillery)\n            raise ValidationError(_(msg))\n\n        if not self._search_field_is_valid():\n            msg = 'The search field \"%s\" is not a field in the Container '\\\n                  'used by the Related Distillery %s.' \\\n                  % (self.search_field, self.context.related_distillery)\n            raise ValidationError(_(msg))\n\n    @property\n    def operator_text(self):\n        \"\"\"\n        Returns a human readable string for the context filter operator.\n        \"\"\"\n        for choice in OPERATOR_CHOICES:\n            if self.operator == choice[0]:\n                return choice[1]\n\n        return self.operator\n\n    def _value_field_is_valid(self):\n        \"\"\"\n        Returns a Boolean indicating whether the value_field is a field\n        in the Container used by the Focal Distillery of the Context.\n        \"\"\"\n        fields = self.context.get_primary_distillery_fields()\n        return bool(self.value_field in fields)\n\n    def _search_field_is_valid(self):\n        \"\"\"\n        Returns a Boolean indicating whether the search_field is a field\n        in the Container used by the Related Distillery of the Context.\n        \"\"\"\n        fields = self.context.get_related_distillery_fields()\n        return bool(self.search_field in fields)\n\n    def create_fieldset(self, data):\n        \"\"\"\n        Takes a dictionary of data that was distilled by the Context's\n        Focal Distillery. Returns a QueryFieldset representing a\n        query expression for the ContextFilter.\n        \"\"\"\n        value = data.get(self.value_field)\n        field_type = get_field_type(self.search_field)\n        return QueryFieldset(\n            field_name=self.search_field,\n            field_type=field_type,\n            operator=self.operator,\n            value=value\n        )\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, null, 1, 1, 1, null, null, null, null, null, null, null, null, null, 1, null, null, 1, 1, null, 1, null, null, 1, 1, 1, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, 1, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "contexts/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nSerializers for Contexts.\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom .models import Context, ContextFilter\nfrom distilleries.models import Distillery\n\n\nclass ContextFilterSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for ContextFilters.\n    \"\"\"\n\n    class Meta:\n        model = ContextFilter\n        fields = (\n            'id',\n            'context',\n            'search_field',\n            'operator',\n            'operator_text',\n            'value_field',\n            'url',\n        )\n\nclass ContextDistillerySerializer(serializers.ModelSerializer):\n    \"\"\"Serializer for a |Distillery| list.\"\"\"\n\n    id = serializers.ReadOnlyField(source='pk')  # pylint: disable=C0103\n    name = serializers.CharField(source='__str__')\n\n    class Meta(object):\n        \"\"\"Metadata options.\"\"\"\n\n        model = Distillery\n        depth = 1\n        fields = (\n            'id',\n            'name',\n            'url',\n        )\n\nclass ContextSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Contexts.\n    \"\"\"\n\n    primary_distillery = ContextDistillerySerializer()\n    related_distillery = ContextDistillerySerializer()\n    filters = ContextFilterSerializer(many=True)\n\n    class Meta:\n        model = Context\n        fields = (\n            'id',\n            'name',\n            'primary_distillery',\n            'related_distillery',\n            'before_time_interval',\n            'before_time_unit',\n            'after_time_interval',\n            'after_time_unit',\n            'filters',\n            'filter_logic',\n            'url',\n        )\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, 1, 1, null, null, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, 1, 1, 1, 1, 1, null, null, 1, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, 1, 1, 1, 1, 1, null, 1, 1, null, null, null, null, null, null, 1, 1, 1, 1, 1, 1, 1, null, null, 1, 1, 1], "name": "contexts/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines views for Contexts.\n\"\"\"\n\n# third party\nfrom django.conf import settings\nimport django_filters\nfrom django_filters.rest_framework import DjangoFilterBackend\nfrom rest_framework.decorators import detail_route\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\n\n# local\nfrom cyphon.views import CustomModelViewSet\nfrom distilleries.models import Distillery\nfrom .models import Context, ContextFilter\nfrom .serializers import ContextFilterSerializer, ContextSerializer\n\n_PAGE_SIZE = settings.PAGE_SIZE\n\n\nclass ContextFilterDjangoFilter(django_filters.FilterSet):\n    \"\"\"\n    Filter context filters by context\n    \"\"\"\n    context = django_filters.ModelMultipleChoiceFilter(\n        name='context',\n        queryset=Context.objects.all()\n    )\n\n    class Meta:\n        model = ContextFilter\n        fields = ['context']\n\n\nclass ContextFilterViewSet(CustomModelViewSet):\n    \"\"\"\n    REST API for ContextFilters.\n    \"\"\"\n    queryset = ContextFilter.objects.all()\n    serializer_class = ContextFilterSerializer\n    filter_class = ContextFilterDjangoFilter\n    custom_filter_backends = ['contexts.filters.ContextFilterFilterBackend']\n    permission_classes = [IsAuthenticated]\n\n\nclass ContextDjangoFilter(django_filters.FilterSet):\n    \"\"\"\n    Filter contexts by primary_distillery.\n    \"\"\"\n    primary_distillery = django_filters.ModelMultipleChoiceFilter(\n        name='primary_distillery',\n        queryset=Distillery.objects.all()\n    )\n\n    class Meta:\n        model = Context\n        fields = ['primary_distillery']\n\n\nclass ContextViewSet(CustomModelViewSet):\n    \"\"\"\n    REST API for Contexts.\n    \"\"\"\n    queryset = Context.objects.all().order_by('name')\n    serializer_class = ContextSerializer\n    filter_class = ContextDjangoFilter\n    custom_filter_backends = ['contexts.filters.ContextFilterBackend']\n    permission_classes = [IsAuthenticated]\n\n    @detail_route(methods=['get'], url_path='related-data-by-id')\n    def related_data_by_id(self, request, pk=None):\n        \"\"\"\n        Provides a REST API endpoint for GET requests for related data.\n        Takes a document id for a document distilled by the Context's\n        Focal Distillery and returns a list of related documents from\n        the Context's Related Distillery.\n        \"\"\"\n        context = self.get_object()\n        doc_id = self.request.query_params.get('id')\n        keyword = self.request.query_params.get('keyword')\n        page = self.request.query_params.get('page', 1)\n        page_size = self.request.query_params.get('page_size', _PAGE_SIZE)\n        if doc_id:\n            result = context.get_related_data_by_id(doc_id, keyword,\n                                                    page, page_size)\n        else:\n            msg = 'A document id must be provided.'\n            result = {'error': msg}\n        return Response(result)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, 1], "name": "cyphon/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\nfrom __future__ import absolute_import\n\n# This will make sure the celery app is always imported when\n# Django starts so that shared_task will use this app.\nfrom .celeryapp import app as celery_app\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, null, null, 1, 1, 1, 1, 1, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, 1, 1, null, null, null, null, 1, null, 1, null, null, null, null, 0, null, 1, null, null, null, null, null, 0, null, 1, null, null, null, null, 0, 0, null, null, null, null, null, null, 0, 0, null, 1, null, null, null, null, 0, 0, 0, null, 1, null, null, null, null, null, 0, 0, null, 1, null, null, null, null, 0, 0, null, null, 1, null, null, null, null, null, 0, 0, 0, 0, null, 1, null, null, null, null, null, 0, null, 1, null, null, null, null, 0, 0, null, 1, null, null, null, null, 0, 0, null, 0, 0, 0, null, 0, null, 1, null, null, null, null, 0, 0, null, 0, 0, 0, 0, null, 0, null, 1, null, null, null, null, 0, null, null, 0, null, null, 0, 0, null, 0, null, 0, null, 1, null, null, null, null, 0, 0, 0, 0, null, 0, 0, null, 1, null, null, null, null, null, 0, 0, 0, 0, null, 1, null, null, null, null, null, 0, 0, 0, 0, 0, 0, null, 1, 1, null, null, null, null, null, null, 0, 0, null, 0, 0, null, 0, 0, null, null, null, 0, null, 0, 0, 0, null, null, 0, null, 0, null, 0, 0, null, 0, 0, null, null, 0, null, 0, 0, 0, null, 0, 0, 0, null, 0, null, null, 1, null, null, null, null, 1, null, 1, null, null, null, 0, 0, null, 0, null, 1, null], "name": "cyphon/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclasses for testing configurations on admin pages.\n\"\"\"\n\n# standard library\nfrom collections import OrderedDict\nimport email\nimport json\nimport logging\n\n# third party\nimport autocomplete_light\nfrom django.conf.urls import url\nfrom django.contrib import admin\nfrom django.core.exceptions import ValidationError\nfrom django.db import transaction\nfrom django.db.utils import IntegrityError\nfrom django.http import JsonResponse\nfrom django.utils.decorators import method_decorator\nfrom django.views.decorators.csrf import csrf_protect\n\nLOGGER = logging.getLogger(__name__)\n\nCONFIG_TOOL_CLASSES = (\n    'collapse',\n    'grp-collapse',\n    'grp-closed',\n    'config-tool',\n)\n\n\nclass ConfigToolAdmin(admin.ModelAdmin):\n    \"\"\"\n    Provides an admin page with a configuration testing tool. The tool\n    takes a test string and returns the result for the specified\n    model method.\n\n    Attributes:\n        model_method: the method that is being tested\n        data_format: defines how the test string should be interpreted\n                     (e.g., as a str, json, int, or float)\n\n    \"\"\"\n    # TODO(LH): assert form is a ConfigForm\n\n    model_method = 'process'\n    data_format = 'str'\n\n    def get_urls(self):\n        \"\"\"\n        Overrides the ModelAdmin get_urls method to add urls for running\n        the configuration test and returning the result.\n        \"\"\"\n        urls = super(ConfigToolAdmin, self).get_urls()\n        custom_urls = [\n            url(r'(?P<object_id>[\\d]+)/change/test/$',\n                self.admin_site.admin_view(self.run_test)),\n            url(r'add/test/$', self.admin_site.admin_view(self.run_test)),\n        ]\n        return custom_urls + urls\n\n    @staticmethod\n    def _get_test_value(form):\n        \"\"\"\n        Takes a ConfigToolForm and returns its test value.\n        \"\"\"\n        return form.get_test_value()\n\n    @staticmethod\n    def _parse_email(text):\n        \"\"\"\n        Takes a string represeting an email message and returns a\n        Message object.\n        \"\"\"\n        return email.message_from_string(text)\n\n    def _format_test_value(self, form):\n        \"\"\"\n        Takes a ConfigToolForm and returns its test value in a format\n        that can be passed to the ConfigToolAdmin's model_method.\n        \"\"\"\n        raw_value = self._get_test_value(form)\n        formatters = {\n            'str': str,\n            'json': json.loads,\n            'int': int,\n            'float': float,\n            'email': self._parse_email,\n        }\n        format_val = formatters.get(self.data_format, 'str')\n        return format_val(raw_value)\n\n    def _get_model_instance(self, object_id):\n        \"\"\"\n        Takes a object id and returns the Model instance for that id.\n        Returns None if the object id is None.\n        \"\"\"\n        if object_id:\n            obj = self.model.objects.get(pk=object_id)\n            return obj\n\n    def _create_form_instance(self, request, object_id):\n        \"\"\"\n        Takes an HttpRequest and the object id for a Model instance.\n        Returns a ModelForm instance initialized with the QueryDict from\n        the request.\n        \"\"\"\n        instance = self._get_model_instance(object_id)\n        return self.form(request.POST, instance=instance)\n\n    def _create_formset_instances(self, request, instance):\n        \"\"\"\n        Takes an HttpRequest and a Model instance. Returns a list of\n        ModelFormsets initialized with the POST data from the request.\n        \"\"\"\n        formsets_with_inlines = self.get_formsets_with_inlines(request)\n        return [inline_formset(request.POST, instance=instance) \\\n                for (inline_formset, dummy_admin) in formsets_with_inlines]\n\n    @staticmethod\n    def _formsets_are_valid(formsets):\n        \"\"\"\n        Takes a list of ModelFormSets and returns a Boolean indicating\n        whether all formsets are valid.\n        \"\"\"\n        valid = True\n        for formset in formsets:\n            valid &= formset.is_valid()\n        return valid\n\n    @staticmethod\n    def _get_related_name(formset):\n        \"\"\"\n        Takes a ModelFormSet and a returns the name of the model with\n        which it's associated.\n        \"\"\"\n        return formset.fk.remote_field.get_accessor_name()\n\n    @staticmethod\n    def _get_form_errors(form):\n        \"\"\"\n        Takes a ModelForm and a returns a dict of its validation errors.\n        \"\"\"\n        form_errors = form.errors.as_json()\n        return json.loads(form_errors)\n\n    def _format_form_errors(self, form, prefix=''):\n        \"\"\"\n        Takes a ModelForm and an optional field prefix. Returns a\n        string detailing validation errors for fields in the form.\n        \"\"\"\n        error_dict = self._get_form_errors(form)\n        error_msg = ''\n\n        for (field, errors) in sorted(error_dict.items()):\n            msg_str = ' '.join([error['message'] for error in errors])\n            error_msg += prefix + field + ': ' + msg_str + '\\n'\n\n        return error_msg\n\n    def _format_formset_errors(self, formset):\n        \"\"\"\n        Takes a ModelFormSet and returns a string detailing any\n        validation errors for forms in the formset.\n        \"\"\"\n        related_name = self._get_related_name(formset)\n        error_mgs = ''\n\n        for index in range(0, formset.total_form_count()):\n            form = formset.forms[index]\n            prefix = '\\t%s-%s-' % (related_name, index)\n            error_mgs += self._format_form_errors(form, prefix)\n\n        return error_mgs\n\n    def _format_errors(self, form, formsets):\n        \"\"\"\n        Takes a ModelForm and a list of ModelFormSets and returns a\n        string detailing any validation errors for the form or formsets.\n        \"\"\"\n        error_msg = 'Sorry! The following fields contained errors:\\n\\n'\n\n        # add errors for the parent form\n        error_msg += self._format_form_errors(form, prefix='\\t')\n\n        # add errors for each formset\n        for formset in formsets:\n            error_msg += self._format_formset_errors(formset)\n\n        error_msg += '\\nPlease correct these errors and try again.'\n\n        return error_msg\n\n    def _sort_dict(self, data):\n        \"\"\"\n        Takes a dictionary and returns an OrderedDict in which all keys\n        are sorted.\n        \"\"\"\n        result = OrderedDict()\n        for (key, value) in sorted(data.items()):\n            if isinstance(value, dict):\n                result[key] = self._sort_dict(value)\n            else:\n                result[key] = value\n        return result\n\n    def _format_result(self, result):\n        \"\"\"\n        Takes the result returned from the ConfigToolAdmin's model_method\n        and returns it as a string. If the result is a dict, prettifies\n        the string before returning it.\n        \"\"\"\n        if isinstance(result, dict):\n            sorted_dict = self._sort_dict(result)\n            return json.dumps(sorted_dict, indent=4)\n        return str(result)\n\n    def _get_result(self, form, instance):\n        \"\"\"\n        Takes a ConfigToolForm and a Model instance. Passes the test value\n        in the form to the method of the Model instance specified by the\n        ConfigToolAdmin's model_method. Returns the result as a string.\n        \"\"\"\n        try:\n            value = self._format_test_value(form)\n            result = getattr(instance, self.model_method)(value)\n            return self._format_result(result)\n        except ValueError as error:\n            return 'The test string is improperly formatted: %s' % error\n\n    @method_decorator(csrf_protect)\n    def run_test(self, request, object_id=None):\n        \"\"\"\n        Takes an HttpRequest with data from a ConfigToolForm and the\n        object id for a Model instance. Creates a temporary version\n        of the Model instance using the form data and returns a\n        JsonResponse with the result of the configuration test.\n        \"\"\"\n        try:\n            with transaction.atomic():\n\n                forms_are_valid = True\n                form = self._create_form_instance(request, object_id)\n\n                if form.is_valid():\n                    instance = form.save()\n\n                    # pass the parent model instance to the formsets to create\n                    # related instances\n                    formsets = self._create_formset_instances(request, instance)\n\n                    if self._formsets_are_valid(formsets):\n                        for formset in formsets:\n                            formset.save()\n\n                        # all models are now saved, so get the test result\n                        result = self._get_result(form, instance)\n                    else:\n                        forms_are_valid = False\n                else:\n                    formsets = []\n                    forms_are_valid = False\n\n                if not forms_are_valid:\n                    result = self._format_errors(form, formsets)\n\n                # rollback the database when exiting the atomic block\n                transaction.set_rollback(True)\n\n        except IntegrityError as error:\n            LOGGER.error('An error occurred while creating a test instance: %s', request)\n            result = 'Could not create an object for testing: %s' % error\n\n        except ValidationError as error:\n            LOGGER.error('An error occurred while initializing a config test: %s', request)\n            result = 'A validation error occurred: %s' % error\n\n        return JsonResponse({'result': result})\n\n\nclass JSONDataAdmin(admin.ModelAdmin):\n    \"\"\"\n    Provides a |ModelAdmin| for a model with a |JSONField| named `data`.\n    Creates a prettified version of the field for display. \n    \"\"\"\n    readonly_fields = ('data_prettified',)\n\n    def data_prettified(self, instance):\n        \"\"\"\n        Displays sorted, pretty-printed JSON.\n        \"\"\"\n        if hasattr(instance, 'data'):\n            return json.dumps(instance.data, sort_keys=True, indent=4)\n        else:\n            LOGGER.error('Object has no data attribute.')\n\n    data_prettified.short_description = 'data'\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, null, null, 0, 0, 0, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 0, 0, 0, 0, 0, null, null, null, null, null, null, null], "name": "cyphon/autocomplete.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom autocomplete_light.widgets import ChoiceWidget\n\n# local\nfrom utils.choices.choices import get_choice_by_value\n\n\nclass AutoCompleteModelFormMixin(object):\n    \"\"\"\n    Provides a mixin for restoring values to autocomplete fields.\n    \"\"\"\n\n    def _restore_value(self, field_name, autocomplete_name):\n        \"\"\"\n        Takes the name of an form field and the name of a registered\n        Autocomplete widget. If the form is initialized with a value\n        for the field, the method restores the value to the Autocomplete\n        widget.\n        \"\"\"\n        value = self.initial.get(field_name, None)\n        if value not in [None, '']:\n            self.fields[field_name].widget = ChoiceWidget(\n                autocomplete_name,\n                extra_context={\n                    'values': [value],\n                    'choices': [value]\n                }\n            )\n\n    def _restore_choice(self, field_name, choices, autocomplete_name):\n        \"\"\"\n        Takes the name of an form field, a list of choices, and the name\n        of a registered Autocomplete widget. If the form is initialized\n        with a value for the field, the method restores the value to the\n        Autocomplete widget.\n        \"\"\"\n        value = self.initial.get(field_name, None)\n        if value not in [None, '']:\n            choice = get_choice_by_value(choices, value)\n            if choice:\n                self.fields[field_name].widget = ChoiceWidget(\n                    autocomplete_name,\n                    extra_context={\n                        'values': [choice[0]],\n                        'choices': [choice]\n                    }\n                )\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, 1, null, null, 1, null, 1, null, null, null, null, null, null, 0, 0, null, 0, null, null, 0], "name": "cyphon/baseclass.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a BaseClass that can be subclassed to create other base classes.\nProvides informative NotImplementedErrors.\n\"\"\"\n\n# standard library\nimport inspect\n\n\nclass BaseClass(object):\n    \"\"\"\n    A base class that can be subclassed to create other base classes.\n    It provides a way to raise informative NotImplementedErrors. This\n    allows developers to easily identify the module and class in which\n    a method needs to be implemented.\n\n    Classes derived from BaseClass (e.g., |Engine|) are intended\n    to be subclassed by other developers to extend the functionality\n    of the project.\n    \"\"\"\n\n    def raise_method_not_implemented(self):\n        \"\"\"\n        Raises a |NotImplementedError| with a message that specifies\n        the module and class in which the error was raised.\n        \"\"\"\n        module_name = self.__module__\n        class_name = type(self).__name__\n        method_name = inspect.stack()[1][3]\n\n        msg = (u'The %s method has not yet been implemented '\n               'for the %s.%s class.') % (method_name, module_name, class_name)\n\n        raise NotImplementedError(msg)\n\n    def raise_attr_not_implemented(self, attribute):\n        \"\"\"\n        Takes a string representing an attribute that has not been\n        been implemented. Raises a |NotImplementedError| with a message\n        that specifies the attribute, as well as the module and class in\n        which the error was raised.\n        \"\"\"\n        module_name = self.__module__\n        class_name = type(self).__name__\n\n        msg = (u'%s has not yet been implemented for the %s.%s class.') \\\n               % (attribute, module_name, class_name)\n\n        raise NotImplementedError(msg)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, null, 1, 0], "name": "cyphon/celeryapp.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# standard library\nfrom __future__ import absolute_import\nimport os\n\n# set the default Django settings module for the 'celery' program.\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'cyphon.settings.prod')\n\n# third party\nfrom celery import Celery\nfrom django.conf import settings\n\n\napp = Celery('cyphon', broker=settings.BROKER_URL, include=['cyphon.tasks'])\n\n# Using a string here means the worker will not have to\n# pickle the object when using Windows.\napp.config_from_object('django.conf:settings')\napp.autodiscover_tasks(lambda: settings.INSTALLED_APPS)\n\n# Optional configuration, see the application user guide.\napp.conf.update(\n    CELERY_TASK_RESULT_EXPIRES=3600,\n)\n\n\nif __name__ == '__main__':\n    app.start()\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, null, 1, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null], "name": "cyphon/choices.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines sets of choices for use throughout the project.\n\"\"\"\n\n# local\nfrom utils.dateutils.dateutils import SECONDS, MINUTES, HOURS, DAYS\n\n\n#: |Alert| priorities.\nALERT_LEVEL_CHOICES = (\n    ('CRITICAL', 'Critical'),\n    ('HIGH', 'High'),\n    ('MEDIUM', 'Medium'),\n    ('LOW', 'Low'),\n    ('INFO', 'Info'),\n)\n\n#: Workflow outcomes for |Alerts|.\nALERT_OUTCOME_CHOICES = (\n    ('false positive', 'false positive'),\n    ('duplicate', 'duplicate'),\n    ('completed', 'completed'),\n    ('N/A', 'N/A'),\n)\n\n#: Workflow states for |Alerts|.\nALERT_STATUS_CHOICES = (\n    ('NEW', 'New'),\n    ('BUSY', 'Busy'),\n    ('DONE', 'Done'),\n)\n\n#: Values from |FIELD_TYPE_CHOICES| that can be searched as dates.\nDATE_FIELDS = ['DateTimeField']\n\n#: Fields from mail objects that can be used in data models.\nEMAIL_FIELD_CHOICES = (\n    ('Attachment', 'Attachment'),\n    ('Attachments', 'Attachments'),\n    ('Date', 'Date'),\n    ('To', 'To'),\n    ('From', 'From'),\n    ('Subject', 'Subject'),\n    ('Content', 'Content'),\n)\n\n#: Field type options for fields in data models.\nFIELD_TYPE_CHOICES = (\n    ('BooleanField', 'BooleanField'),\n    ('CharField', 'CharField'),\n    ('ChoiceField', 'ChoiceField'),\n    ('DateTimeField', 'DateTimeField'),\n    ('EmailField', 'EmailField'),\n    ('FileField', 'FileField'),\n    ('FloatField', 'FloatField'),\n    ('IntegerField', 'IntegerField'),\n    ('GenericIPAddressField', 'IPAddressField'),\n    ('ListField', 'ListField'),\n    ('PointField', 'PointField'),\n    ('TextField', 'TextField'),\n    ('URLField', 'URLField'),\n    ('EmbeddedDocument', 'EmbeddedDocument'),\n)\n\nGEOCOORDINATE_CHOICES = (\n    ('LNG/LAT', 'Longitude, Latitude'),\n    ('LAT/LNG', 'Latitude, Logitude'),\n)\n\n#: Values from |FIELD_TYPE_CHOICES| that can be geoqueried.\nLOCATION_FIELDS = ['PointField']\n\n#: Formats used by API endpoints for geofilters\nLOCATION_FORMAT_CHOICES = (\n    ('box', 'Bounding Box'),\n    ('radius', 'Radius'),\n)\n\n#: Logical operators for combining query terms.\nLOGIC_CHOICES = (\n    ('AND', 'AND'),\n    ('OR', 'OR'),\n)\n\n#: Health statuses for |Monitors|.\nMONITOR_STATUS_CHOICES = (\n    ('RED', 'Red'),\n    ('YELLOW', 'Yellow'),\n    ('GREEN', 'Green'),\n)\n\n#: Operators that can be used in searches to filter field values.\nOPERATOR_CHOICES = (\n    ('eq', 'equals'),\n    ('in', 'contains'),\n    ('gt', 'greater than'),\n    ('gte', 'greater than or equal to'),\n    ('lt', 'less than'),\n    ('lte', 'less than or equal to'),\n    ('regex', 'contains'),\n    ('not:eq', 'does not equal'),\n    ('not:in', 'does not contain'),\n    ('not:regex', 'does not contain'),\n    ('not:missing', 'is not null'),\n    ('within', 'within')\n)\n\nREGEX_CHOICES = (\n    ('CharField:x', 'contains'),\n    ('CharField:^x', 'begins with'),\n    ('CharField:x$', 'ends with'),\n    ('CharField:^x$', 'equals'),\n)\n\n#: Search task options for Reservoir queries.\nSEARCH_TASK_CHOICES = (\n    ('ADHOC_SRCH', 'Ad hoc search'),\n    ('BKGD_SRCH', 'Background search'),\n)\n\n#: Categories for broadly categorizing field types.\nTARGET_TYPE_CHOICES = (\n    ('Account', 'Account'),\n    ('DateTime', 'DateTime'),\n    ('IPAddress', 'IPAddress'),\n    ('Keyword', 'Keyword'),\n    ('Location', 'Location'),\n)\n\n#: Values from |FIELD_TYPE_CHOICES| that can be searched as text.\nTEXT_FIELDS = [\n    'CharField',\n    'ChoiceField',\n    'EmailField',\n    'GenericIPAddressField',\n    'ListField',\n    'TextField',\n    'URLField',\n]\n\n#: Time unit options.\nTIME_UNIT_CHOICES = (\n    (SECONDS, 'Seconds'),\n    (MINUTES, 'Minutes'),\n    (HOURS, 'Hours'),\n    (DAYS, 'Days'),\n)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, 0, 0, 0, null, null, 0, null, null, null, null, 0, 0, null, 0, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null], "name": "cyphon/dashboard.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nThis file was generated with the customdashboard management command and\ncontains the class for the main dashboard.\n\nTo activate your index dashboard add the following to your settings.py:\n    GRAPPELLI_INDEX_DASHBOARD = 'cyphon.dashboard.CustomIndexDashboard'\n\"\"\"\n\n# third party\nfrom django.utils.translation import ugettext_lazy as _\nfrom grappelli.dashboard import modules, Dashboard\nfrom grappelli.dashboard.utils import get_admin_site_name\n\n\nclass CyphonIndexDashboard(Dashboard):\n    \"\"\"\n    Custom index dashboard.\n    \"\"\"\n\n    def init_with_context(self, context):\n        site_name = get_admin_site_name(context)\n\n        self.children.append(modules.ModelList(\n            _('Shaping Data'),\n            column=1,\n            collapsible=True,\n            css_classes=('grp-collapse grp-closed',),\n            models=(\n                'bottler.bottles.models.Bottle',\n                'bottler.labels.models.Label',\n                'bottler.containers.models.Container',\n            ),\n        ))\n\n        self.children.append(modules.ModelList(\n            _('Filtering Data'),\n            column=1,\n            collapsible=True,\n            css_classes=('grp-collapse grp-closed',),\n            models=(\n                'target.followees.models.Followee',\n                'target.locations.models.Location',\n                'target.searchterms.models.SearchTerm',\n            ),\n        ))\n\n        self.children.append(modules.Group(\n            _('Sifting Data'),\n            column=1,\n            collapsible=True,\n            css_classes=('grp-collapse grp-closed',),\n            children=[\n                modules.ModelList(\n                    _('Logs'),\n                    column=1,\n                    css_classes=('grp-collapse grp-closed',),\n                    models=(\n                        'sifter.logsifter.logsieves.models.LogRule',\n                        'sifter.logsifter.logsieves.models.LogSieve',\n                        'sifter.logsifter.logmungers.models.LogMunger',\n                        'sifter.logsifter.logchutes.models.LogChute',\n                    ),\n                ),\n                modules.ModelList(\n                    _('Email'),\n                    css_classes=('grp-collapse grp-closed',),\n                    models=(\n                        'sifter.mailsifter.mailsieves.models.MailRule',\n                        'sifter.mailsifter.mailsieves.models.MailSieve',\n                        'sifter.mailsifter.mailmungers.models.MailMunger',\n                        'sifter.mailsifter.mailchutes.models.MailChute',\n                    ),\n                ),\n                modules.ModelList(\n                    _('JSON Data'),\n                    column=1,\n                    css_classes=('grp-collapse grp-closed',),\n                    models=(\n                        'sifter.datasifter.datasieves.models.DataRule',\n                        'sifter.datasifter.datasieves.models.DataSieve',\n                        'sifter.datasifter.datamungers.models.DataMunger',\n                        'sifter.datasifter.datachutes.models.DataChute',\n                    ),\n                ),\n            ]\n        ))\n\n        self.children.append(modules.Group(\n            _('Condensing Data'),\n            column=1,\n            collapsible=True,\n            css_classes=('grp-collapse grp-closed',),\n            children=[\n                modules.ModelList(\n                    _('Logs'),\n                    css_classes=('grp-collapse grp-closed',),\n                    models=(\n                        'sifter.logsifter.logcondensers.models.LogParser',\n                        'sifter.logsifter.logcondensers.models.LogCondenser',\n                    ),\n                ),\n                modules.ModelList(\n                    _('Email'),\n                    css_classes=('grp-collapse grp-closed',),\n                    models=(\n                        'sifter.mailsifter.mailcondensers.models.MailParser',\n                        'sifter.mailsifter.mailcondensers.models.MailCondenser',\n                    ),\n                ),\n                modules.ModelList(\n                    _('JSON Data'),\n                    css_classes=('grp-collapse grp-closed',),\n                    models=(\n                        'sifter.datasifter.datacondensers.models.DataParser',\n                        'sifter.datasifter.datacondensers.models.DataCondenser',\n                    ),\n                ),\n            ]\n        ))\n\n        self.children.append(modules.ModelList(\n            _('Enhancing Data'),\n            column=1,\n            collapsible=True,\n            css_classes=('grp-collapse grp-closed',),\n            models=(\n                'inspections.models.InspectionStep',\n                'inspections.models.Inspection',\n                'lab.procedures.models.Procedure',\n            ),\n        ))\n\n        self.children.append(modules.ModelList(\n            _('Storing Data'),\n            column=1,\n            css_classes=('grp-collapse grp-closed',),\n            models=(\n                'warehouses.models.Warehouse',\n                'warehouses.models.Collection',\n            ),\n        ))\n\n        self.children.append(modules.ModelList(\n            _('Distilling Data'),\n            column=1,\n            css_classes=('grp-collapse grp-closed',),\n            models=(\n                'distilleries.models.Distillery',\n            ),\n        ))\n\n        self.children.append(modules.ModelList(\n            _('Investigating Data'),\n            column=1,\n            css_classes=('grp-collapse grp-closed',),\n            models=(\n                'contexts.models.Context',\n            ),\n        ))\n\n        self.children.append(modules.ModelList(\n            _('Configuring Alerts'),\n            column=1,\n            css_classes=('grp-collapse grp-closed',),\n            models=(\n                'monitors.models.Monitor',\n                'watchdogs.models.Watchdog',\n                'watchdogs.models.Muzzle',\n            ),\n        ))\n\n        self.children.append(modules.ModelList(\n            _('Manage Alerts'),\n            column=2,\n            collapsible=False,\n            models=(\n                'alerts.models.Alert',\n            ),\n        ))\n\n        self.children.append(modules.ModelList(\n            _('Manage Mail'),\n            column=2,\n            collapsible=False,\n            models=(\n                'django_mailbox.models.Mailbox',\n                'django_mailbox.models.Message',\n                'django_mailbox.models.MessageAttachment',\n            ),\n        ))\n\n        self.children.append(modules.ModelList(\n            _('People and Permissions'),\n            column=2,\n            collapsible=False,\n            models=(\n                'appusers.models.AppUser',\n                'django.contrib.auth.models.Group',\n            ),\n        ))\n\n        self.children.append(modules.Group(\n            _('App Configurations'),\n            column=2,\n            collapsible=True,\n            css_classes=('grp-collapse grp-closed',),\n            children=[\n                modules.ModelList(\n                    _('Passports & Visas'),\n                    css_classes=('grp-collapse grp-open',),\n                    models=(\n                        'ambassador.passports.models.Passport',\n                        'ambassador.visas.models.Visa',\n                    ),\n                ),\n                modules.ModelList(\n                    _('Alert Response'),\n                    css_classes=('grp-collapse grp-open',),\n                    models=(\n                        'responder.actions.models.Action',\n                        'responder.couriers.models.Courier',\n                        'responder.destinations.models.Destination',\n                    ),\n                ),\n                modules.ModelList(\n                    _('Data Collection'),\n                    css_classes=('grp-collapse grp-open',),\n                    models=(\n                        'aggregator.pipes.models.Pipe',\n                        'aggregator.plumbers.models.Plumber',\n                        'aggregator.reservoirs.models.Reservoir',\n                    ),\n                ),\n            ]\n        ))\n\n        # self.children.append(modules.AppList(\n        #     _('App Configurations'),\n        #     collapsible=True,\n        #     column=2,\n        #     css_classes=('grp-collapse grp-closed',),\n        #     exclude=(\n        #         'django.contrib.*',\n        #         'alerts.*',\n        #         'appusers.*',\n        #         'django_mailbox.models.Message*'\n        #     ),\n        # ))\n\n        self.children.append(modules.ModelList(\n            _('Records'),\n            column=3,\n            collapsible=False,\n            models=(\n                'responder.dispatches.models.Dispatch',\n                'aggregator.invoices.models.Invoice',\n                'ambassador.stamps.models.Stamp',\n            ),\n        ))\n\n        self.children.append(modules.LinkList(\n            _('Support'),\n            column=3,\n            children=[\n                {\n                    'title': _('Django Documentation'),\n                    'url': 'http://docs.djangoproject.com/',\n                    'external': True,\n                },\n            ]\n        ))\n\n        self.children.append(modules.RecentActions(\n            _('Recent Actions'),\n            limit=3,\n            collapsible=False,\n            column=3,\n        ))\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, 1, 1, 1, 1, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null], "name": "cyphon/fieldsets.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a |QueryFieldset| class. |QueryFieldsets| are used to construct\nqueries to data stores.\n\"\"\"\n\n# local\nfrom cyphon.choices import FIELD_TYPE_CHOICES, OPERATOR_CHOICES\n\n\nclass QueryFieldset(object):\n    \"\"\"\n\n    Attributes\n    ----------\n    field_name : str\n        The name of the field being queried.\n\n    field_type : str\n        The type of field being queried. Corresponds to a value in\n        |FIELD_TYPE_CHOICES|.\n\n    operator : str\n        The method used to evaluate the field being queried.\n        Corresponds to a value in |OPERATOR_CHOICES|.\n\n    value : str\n        The value used to filter field being queried.\n\n    Raises\n    ------\n    AssertionError\n        If the :attr:`~cyphon.fieldsets.QueryFieldset.field_name` is not in\n        |FIELD_TYPE_CHOICES| or the :attr:`~cyphon.fieldsets.QueryFieldset.field_type`\n        is not in |OPERATOR_CHOICES|.\n\n    \"\"\"\n\n    FIELD_TYPES = [choice[0] for choice in FIELD_TYPE_CHOICES]\n    OPERATORS = [choice[0] for choice in OPERATOR_CHOICES]\n\n    def __init__(self, field_name, field_type, operator, value):\n        self.field_name = field_name\n        self.field_type = field_type\n        self.operator = operator\n        self.value = value\n\n        assert self.field_type in self.FIELD_TYPES\n        assert self.operator in self.OPERATORS\n\n    @property\n    def __dict__(self):\n        return {\n            'field_name': self.field_name,\n            'field_type': self.field_type,\n            'operator': self.operator,\n            'value': self.value\n        }\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, 0, null, null, 0, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, 0, 0, null, 0, null, 0, null, null, null, null, null, null, 0, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, null, 0, null, 0, null, null, 0, null, 0, null, null, 0, 0, 0, 0, null, null, null, 0, 0, null, null, null, null, null, 0, 0, 0, 0, 0, null, 0, null, 0, null, null, null, null, null, 0, 0, 0, null, 0, null, null, null, null, null, 0, 0, null, 0, null, null, null, null, null, 0, 0, 0, 0, null, 0, null, null, null, null, null, null, 0, 0, 0, 0, 0, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, 0, null, 0, 0, null, 0, 0, null, 0, null, null, 0, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, 0, 0, 0, null, 0, 0, null, 0, null, 0], "name": "cyphon/filters.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines an ObjectFilterBackend class.\n\"\"\"\n\n# third party\nfrom django.db.models import Count, Q\nfrom django_filters.rest_framework import DjangoFilterBackend\n\n# local\nfrom cyphon.relations import ModelSearchMixIn\n\n\nclass ObjectFilterBackend(DjangoFilterBackend, ModelSearchMixIn):\n    \"\"\"\n    Provides a filter backend for a REST API endpoint. The backend can\n    filter results for a Model using an object instance of another\n    Model that may be related through a chain of forward relations.\n    The backend searches the model graph for direct or indirect\n    relationships between the two models, then uses the object instance\n    to query for related objects.\n\n    The backend searches for forward relationships defined by\n    |ForeignKey|, |ManyToManyField|, and |OneToOneField| fields.\n    It ignores reverse relations and |GenericForeignKey| fields.\n    It also ignores fields and models specified by :attr:`~IGNORED_FIELDS`\n    and :attr:`~IGNORED_MODELS`.\n\n    \"\"\"\n\n    IGNORED_FIELDS = [\n        ('alerts', 'Alert', 'assigned_user'),\n    ]\n    \"\"\"\n    A |list| of 3-tuples of |str| that specify the app label, model,\n    and field name of |Fields| that should be ignored when searching\n    the model graph for forward relations.\n\n    \"\"\"\n\n    @staticmethod\n    def _get_field_lookup(field, current_lookup):\n        \"\"\"\n        Takes a Model field and a string for a current lookup value.\n        The `current_lookup` represents a lookup for a field that\n        is a forward relation to the model to which the `field` belongs.\n        Returns a new lookup that spans the relationship to `field`.\n        \"\"\"\n        if current_lookup:\n            return current_lookup + '__' + field.name\n        else:\n            return field.name\n\n    @staticmethod\n    def _should_exclude(field):\n        \"\"\"\n        Takes a Model field and returns a Boolean indicating whether\n        the field should be used to exclude results that relate to\n        objects other than that specified in the filter query.\n        \"\"\"\n        return field.many_to_many\n\n    def _create_lookups(self, base_model, target_model, handled_fields=None,\n                        current_lookup=None):\n        \"\"\"\n        Returns lookups for forward relations from a base model to a\n        target model.\n\n        Parameters\n        ----------\n        base_model : type\n            The Model type representing the starting point when\n            searching for paths to the `target_model` via forward\n            relations.\n\n        target_model : type\n            A Model type representing the end point when searching\n            for paths from the `base_model` via forward relations.\n\n        handled_fields : `set` or `None`\n            A set of Model fields that have been visited in the current\n            path. Fields in this set are skipped if visited again.\n            This avoids circular paths that would cause infinite\n            recursions.\n\n        current_lookup : `str` or `None`\n            A lookup for the field at the current point in the path,\n            starting from the `base_model`.\n\n        Returns\n        -------\n        dict\n            A dictionary with the keys 'filters' and 'exclude'.\n            The value of 'filters' is a list of strings representing\n            lookups for forward relations from the `base_model` to the\n            `target model`. The value of 'exclude' is a subset of the\n            `filters` list that should be used to exclude results that\n            also relate to objects other than that specified in the\n            filter query (e.g., ManyToManyFields that relate to both\n            the specified object as well as other objects).\n\n        Notes\n        -----\n        This method intentionally ignores reverse relations.\n\n        Warning\n        -------\n        Currently, this method ignores forward relations defined using\n        GenericForeignKey fields.\n\n        \"\"\"\n        lookups = {'filters': [], 'exclude': []}\n        handled_fields = handled_fields or set()\n\n        for field in self.get_model_fields(base_model):\n\n            field_lookup = self._get_field_lookup(field, current_lookup)\n\n            # base case\n            if self.ignore_field(field=field, ignore_reverse=True,\n                                 handled_fields=handled_fields):\n                continue\n\n            # base case\n            elif field.related_model == target_model:\n                lookups['filters'].append(field_lookup)\n                if self._should_exclude(field):\n                    lookups['exclude'].append(field_lookup)\n\n            # recursive case\n            else:\n                handled_fields.add(field)\n                related_lookups = self._create_lookups(\n                    base_model=field.related_model,\n                    target_model=target_model,\n                    handled_fields=handled_fields,\n                    current_lookup=field_lookup\n                )\n                lookups['filters'].extend(related_lookups['filters'])\n                if self._should_exclude(field):\n                    lookups['exclude'].extend(related_lookups['filters'])\n                if related_lookups['exclude']:\n                    lookups['exclude'].extend(related_lookups['exclude'])\n\n        return lookups\n\n    def _get_lookups(self, obj, queryset):\n        \"\"\"\n        Takes a Model object instance and a QuerySet. Returns a dict\n        containing lookups used to filter and exclude records from the\n        queryset.\n        \"\"\"\n        base_model = queryset.model\n        target_model = type(obj)\n        return self._create_lookups(base_model, target_model)\n\n    @staticmethod\n    def _get_other_objects(obj):\n        \"\"\"\n        Takes a Model object instance and returns a QuerySet for all\n        objects except the given one.\n        \"\"\"\n        obj_model = type(obj)\n        return obj_model.objects.exclude(pk=obj.pk)\n\n    @staticmethod\n    def _apply_filter(queryset, filter_lookups, obj):\n        \"\"\"\n        Takes a QuerySet, a list of lookup strings, and a Model object\n        instance. Returns a QuerySet of records related to the object.\n        \"\"\"\n        filter_kwargs = {}\n        for filter_lookup in filter_lookups:\n            filter_kwargs[filter_lookup] = obj\n        return queryset.filter(**filter_kwargs)\n\n    def _apply_exclude(self, queryset, exclude_lookups, obj):\n        \"\"\"\n        Takes a QuerySet, a list of lookup strings, and a Model object\n        instance. Returns a QuerySet of records that do not contain\n        many-to-many forward relations to any object other than the\n        given `obj`.\n        \"\"\"\n        other_objects = self._get_other_objects(obj)\n        exclude_kwargs = {}\n        for exclude_lookup in exclude_lookups:\n            exclude_kwargs[exclude_lookup + '__in'] = other_objects\n        return queryset.exclude(**exclude_kwargs)\n\n    def filter_by_object(self, obj, queryset, exclude_mixed_m2m=True):\n        \"\"\"Filter a queryset based on forward relations to an object.\n\n        Parameters\n        ----------\n        obj : Model\n            An instance of a |Model| subclass used to filter the\n            `queryset`.\n\n        queryset : QuerySet\n            A |QuerySet| that should be filtered using forward relations\n            to the given `obj`.\n\n        exclude_mixed_m2m : bool\n            A |bool| indicating whether the QuerySet should exclude\n            records with many-to-many forward relations that are not\n            exclusive to the given `obj`. This can be used to prevent\n            a user from seeing objects that also relate to other users.\n\n        Returns\n        -------\n        QuerySet\n            A |QuerySet| containing only records with forward relations\n            to `obj`. If `exclude_mixed_m2m` is |True|, the queryset\n            also excludes records that relate to other objects of the\n            `obj`'s type.\n\n        Warning\n        -------\n        This method ignores reverse relations and relations defined\n        using GenericForeignKey fields.\n\n        \"\"\"\n        lookups = self._get_lookups(obj, queryset)\n        filter_lookups = lookups['filters']\n        exclude_lookups = lookups['exclude']\n\n        if filter_lookups:\n            queryset = self._apply_filter(queryset, filter_lookups, obj)\n\n        if exclude_mixed_m2m and exclude_lookups:\n            queryset = self._apply_exclude(queryset, exclude_lookups, obj)\n\n        return queryset.distinct()\n\n\nclass GroupFilterBackend(ObjectFilterBackend):\n    \"\"\"\n    Provides a filter backend to only show records that are either\n    associated with at least one of a given user's |Group| or are not\n    associated with any |Group|.\n    \"\"\"\n\n    def filter_queryset(self, request, queryset, view):\n        \"\"\"Return a filtered queryset.\n\n        Implements `custom filtering`_.\n\n        Parameters\n        ----------\n        request : Request\n             A `Request`_ for a resource.\n\n        queryset : QuerySet\n            A |QuerySet| to be filtered.\n\n        view : ModelViewSet\n            A `ModelViewSet`_.\n\n        Returns\n        -------\n        QuerySet\n            A |QuerySet| filtered to only show objects that are either\n            associated with at least one of a given user's |Group| or\n            are not associated with any |Group|.\n\n        \"\"\"\n        user = request.user\n        user_groups = user.groups.all()\n        queryset = queryset.annotate(group_cnt=Count('groups'))\n        no_groups_q = Q(group_cnt=0)\n        shared_groups_q = Q(groups__in=user_groups)\n\n        if user_groups:\n            queryset = queryset.filter(no_groups_q | shared_groups_q)\n        else:\n            queryset = queryset.filter(no_groups_q)\n\n        return queryset.distinct()\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, 1, null, 1, null, null, null, null, null, null, 1, null, null, null, 1, null, 1, 0, null, null, 0, null, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, 1, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, 1, null, null, null, 0, null], "name": "cyphon/forms.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines forms for configurations.\n\"\"\"\n\n# third party\nfrom django import forms\nfrom django.utils.safestring import mark_safe\nfrom django.template.loader import render_to_string\n\n# these values should correspond to the field in ConfigToolForm\nCONFIG_TEST_VALUE_FIELD = 'config_test_string'\nCONFIG_TEST_BUTTON = 'config_test_button'\nCONFIG_TEST_RESULT_FIELD = 'config_test_result'\n\nCONFIG_TOOL_INPUTS = (\n    CONFIG_TEST_VALUE_FIELD,\n    CONFIG_TEST_BUTTON,\n    CONFIG_TEST_RESULT_FIELD,\n)\n\n\nclass ConfigToolButtonWidget(forms.Widget):\n    \"\"\"\n    A form Widget for a \"Run Test\" button for a configuration test.\n    \"\"\"\n    template_name = 'config_test_button_widget.html'\n\n    def render(self, name, value, attrs=None):\n        context = {\n            'url': '/'\n        }\n        return mark_safe(render_to_string(self.template_name, context))\n\n\nclass ConfigToolForm(forms.ModelForm):\n    \"\"\"\n    Defines a ModelForm with a tool for testing a configuration.\n    \"\"\"\n\n    class Meta:\n        exclude = []\n\n    config_test_string = forms.CharField(\n        widget=forms.Textarea,\n        required=False,\n        help_text='Enter a test string.',\n        label=''\n    )\n    config_test_button = forms.CharField(\n        widget=ConfigToolButtonWidget,\n        required=False,\n        label=''\n    )\n    config_test_result = forms.CharField(\n        widget=forms.Textarea(attrs={'readonly':'readonly'}),\n        required=False,\n        label='Test result'\n    )\n\n    class Media:\n        js = ['js/cookie.js', 'js/config-tool.js']\n\n    def get_test_value(self):\n        \"\"\"\n        Returns the test value from the form.\n        \"\"\"\n        return self.cleaned_data[CONFIG_TEST_VALUE_FIELD]\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "cyphon/management/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "cyphon/management/commands/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "cyphon/management/commands/dumpconf.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null], "name": "cyphon/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nProvides subclasses and mixins to add functionality to Django's default\nmodel |Manager|.\n\"\"\"\n\n# standard library\nimport logging\n\n# third party\nfrom django.db import models\nfrom django.core.exceptions import ObjectDoesNotExist\n\n\nclass GetByNameMixin(object):\n    \"\"\"\n    Mixin for a |Manager| that provides a method for finding an object\n    by its unique `name`.\n    \"\"\"\n\n    def get_by_natural_key(self, name):\n        \"\"\"Get an object by its unique `name`.\n\n        Parameters\n        ----------\n        name : str\n            The object's `name`.\n\n        Returns\n        -------\n        |Model|\n            The |Model| object with the specified `name`.\n\n        \"\"\"\n        try:\n            return self.get(name=name)\n        except ObjectDoesNotExist:\n            logging.getLogger(self.__module__).error('%s \"%s\" does not exist',\n                                                     self.model.__name__, name)\n\nclass FindEnabledMixin(object):\n    \"\"\"\n    Mixin for a |Manager| that provides a method for finding enabled\n    objects.\n    \"\"\"\n\n    def find_enabled(self):\n        \"\"\"Find enabled objects.\n\n        Returns\n        -------\n        |QuerySet|\n            A |QuerySet| of objects for which `enabled` is set to |True|.\n\n        \"\"\"\n        default_queryset = self.get_queryset()\n        return default_queryset.filter(enabled=True)\n\n\nclass GetByNameManager(models.Manager, GetByNameMixin):\n    \"\"\"\n    A |Manager| that provides a `get_by_natural_key` method based on the\n    object's `name`.\n    \"\"\"\n    pass\n\n\nclass SelectRelatedManager(models.Manager):\n    \"\"\"\n    A |Manager| whose default queryset includes related object data.\n    \"\"\"\n\n    def get_queryset(self):\n        \"\"\"Get the default |QuerySet| for the model manager.\n\n        Overrides the default get_queryset method. Includes related\n        object data in search results to avoid additional database\n        queries.\n\n        Returns\n        -------\n        |QuerySet|\n            A |Queryset| which selects related objects.\n\n        See Also\n        --------\n        See Django's documentation for the `select related`_ method of a\n        |QuerySet|.\n\n        \"\"\"\n        default_queryset = super(SelectRelatedManager, self).get_queryset()\n        return default_queryset.select_related()\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, 0, 0, null, null, 0, null, null, null, null, null, 0, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, 0, 0, null, 0, null, null, null, null, 0, null, 0, null, null, null, null, null, 0, null, 0, null, null, null, null, null, 0, 0, 0, 0, 0, 0, null, 0, null, null, null, null, null, 0, 0, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, 0, null, null, null, null, null, 0, null, null, 0, null, null, null, null, 0, 0, null, null, 0, 0, null, null, null, 0, null, 0, 0, null, null, 0, 0, null, null, null, null, null, null, 0, null], "name": "cyphon/relations.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines an ObjectFilterBackend class.\n\"\"\"\n\n# third party\nfrom django.contrib.contenttypes.fields import GenericRelation\nfrom django.db.models.fields.reverse_related import ForeignObjectRel\nfrom django.apps import apps\n\n\nclass ModelSearchMixIn(object):\n    \"\"\"\n\n\n    \"\"\"\n\n    IGNORED_FIELDS = []\n    \"\"\"\n    A |list| of 3-tuples of |str| that specify the app label, model,\n    and field name of |Fields| that should be ignored when searching\n    the model graph for forward relations.\n\n    \"\"\"\n\n    IGNORED_MODELS = [\n        ('auth', 'Group'),\n        ('auth', 'Permission'),\n        ('contenttypes', 'ContentType'),\n    ]\n    \"\"\"\n    A |list| of 2-tuples of |str| that specify the app label and\n    model of |Models| that should be ignored when searching the\n    model graph for forward relations.\n\n    \"\"\"\n\n    @staticmethod\n    def get_model_key(model):\n        \"\"\"\n\n        \"\"\"\n        app_label = model._meta.app_label\n        model_name = model.__name__\n        return (app_label, model_name)\n\n    @staticmethod\n    def get_models(model_keys):\n        \"\"\"\n\n        \"\"\"\n        return [apps.get_model(*args) for args in model_keys]\n\n    @property\n    def ignored_models(self):\n        \"\"\"\n        Returns a list of Models that should be ignored when searching\n        the model graph for forward relations.\n        \"\"\"\n        return self.get_models(self.IGNORED_MODELS)\n\n    @property\n    def ignored_fields(self):\n        \"\"\"\n        Returns a list of Fields that should be ignored when searching\n        the model graph for forward relations.\n        \"\"\"\n        ignored_fields = []\n        for args in self.IGNORED_FIELDS:\n            model = apps.get_model(args[0], args[1])\n            field = model._meta.get_field(args[2])\n            ignored_fields.append(field)\n        return ignored_fields\n\n    @staticmethod\n    def field_is_reverse_relation(field):\n        \"\"\"\n        Takes a Model field and returns a Boolean indicating whether\n        the field refers to a reverse relation.\n        \"\"\"\n        reverse_relations = (ForeignObjectRel, GenericRelation, )\n        return isinstance(field, reverse_relations)\n\n    def ignore_field(self, field, ignore_reverse, handled_fields):\n        \"\"\"\n        Takes a Model field and a list of Model fields that have already\n        been examined. Returns a Boolean indicating whether the field\n        should be ignored when creating lookups.\n\n        Returns True if any of the following are True:\n            - the field does not have a related model\n            - the field has already been processed\n            - the field is in IGNORED_FIELDS\n            - the field's related model is in IGNORED_MODELS\n            - the field is a reverse relation\n\n        \"\"\"\n        return not field.related_model \\\n            or field in handled_fields \\\n            or field in self.ignored_fields \\\n            or field.related_model in self.ignored_models \\\n            or (ignore_reverse and self.field_is_reverse_relation(field))\n\n    @staticmethod\n    def get_model_fields(model):\n        \"\"\"\n        Takes a Model type and returns a tuple of fields associated\n        with it.\n        \"\"\"\n        return model._meta.get_fields(include_parents=True,\n                                      include_hidden=False)\n\n    def is_related(self, base_model, target_models, ignore_reverse,\n                   handled_fields=None):\n        \"\"\"\n\n        \"\"\"\n        is_related = False\n        handled_fields = handled_fields or set()\n\n        # base case\n        if base_model in target_models:\n            return True\n\n        # recursive case\n        else:\n            for field in self.get_model_fields(base_model):\n\n                if self.ignore_field(field, ignore_reverse, handled_fields):\n                    continue\n\n                else:\n                    handled_fields.add(field)\n                    is_related |= self.is_related(\n                        base_model=field.related_model,\n                        target_models=target_models,\n                        ignore_reverse=ignore_reverse,\n                        handled_fields=handled_fields\n                    )\n\n        return is_related\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "cyphon/settings/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, 1, null, 1, null, 1, null, 1, 1, 1, null, 1, null, null, null, 1, null, null, null, 1, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, 1, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, 1, null, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, 1, null, null, null, null, 1, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, 1, 1, null, null, 1, 1, 1, 1, 1, 1, null, null, null, 1, 1, 1, 1, 1, null, null, null, 1, null, 1, null, 1, null, 1, null, 1, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, 1, 1, 1, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, 1, null, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "cyphon/settings/default.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n[`source`_]\n\nDefault Django settings for Cyphon when running tests or compiling docs.\n\nFor more information on this Django file, see:\nhttps://docs.djangoproject.com/en/1.9/topics/settings/\n\nFor the full list of Django settings and their values, see:\nhttps://docs.djangoproject.com/en/1.9/ref/settings/\n\n.. _source: ../_modules/cyphon/settings/dev.html\n\n\"\"\"\n\n# standard library\nfrom collections import OrderedDict\nfrom datetime import timedelta\nimport os\nimport logging\nimport sys\n\nLOGGER = logging.getLogger(__name__)\n\n\n#########################\n# Settings from conf.py #\n#########################\n\nSECRET_KEY = 'this-should-be-a-string-of-random-characters'\n\n\n# HOSTNAME is used to send out an email to new users once an\n# administrator adds them.\n\nHOST_SETTINGS = {\n    'ALLOWED_HOSTS': [],\n    'CORS_ORIGIN_WHITELIST': [],\n    'HOSTNAME': 'localhost',\n}\n\nTEST = 'test' in sys.argv\n\nFUNCTIONAL_TESTS_ENABLED = os.getenv('FUNCTIONAL_TESTS_ENABLED', False)\n\nPAGE_SIZE = 10\n\nPROJ_DIR = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))\nHOME_DIR = os.path.dirname(PROJ_DIR)\nKEYS_DIR = os.path.join(HOME_DIR, 'keys')\n\nALERTS = {\n    'ALERT_URL': '/#/alerts?alertDetail=',\n}\n\nAPPUSERS = {\n    'CUSTOM_FILTER_BACKENDS': []\n}\n\nCODEBOOKS = {\n    'CODENAME_PREFIX': '**',  # prefix for displayed CodeNames\n    'CODENAME_SUFFIX': '**',  # suffix for displayed CodeNames\n}\n\nDISTILLERIES = {\n\n    # dictionary key for recording the date record was saved\n    'DATE_KEY': '_saved_date',\n\n    # dictionary key for saving the primary key of the distillery associated with a\n    # distilled document\n    'DISTILLERY_KEY': '_distillery',\n\n    # dictionary key for saving fields relating to the location of the raw data on\n    # which the distilled data is based\n    'RAW_DATA_KEY': '_raw_data',\n\n    # dictionary key for adding a label to a document\n    'LABEL_KEY': '_metadata',\n\n    # dictionary key for saving the name of the backend where the raw data is stored\n    'BACKEND_KEY': 'backend',\n\n    # dictionary key for saving the name of the database where the raw data is stored\n    'WAREHOUSE_KEY': 'database',\n\n    # dictionary key for saving the name of the collection where the raw data is stored\n    'COLLECTION_KEY': 'collection',\n\n    # dictionary key for saving the document id for the raw data\n    'DOC_ID_KEY': 'doc_id',\n\n    # dictionary key for saving the name of the platform associated with a document\n    'PLATFORM_KEY': '_platform',\n\n}\n\nELASTICSEARCH = {\n    'HOSTS': ['{0}:{1}'.format(os.getenv('ELASTICSEARCH_HOST', 'localhost'),\n                               os.getenv('ELASTICSEARCH_PORT', '9200'))],\n    'TIMEOUT': 30,\n}\n\nEMAIL = {\n    'NAME': 'Cyphon',\n    'HOST': 'smtp.gmail.com',\n    'HOST_USER': 'user@',\n    'HOST_PASSWORD': 'you',\n    'PORT': 587,\n    'USE_TLS': True,\n}\n\nGEOIP = {\n    'CITY_DB_PATH': '/usr/share/GeoIP/GeoLite2-City.mmdb'\n}\n\nJIRA = {\n    'SERVER': '',                       # JIRA url\n    'PROJECT_KEY': '',                  # project key\n    'ISSUE_TYPE': '',                   # issue type\n    'CUSTOM_FIELDS': {},                # custom fields\n    'PRIORITIES': {\n        'CRITICAL': 'Critical',\n        'HIGH': 'High',\n        'MEDIUM': 'Medium',\n        'LOW': 'Low',\n        'INFO': 'Low'\n    },\n    'DEFAULT_PRIORITY': 'Medium',\n    'STYLE_PARAMS': {\n        'title': 'Cyphon Alert',\n        'titleBGColor': '#dcdcdc',\n        'bgColor': '#f5f5f5',\n    },\n    'INCLUDE_FULL_DESCRIPTION': False,\n    'INCLUDE_EMPTY_FIELDS': False,\n    'INCLUDE_ALERT_COMMENTS': False,\n    'INCLUDE_ALERT_LINK': True,\n    'COMMENT_VISIBILITY': {\n        'type': 'role',\n        'value': ''                     # JIRA role\n    },\n}\n\nLOGSIFTER = {\n    'DEFAULT_LOG_MUNGER': 'default_log',\n    'DEFAULT_LOG_CHUTE_ENABLED': True,\n}\n\nMAILSIFTER = {\n    'DEFAULT_MAIL_MUNGER': 'default_mail',\n    'DEFAULT_MAIL_CHUTE_ENABLED': True,\n    'MAIL_COLLECTION': 'postgresql.django_cyphon.django_mailbox_message',\n    'EMAIL_CONTENT_PREFERENCES': ('text/plain', 'text/html'),\n    'ALLOWED_EMAIL_ATTACHMENTS': ('text/plain', 'application/pdf', 'image/jpeg', 'image/png'),\n    'ALLOWED_FILE_EXTENSIONS': ('.txt', '.pdf', '.jpeg', '.jpg', '.png'),\n    'ATTACHMENTS_FOLDER': 'attachments/%Y/%m/%d/',\n}\n\nMONGODB = {\n    'HOST': '{0}:{1}'.format(os.getenv('MONGODB_HOST', 'localhost'),\n                             os.getenv('MONGODB_PORT', '27017')),\n    'TIMEOUT': 20,\n}\n\nNOTIFICATIONS = {\n    'PUSH_NOTIFICATION_KEY': '',\n    'IGNORED_ALERT_LEVELS': ['INFO'],\n}\n\nPOSTGRES = {\n    'NAME': os.getenv('POSTGRES_DB', 'postgres'),\n    'USER': os.getenv('POSTGRES_USER', 'postgres'),\n    'PASSWORD': os.getenv('POSTGRES_PASSWORD', 'postgres'),\n    'HOST': os.getenv('POSTGRES_HOST', 'localhost'),\n    'PORT': os.getenv('POSTGRES_PORT', '5432'),\n}\n\nPRIVATE_FIELDS = [\n    DISTILLERIES['DISTILLERY_KEY'],\n    DISTILLERIES['RAW_DATA_KEY'],\n    DISTILLERIES['DATE_KEY'],\n]\n\nRABBITMQ = {\n    'EXCHANGE': 'cyphon',\n    'EXCHANGE_TYPE': 'direct',\n    'ROUTING_KEY': 'logstash',\n    'QUEUE_NAME': 'logstash',\n    'DURABLE': True,\n    'HOST': os.getenv('RABBITMQ_DEFAULT_HOST', 'rabbit'),\n    'VHOST': os.getenv('RABBITMQ_DEFAULT_VHOST', 'cyphon'),\n    'USERNAME': os.getenv('RABBITMQ_DEFAULT_USER', 'guest'),\n    'PASSWORD': os.getenv('RABBITMQ_DEFAULT_PASS', 'guest'),\n}\n\nTEASERS = {\n    'CHAR_LIMIT': 1000  # Character limit for teaser fields\n}\n\n#: Twitter authentication credentials for use in tests\nTWITTER = {\n    'KEY': '',                          # consumer key\n    'SECRET': '',                       # consumer secret\n    'ACCESS_TOKEN': '',                 # access token\n    'ACCESS_TOKEN_SECRET': '',          # access token secret\n}\n\nWAREHOUSES = {\n    'DEFAULT_STORAGE_ENGINE': 'elasticsearch'\n}\n\n\n#########################\n# Settings from base.py #\n#########################\n\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))\n\nALLOWED_HOSTS = HOST_SETTINGS['ALLOWED_HOSTS']\nCORS_ORIGIN_WHITELIST = HOST_SETTINGS['CORS_ORIGIN_WHITELIST']\nHOSTNAME = HOST_SETTINGS['HOSTNAME']\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.contrib.gis.db.backends.postgis',\n        'NAME': POSTGRES['NAME'],\n        'USER': POSTGRES['USER'],\n        'PASSWORD': POSTGRES['PASSWORD'],\n        'HOST': POSTGRES['HOST'],\n        'PORT': POSTGRES['PORT'],\n    }\n}\n\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [\n            '/templates/'\n        ],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.contrib.auth.context_processors.auth',\n                'django.template.context_processors.debug',\n                'django.template.context_processors.i18n',\n                'django.template.context_processors.media',\n                'django.template.context_processors.request',\n                'django.template.context_processors.static',\n                'django.template.context_processors.tz',\n                'django.contrib.messages.context_processors.messages',\n            ],\n        },\n    },\n]\n\nTEST = 'test' in sys.argv\n\n#: Application definition\nINSTALLED_APPS = (\n    'cyphon',  # must come before django.contrib.admin to override templates\n    'autocomplete_light',  # must come before django.contrib.admin\n    'django.contrib.admindocs',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.gis',\n    'django.contrib.messages',\n    'django.contrib.postgres',\n    'django.contrib.sessions',\n    'django.contrib.staticfiles',\n    # 'debug_toolbar',\n    'constance',\n    'constance.backends.database',\n    'grappelli.dashboard',  # must come after contenttypes and before grappelli\n    'grappelli',  # must come before django.contrib.admin\n    'django.contrib.admin',\n    'django_extensions',\n    'django_mailbox',\n    # 'corsheaders',  # Cross Origin Resource Sharing (local dev)\n    'rest_framework',\n    'rest_framework_docs',\n    'rest_framework_jwt',  # Auth tokens\n    'aggregator.filters',\n    'aggregator.funnels',\n    'aggregator.invoices',\n    'aggregator.pipes',\n    'aggregator.plumbers',\n    'aggregator.pumproom',\n    'aggregator.reservoirs',\n    'aggregator.samples',\n    'aggregator.streams',\n    'alerts',\n    'ambassador.passports',\n    'ambassador.stamps',\n    'ambassador.visas',\n    'appusers',\n    'bottler.containers',\n    'bottler.bottles',\n    'bottler.labels',\n    'bottler.tastes',\n    'categories',\n    'codebooks',\n    'companies',\n    'contexts',\n    'cyphon.settings',\n    'distilleries',\n    'httmock',\n    'inspections',\n    'lab.procedures',\n    'monitors',\n    'notifications',\n    'query',\n    'query.collectionqueries',\n    'query.reservoirqueries',\n    'responder.actions',\n    'responder.couriers',\n    'responder.destinations',\n    'responder.dispatches',\n    'sifter.datasifter.datachutes',\n    'sifter.datasifter.datacondensers',\n    'sifter.datasifter.datamungers',\n    'sifter.datasifter.datasieves',\n    'sifter.logsifter.logchutes',\n    'sifter.logsifter.logcondensers',\n    'sifter.logsifter.logmungers',\n    'sifter.logsifter.logsieves',\n    'sifter.mailsifter.mailchutes',\n    'sifter.mailsifter.mailcondensers',\n    'sifter.mailsifter.mailmungers',\n    'sifter.mailsifter.mailsieves',\n    'tags',\n    'target.followees',\n    'target.locations',\n    'target.searchterms',\n    'target.timeframes',\n    'utils.dateutils',\n    'utils.geometry',\n    'utils.parserutils',\n    'utils.validators',\n    'warehouses',\n    'watchdogs',\n)\n\nMIDDLEWARE_CLASSES = (\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'corsheaders.middleware.CorsMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.auth.middleware.SessionAuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n    'django.middleware.locale.LocaleMiddleware',\n)\n\nROOT_URLCONF = 'cyphon.urls'\n\nWSGI_APPLICATION = 'cyphon.wsgi.application'\n\n#: Authentication backend classes to use when attempting to authenticate a user\nAUTHENTICATION_BACKENDS = (\n    'django.contrib.auth.backends.ModelBackend', # this is default\n)\n\n#: The model to use to represent a User.=\nAUTH_USER_MODEL = 'appusers.AppUser'\n\n#: Link Creation for Emails sent from the server\nTRANSFER_PROTOCOL = 'http'\n\nAUTH_PASSWORD_VALIDATORS = [\n    {\n        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\n        'OPTIONS': {\n            'min_length': 9,\n        }\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',\n    },\n]\n\n#: Path for user registration\nREGISTRATION_PATH = '#/user/registration'\n\n#: Path for password reset\nPASSWORD_RESET_PATH = '#/user/reset-password'\n\n#: How many days until a unique user url is not valid\nPASSWORD_RESET_TIMEOUT_DAYS = 3\n\n#: Password strength variables\nPASSWORD_MIN_LENGTH = 6\nPASSWORD_MAX_LENGTH = 30\n\n# This section is for sending email to users. This example is a gmail account.\nEMAIL_NAME = EMAIL['NAME']\nEMAIL_HOST = EMAIL['HOST']\nEMAIL_HOST_USER = EMAIL['HOST_USER']\nEMAIL_HOST_PASSWORD = EMAIL['HOST_PASSWORD']\nEMAIL_PORT = EMAIL['PORT']\nEMAIL_USE_TLS = EMAIL['USE_TLS']\n\n# Internationalization\n# https://docs.djangoproject.com/en/1.8/topics/i18n/\nLANGUAGE_CODE = 'en-us'\nTIME_ZONE = 'US/Eastern'\nUSE_I18N = True\nUSE_L10N = True\nUSE_TZ = True\n\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/1.8/howto/static-files/\nSTATIC_URL = '/static/'\n\nSTATIC_ROOT = os.path.join(HOME_DIR, 'static')\n\nMEDIA_URL = '/media/'\n\nMEDIA_ROOT = os.path.join(HOME_DIR, 'media')\n\nAPI_URL = '/api/v1/'\n\n# REST Framework\n# http://www.django-rest-framework.org/api-guide/settings/\nREST_FRAMEWORK = {\n    'PAGE_SIZE': 10,\n    'DEFAULT_FILTER_BACKENDS': (\n        'django_filters.rest_framework.DjangoFilterBackend',\n    ),\n    'DEFAULT_METADATA_CLASS': 'rest_framework.metadata.SimpleMetadata',\n    'DEFAULT_PERMISSION_CLASSES': (\n        'rest_framework.permissions.IsAuthenticated',\n        # 'rest_framework.permissions.DjangoModelPermissions',\n    ),\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework.authentication.SessionAuthentication',\n        'rest_framework.authentication.BasicAuthentication',\n        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',\n    ),\n}\n\n# This is for the messaging system that celery will use to operate. This is\n# for rabbitMQ.\nBROKER_URL = 'amqp://{username}:{password}@{host}:5672/{vhost}'.format(\n    username=RABBITMQ['USERNAME'],\n    password=RABBITMQ['PASSWORD'],\n    host=RABBITMQ['HOST'],\n    vhost=RABBITMQ['VHOST']\n)\n\nCELERY_ACCEPT_CONTENT = ['json']\nCELERY_TASK_SERIALIZER = 'json'\nCELERY_RESULT_SERIALIZER = 'json'\n\n#: Schedule for Celery tasks\nCELERYBEAT_SCHEDULE = {\n    'get-new-mail': {\n        'task': 'tasks.get_new_mail',\n        'schedule': timedelta(seconds=30)\n    },\n    'run-health-check': {\n        'task': 'tasks.run_health_check',\n        'schedule': timedelta(seconds=60)\n    },\n    'run-bkgd-search': {\n        'task': 'tasks.run_bkgd_search',\n        'schedule': timedelta(seconds=60)\n    },\n}\n\nCELERYD_POOL_RESTARTS = True\n\nGRAPPELLI_ADMIN_TITLE = 'Cyphon'\nGRAPPELLI_INDEX_DASHBOARD = 'cyphon.dashboard.CyphonIndexDashboard'\n\nJASMINE_TEST_DIRECTORY = 'tests'\n\nJWT_AUTH = {\n    'JWT_ALLOW_REFRESH': True,\n    'JWT_RESPONSE_PAYLOAD_HANDLER': 'appusers.views.jwt_response_payload_handler',\n    'JWT_EXPIRATION_DELTA': timedelta(weeks=52),\n    'JWT_REFRESH_EXPIRATION_DELTA': timedelta(weeks=52)\n}\n\nCONSTANCE_IGNORE_ADMIN_VERSION_CHECK = True\nCONSTANCE_BACKEND = 'constance.backends.database.DatabaseBackend'\nCONSTANCE_CONFIG = OrderedDict([\n    ('PUSH_NOTIFICATIONS_ENABLED', (False, 'Turn on push notifications')),\n])\n\nDJANGO_MAILBOX_ATTACHMENT_UPLOAD_TO = os.path.join(MEDIA_ROOT,\n                                                   'mailbox_attachments/%Y/%m/%d/')\n\nREST_FRAMEWORK_DOCS = {\n    'HIDE_DOCS': os.environ.get('HIDE_DRFDOCS', False)\n}\n\n\n#########################\n# Settings from dev.py  #\n#########################\n\nDEBUG = True\n\n# Necessary for logstash environment\nREQUIREMENTS = os.path.join(os.path.dirname(BASE_DIR),\n                            'virtualenv/lib/python3.4/site-packages')\n\n#: URL for constructing link with MEDIA_URL\nBASE_URL = 'http://localhost:8000'\n\nCORS_ORIGIN_ALLOW_ALL = True\nCORS_ALLOW_CREDENTIALS = True\nCORS_ORIGIN_WHITELIST = ['http://localhost:8000']\n\nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'formatters': {\n        'verbose': {\n            'format': '%(levelname)s %(asctime)s %(name)s '\n                      '%(process)d %(thread)d %(message)s'\n        },\n        'simple': {\n            'format': '%(levelname)s %(message)s'\n        },\n    },\n    'handlers': {\n        'console': {\n            'level': 'DEBUG',\n            'class': 'logging.StreamHandler',\n            'formatter': 'simple'\n        },\n        'mail_admins': {\n            'level': 'WARNING',\n            'class': 'django.utils.log.AdminEmailHandler'\n        },\n    },\n    'loggers': {\n        'django.server': {\n            'handlers': ['console'],\n            'propagate': True,\n            'level': 'DEBUG'\n        },\n        'django.request': {\n            'handlers': ['console'],\n            'propagate': True,\n            'level': 'DEBUG'\n        },\n        'django': {\n            'handlers': ['console'],\n            'propagate': True,\n            'level': 'INFO',\n        },\n        'receiver': {\n            'handlers': ['console'],\n            'propagate': True,\n            'level': 'DEBUG',\n        },\n    }\n}\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, null, 1, null, 1, null, 1, 0, null, 1, null, null, 1, null, null, null, null, 1, 1, null, 1, 1, null, 1, null, null, 1, null, null, null, null, 0, 0], "name": "cyphon/tasks.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n[`source`_]\n\nCyphon Celery tasks.\n\n.. _source: ../_modules/cyphon/tasks.html\n\n\"\"\"\n\n# third party\nfrom django.apps import apps\nfrom django.db import close_old_connections\n\n# local\nfrom cyphon.celeryapp import app\nfrom aggregator.filters.services import execute_filter_queries\n\n\n@app.task(name='tasks.get_new_mail')\ndef get_new_mail():\n    \"\"\"\n    Checks mail for all Mailboxes.\n    \"\"\"\n    mailbox_model = apps.get_model(app_label='django_mailbox',\n                                   model_name='mailbox')\n    mailboxes = mailbox_model.objects.all()\n\n    for mailbox in mailboxes:\n        mailbox.get_new_mail()\n\n    close_old_connections()\n\n\n@app.task(name='tasks.run_health_check')\ndef run_health_check():\n    \"\"\"\n    Gathers all active Monitors and updates their status.\n    \"\"\"\n    monitor_model = apps.get_model(app_label='monitors', model_name='monitor')\n    monitors = monitor_model.objects.find_enabled()\n\n    for monitor in monitors:\n        monitor.update_status()\n\n    close_old_connections()\n\n\n@app.task(name='tasks.run_bkgd_search')\ndef run_bkgd_search():\n    \"\"\"\n    Runs background queries.\n    \"\"\"\n    execute_filter_queries()\n    close_old_connections()\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, 0, null, 1, null, 1, 1, null, 1, null, 1, 1, null, null, 1, 1, 1, null, null, 1, null, null, null, 1, null, 1, 1, 1, null, 1, 1, 1, null, null, 1, null, null, null, 1, null, 1, 1, 1, null, 1, 1, 1], "name": "cyphon/transaction.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# standard library\nfrom functools import wraps\n\n# third party\nfrom django import db\nfrom django.apps import apps\n\n\nLOCK_MODES = (\n    'ACCESS SHARE',\n    'ROW SHARE',\n    'ROW EXCLUSIVE',\n    'SHARE UPDATE EXCLUSIVE',\n    'SHARE',\n    'SHARE ROW EXCLUSIVE',\n    'EXCLUSIVE',\n    'ACCESS EXCLUSIVE',\n)\n\n\ndef require_lock(model_ref, lock_mode):\n    \"\"\"Decorator for PostgreSQL's table-level lock functionality.\n\n    Parameters\n    ----------\n    model_ref : |Model|, |tuple|, or |list|\n        Model or tuple/list of App label and Model name\n\n    lock_mode : str\n        The\n\n    Example\n    -------\n    .. code-block:: python\n\n       @transaction.atomic\n       @require_lock(MyModel, 'ACCESS EXCLUSIVE')\n       def myview(request):\n            ...\n\n    See also\n    --------\n    PostgreSQL's LOCK Documentation:\n    http://www.postgresql.org/docs/8.3/interactive/sql-lock.html\n\n    \"\"\"\n    def _decorator(func):\n        @wraps(func)  # preserve name and docstring of wrapped function\n        def _call(*args, **kwargs):\n            if isinstance(model_ref, (tuple, list)):\n                model = apps.get_model(*model_ref)\n            else:\n                model = model_ref\n\n            if lock_mode not in LOCK_MODES:\n                err_msg = '%s is not a PostgreSQL supported lock mode.' \\\n                          % lock_mode\n                raise ValueError(err_msg)\n\n            cursor = db.connection.cursor()\n            cursor.execute(\n                'LOCK TABLE %s IN %s MODE' % (model._meta.db_table, lock_mode)\n            )\n            return func(*args, **kwargs)\n        return _call\n    return _decorator\n\n\ndef close_old_connections(func):\n    \"\"\"\n\n    \"\"\"\n    @wraps(func)  # preserve name and docstring of wrapped function\n    def _decorator(*args, **kwargs):\n        result = None\n        try:\n            result = func(*args, **kwargs)\n        finally:\n            db.close_old_connections()\n        return result\n    return _decorator\n\n\ndef close_connection(func):\n    \"\"\"\n\n    \"\"\"\n    @wraps(func)  # preserve name and docstring of wrapped function\n    def _decorator(*args, **kwargs):\n        result = None\n        try:\n            result = func(*args, **kwargs)\n        finally:\n            db.connection.close()\n        return result\n    return _decorator\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, 1, 1, 1, 1, null, null, null, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1], "name": "cyphon/urls.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.conf.urls import include, url\nfrom django.conf.urls.static import static\nfrom django.conf import settings\nfrom django.contrib import admin\nfrom django.contrib.auth import views as auth_views\nfrom django.views.generic import RedirectView\nfrom rest_framework.routers import DefaultRouter\nimport rest_framework_jwt.views as rest_views\n# from rest_framework_docs.views import DRFDocsView\n\n# local\nfrom alerts.views import AlertViewSet, CommentViewSet\nfrom appusers.views import AppUserViewSet\nfrom contexts.views import ContextViewSet, ContextFilterViewSet\nfrom bottler.bottles.views import BottleViewSet, BottleFieldViewSet\nfrom bottler.containers.views import ContainerViewSet\nfrom distilleries.views import DistilleryViewSet\nfrom bottler.labels.views import LabelViewSet, LabelFieldViewSet\nfrom bottler.tastes.views import TasteViewSet\nfrom monitors.views import MonitorViewSet\nfrom query.collectionqueries.views import CollectionQueryViewSet, QueryFieldsetViewSet\nfrom responder.actions.views import ActionViewSet\nfrom responder.destinations.views import DestinationViewSet\nfrom responder.dispatches.views import DispatchViewSet\nfrom warehouses.views import WarehouseViewSet, CollectionViewSet\n\n\nurlpatterns = [\n    # url(r'^$', 'dashboard.views.index', name='index'),\n    url(r'^$', RedirectView.as_view(url='admin/')),\n    url(r'^admin/', include(admin.site.urls)),\n    url(r'^autocomplete/', include('autocomplete_light.urls')),\n    url(r'^grappelli/', include('grappelli.urls')), # grappelli URLS\n    url(r'^admin/doc/', include('django.contrib.admindocs.urls')),\n]\n\n# REST API\nrouter = DefaultRouter()\n\nrouter.register(r'actions', ActionViewSet)\nrouter.register(r'alerts', AlertViewSet)\nrouter.register(r'comments', CommentViewSet)\nrouter.register(r'bottles', BottleViewSet)\nrouter.register(r'bottlefields', BottleFieldViewSet)\nrouter.register(r'collectionqueries', CollectionQueryViewSet)\nrouter.register(r'collections', CollectionViewSet)\nrouter.register(r'containers', ContainerViewSet)\nrouter.register(r'contexts', ContextViewSet)\nrouter.register(r'contextfilters', ContextFilterViewSet)\nrouter.register(r'destinations', DestinationViewSet)\nrouter.register(r'distilleries', DistilleryViewSet)\nrouter.register(r'dispatches', DispatchViewSet)\nrouter.register(r'queryfieldsets', QueryFieldsetViewSet)\nrouter.register(r'labels', LabelViewSet)\nrouter.register(r'labelfields', LabelFieldViewSet)\nrouter.register(r'monitors', MonitorViewSet)\nrouter.register(r'tastes', TasteViewSet)\nrouter.register(r'users', AppUserViewSet)\nrouter.register(r'warehouses', WarehouseViewSet)\n\n# The API URLs are determined automatically by the router.\n# Additionally, we include the login URLs for the browsable API.\nurlpatterns += [\n    url(r'^admin/password_reset/$', auth_views.password_reset,\n        name='admin_password_reset'),\n    url(r'^admin/password_reset/done/$', auth_views.password_reset_done,\n        name='password_reset_done'),\n    url(r'^reset/(?P<uidb64>[0-9A-Za-z_\\-]+)/(?P<token>.+)/$',\n        auth_views.password_reset_confirm, name='password_reset_confirm'),\n    url(r'^reset/done/$', auth_views.password_reset_complete,\n        name='password_reset_complete'),\n\n    # REST API documenation\n    url(r'^docs/', include('rest_framework_docs.urls')),\n    # url(r'^docs/', DRFDocsView.as_view(drf_router=router), name='drfdocs'),\n    # TODO(LH): use DRFDocsView once DRF Docs does next release\n\n    # REST API\n    url(r'^api/v1/', include(router.urls)),\n    url(r'^api/v1/auth/',\n        include('rest_framework.urls', namespace='rest_framework')),\n    url(r'^api/v1/user/', include('appusers.urls')),\n    url(r'^api/v1/notifications/', include('notifications.urls')),\n    url(r'^api/v1/api-token-auth/', rest_views.obtain_jwt_token),\n    url(r'^api/v1/api-token-verify/', rest_views.verify_jwt_token),\n    url(r'^api/v1/api-token-refresh/', rest_views.refresh_jwt_token),\n] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)\n\nadmin.site.site_header = 'Cyphon'\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, 1, 1, 1, 1, 1, null, 1, null, null, null, 1, 1, 1, 1, 1, null, 1, null, null, null, null, 1, 1, 1, 1, 0, 0, null, 0], "name": "cyphon/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\"\"\"\n\n# standard library\nimport importlib\n\n# third party\nfrom rest_framework.settings import api_settings\nfrom rest_framework.viewsets import ModelViewSet\n\n\nclass CustomModelViewSet(ModelViewSet):\n    \"\"\"\n\n    \"\"\"\n    custom_filter_backends = []\n\n    def __init__(self, *args, **kawrgs):\n        super(CustomModelViewSet, self).__init__(*args, **kawrgs)\n        custom_backends = self._get_custom_backends()\n        default_backends = super(CustomModelViewSet, self).filter_backends\n        self.filter_backends = list(default_backends) + custom_backends\n\n    def _get_custom_backends(self):\n        \"\"\"\n\n        \"\"\"\n        backends = []\n        for class_ref in self.custom_filter_backends:\n            backend = self._get_class_from_string(class_ref)\n            backends.append(backend)\n        return backends\n\n    @staticmethod\n    def _get_class_from_string(class_ref):\n        \"\"\"\n\n        \"\"\"\n        try:\n            module_name, class_name = class_ref.rsplit('.', 1)\n            module = importlib.import_module(module_name)\n            return getattr(module, class_name)\n        except (ImportError, AttributeError) as error:\n            msg = \"Could not import '%s'. %s: %s.\" % \\\n                  (class_ref, error.__class__.__name__, error)\n            raise ImportError(msg)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, 0, null, 0, null, null, 0, null, null, 0, null], "name": "cyphon/wsgi.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nWSGI config for cyphon project.\n\nIt exposes the WSGI callable as a module-level variable named ``application``.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/1.7/howto/deployment/wsgi/\n\"\"\"\n\n# standard library\nimport os\n\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'cyphon.settings.prod')\n\n# third party\nfrom django.core.wsgi import get_wsgi_application\n\n\napplication = get_wsgi_application()\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1], "name": "distilleries/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\ndefault_app_config = 'distilleries.apps.DistilleriesConfig'\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, null, 1, 1, null, null, null, null, null], "name": "distilleries/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCustomizes admin pages for |Distilleries|.\n\n=========================  =========================================\nClass                      Description\n=========================  =========================================\n:class:`~DistilleryAdmin`  Customize admin pages for |Distilleries|.\n=========================  =========================================\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom distilleries.models import Distillery\n\n\n@admin.register(Distillery)\nclass DistilleryAdmin(admin.ModelAdmin):\n    \"\"\"Customizes admin pages for |Distilleries|.\"\"\"\n\n    list_display = [\n        'collection',\n        'container',\n        'is_shell',\n    ]\n    list_display_links = ['collection', 'container']\n    fields = [\n        'collection',\n        'container',\n        'is_shell',\n        'categories'\n    ]\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, 1, 1, null, 1, null, null, null, null, 1], "name": "distilleries/apps.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nConfigures the :ref:`Distilleries<distilleries>` app.\n\n============================  ===============================\nClass                         Description\n============================  ===============================\n:class:`~DistilleriesConfig`  |AppConfig| for |Distilleries|.\n============================  ===============================\n\n\"\"\"\n\n# third party\nfrom django.apps import AppConfig\n\n\nclass DistilleriesConfig(AppConfig):\n    \"\"\"|AppConfig| for |Distilleries|.\"\"\"\n\n    name = 'distilleries'\n    verbose_name = 'Distilleries'\n\n    def ready(self):\n        \"\"\"Override the default :meth:`~django.apps.AppConfig.ready` method.\n\n        Registers :mod:`~distilleries.signals` used in the app.\n        \"\"\"\n        import distilleries.signals  # noqa: F401\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, 1, 1, 1, 1, null, null, 1, 1, 1, 1, 1, 1, null, 1, 1, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, null, 1, null, null, null, 1, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, 1, null, null, 1, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, null, null, null, 0, 0, 0, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, 1, null, 1, null, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, 0, null, 1, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, 0, null, 1, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, 0, 1, 1, 1], "name": "distilleries/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a model for storing, retrieving, and displaying documents.\n\n===========================  ================================================\nClass                        Description\n===========================  ================================================\n:class:`~Distillery`         Coordinates doc storage, retrieval, and display.\n:class:`~DistilleryManager`  Model manager for |Distilleries|.\n===========================  ================================================\n\n\"\"\"\n\n# standard library\nimport logging\n\n# third party\nfrom django.conf import settings\nfrom django.db import models\nfrom django.utils import timezone\nfrom django.utils.functional import cached_property\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom categories.models import Category\nfrom companies.models import Company\nfrom bottler.containers.models import Container\nfrom distilleries import signals\nfrom utils.dateutils.dateutils import parse_date\nfrom warehouses.models import Collection\n\n_DISTILLERY_SETTINGS = settings.DISTILLERIES\n_PAGE_SIZE = settings.PAGE_SIZE\n\n_LOGGER = logging.getLogger(__name__)\n\n\nclass DistilleryManager(models.Manager):\n    \"\"\"Manage |Distillery| objects.\n\n    Adds methods to the default Django model manager.\n    \"\"\"\n\n    def get_queryset(self):\n        \"\"\"Get the initial |Distillery| queryset.\n\n        Overrides the default `get_queryset` method to also select\n        related objects.\n\n        Returns\n        -------\n        |Queryset|\n            A |Queryset| of |Distilleries|.\n\n        See also\n        --------\n        Django's documentation contains instructions on how to\n        `select related`_ objects and `modify an initial queryset`_.\n\n        \"\"\"\n        default_queryset = super(DistilleryManager, self).get_queryset()\n        return default_queryset.select_related()\n\n    def get_by_natural_key(self, backend, database, collection_name):\n        \"\"\"Get a |Distillery| by its natural key.\n\n        Allows retrieval of a |Distillery| by its natural key instead of\n        its primary key.\n\n        Parameters\n        ----------\n        backend : str\n            The backend of the |Warehouse| to which the Distillery's\n            |Collection| belongs.\n\n        database : str\n            The name of the |Warehouse| to which the Distillery's\n            |Collection| belongs.\n\n        collection_name : str\n            The name of the Distillery's |Collection|.\n\n        Returns\n        -------\n        |Distillery|\n            The |Distillery| associated with the natural key.\n\n        \"\"\"\n        collection = Collection.objects.get_by_natural_key(backend, database,\n                                                           collection_name)\n        if collection:\n            return self.get(collection=collection.pk)\n        else:\n            _LOGGER.error('%s for Collection %s.%s.%s does not exist',\n                          self.model.__name__, backend, database,\n                          collection_name)\n\n    def have_alerts(self, queryset=None):\n        \"\"\"Get |Distilleries| that are associated with |Alerts|.\n\n        Returns\n        -------\n        |Queryset|\n            A |Queryset| of |Distilleries| that are associated with\n            |Alerts|.\n        \"\"\"\n        if queryset is None:\n            queryset = self.get_queryset()\n        annotated_qs = queryset.annotate(alert_cnt=models.Count('alerts'))\n        return annotated_qs.filter(alert_cnt__gt=0)\n\n\nclass Distillery(models.Model):\n    \"\"\"Coordinate the storage, retrieval, and display of documents.\n\n    Specifies the data model for a set of documents, the location where\n    they are stored, and some general info about them. A Distillery can\n    also construct document teasers and redact those teasers prior to\n    display.\n\n    Attributes\n    ----------\n    collection : Collection\n        The |Collection| in which data is stored.\n\n    container : Container\n        The |Container| used to model the data.\n\n    company : Company\n        The |Company| associated with the data.\n\n    categories : `list` of `Categories`\n        A |list| of |Categories| that characterize the data.\n\n    is_shell : bool\n        Whether the Distillery is only used to model and retrieve data,\n        and is not responsible for saving data. This may be the case\n        if the data is saved by `Logstash`_ rather tha Cyphon.\n\n    \"\"\"\n\n    _DATE_KEY = _DISTILLERY_SETTINGS['DATE_KEY']\n\n    collection = models.OneToOneField(\n        Collection,\n        primary_key=True,\n        help_text=_('Storage location')\n    )\n    container = models.ForeignKey(\n        Container,\n        related_name='distilleries',\n        related_query_name='distillery',\n        help_text=_('Data model')\n    )\n    company = models.ForeignKey(Company, blank=True, null=True)\n    categories = models.ManyToManyField(\n        Category,\n        related_name='distilleries',\n        related_query_name='distillery',\n        blank=True,\n        help_text=_('Employ Watchdogs with these Categories.')\n    )\n    is_shell = models.BooleanField(\n        default=False,\n        help_text=_('A \"shell\" models and retrieves data, '\n                    'but is not responsible for saving data.')\n    )\n\n    objects = DistilleryManager()\n\n    class Meta(object):\n        \"\"\"Metadata options.\"\"\"\n\n        verbose_name_plural = 'distilleries'\n        ordering = ['collection']\n\n    def __str__(self):\n        \"\"\"Get a string representation of the Distillery instance.\n\n        Returns a printable string showing the Distillery's |Collection|.\n        \"\"\"\n        return str(self.collection)\n\n    @cached_property\n    def codebook(self):\n        \"\"\"A |CodeBook| for redacting data.\n\n        Returns\n        -------\n        |CodeBook|\n            The |CodeBook| associated with the Distillery's |Company|.\n\n        \"\"\"\n        if hasattr(self.company, 'codebook'):\n            return self.company.codebook\n\n    def _add_distillery_info(self, doc):\n        \"\"\"Add the Distillery's pk to a document.\n\n        Takes a dictionary of data, adds a field containing the primary\n        key of the Distillery, and returns the updated dictionary. This\n        field helps identify the origin of a record in queries that\n        aggregate data across |Collections|.\n        \"\"\"\n        doc[_DISTILLERY_SETTINGS['DISTILLERY_KEY']] = self.pk\n        return doc\n\n    def _add_date(self, doc):\n        \"\"\"Add the current datetime to a document.\n\n        Takes a dictionary of data, adds a field containing a |datetime|\n        for the current time, and returns the updated dictionary.\n        \"\"\"\n        doc[self._DATE_KEY] = timezone.now()\n        return doc\n\n    @staticmethod\n    def _get_doc_ref(doc_id, collection_str):\n        \"\"\"Create a location reference for a doc.\n\n        Takes a document id and a string representing a |Collection|.\n        Returns a dictionary that breaks down the location of the\n        document so it can be easily located.\n        \"\"\"\n        try:\n            source = collection_str.split('.')\n\n            return {\n                _DISTILLERY_SETTINGS['BACKEND_KEY']: source[0],\n                _DISTILLERY_SETTINGS['WAREHOUSE_KEY']: source[1],\n                _DISTILLERY_SETTINGS['COLLECTION_KEY']: source[2],\n                _DISTILLERY_SETTINGS['DOC_ID_KEY']: doc_id\n            }\n        except (AttributeError, IndexError):\n            _LOGGER.error('Info for raw data document %s could not be added',\n                          doc_id)\n\n    def _add_raw_data_info(self, doc, doc_id, collection_str):\n        \"\"\"Add a reference to the location of raw data.\n\n        Takes a dictionary of distilled data, the doc id of the original\n        (undistilled) data, and a string representation of the |Collection|\n        where the original data resides. Adds a location reference for the\n        undistilled data to the distilled doc, and returns the updated doc.\n        \"\"\"\n        raw_data_info = self._get_doc_ref(doc_id, collection_str)\n        if raw_data_info:\n            doc[_DISTILLERY_SETTINGS['RAW_DATA_KEY']] = raw_data_info\n        return doc\n\n    @staticmethod\n    def _add_platform_info(doc, platform):\n        \"\"\"Add |Platform| info to a doc.\n\n        Takes a document and a string representation of the |Platform|\n        from which the data came. Adds a field with the Platform info\n        and returns the updated doc.\n        \"\"\"\n        platform_key = _DISTILLERY_SETTINGS['PLATFORM_KEY']\n        doc[platform_key] = str(platform)\n        return doc\n\n    def _add_label(self, doc):\n        \"\"\"Enhance a doc with metadata.\n\n        Takes a dictionary of data, adds a '_metadata' field containing a\n        dictionary of metadata, and returns the 'labeled' data.\n        \"\"\"\n        return self.container.add_label(doc)\n\n    def _save_and_send_signal(self, doc):\n        \"\"\"Save a doc and send a |document_saved| signal.\n\n        Takes a dictionary of data, saves it in the Distillery's\n        |Collection|, and sends a signal that the document has been\n        saved. This signal is received by |Alarms|, such as |Watchdogs|\n        and |Monitors|.\n        \"\"\"\n        doc_id = self.collection.insert(doc)\n\n        signals.document_saved.send(sender=type(self), doc=doc,\n                                    distillery=self, doc_id=doc_id)\n        return doc_id\n\n    def _get_date_saved_field(self):\n        \"\"\"Get the field containing the date when a document was saved.\n\n        Returns the name of the field that stores the date when a\n        document was saved by Cyphon.\n        \"\"\"\n        if not self.is_shell:\n            return self._DATE_KEY\n\n    def get_bottle(self):\n        \"\"\"Get the |Bottle| used by the Distillery.\n\n        Returns\n        -------\n        |Bottle|\n            The |Bottle| associated with the Distillery's |Container|.\n\n        \"\"\"\n        return self.container.bottle\n\n    def get_backend(self):\n        \"\"\"Get the name of the storage engine used by the Distillery.\n\n        Returns\n        -------\n        str\n            The name of the storage engine associated with the\n            Distillery's |Collection| (e.g., 'elasticsearch').\n\n        \"\"\"\n        return self.collection.get_backend()\n\n    def get_warehouse_name(self):\n        \"\"\"Get the name of the |Warehouse| used by the Distillery.\n\n        Returns\n        -------\n        str\n            The name of the |Warehouse| associated with the Distillery's\n            |Collection|.\n\n        \"\"\"\n        return self.collection.get_warehouse_name()\n\n    def get_collection_name(self):\n        \"\"\"Get the name of the Distillery's |Collection|.\n\n        Returns\n        -------\n        str\n            The name of the |Collection| where the Distillery stores data.\n\n        \"\"\"\n        return self.collection.name\n\n    @cached_property\n    def warehouse(self):\n        \"\"\"The |Warehouse| used by the Distillery.\n\n        Returns\n        -------\n        |Warehouse|\n            The |Warehouse| where the Distillery's |Collection| is located.\n\n        \"\"\"\n        return self.collection.warehouse\n\n    @cached_property\n    def schema(self):\n        \"\"\"Get the |DataFields| in documents handled by the Distillery.\n\n        Returns\n        -------\n        |list| of |DataFields|\n            |DataFields| in the Distillery's |Container|.\n\n        \"\"\"\n        return self.container.fields\n\n    def get_text_fields(self):\n        \"\"\"Get |DataFields| that can be searched as text.\n\n        Returns\n        -------\n        |list| of |DataFields|\n            |DataFields| in the Distillery's |Container| that can be\n            searched as text.\n\n        \"\"\"\n        return self.container.get_text_fields()\n\n    def get_field_list(self):\n        \"\"\"Get the names of fields in docs handled by the Distillery.\n\n        Returns\n        -------\n        |list| of |str|\n            Field names associated with the Distillery's |Container|.\n\n        \"\"\"\n        return self.container.get_field_list()\n\n    def find(self, query, sorter=None, page=1, page_size=_PAGE_SIZE):\n        \"\"\"Find documents matching a query.\n\n        Parameters\n        ----------\n        query : |EngineQuery|\n            An |EngineQuery| defining critieria for matching documents\n            in the Distillery's |Collection|.\n\n        sorter : |Sorter| or |None|\n            A |Sorter| defining how results should be ordered.\n\n        page : int\n            The page of results to return.\n\n        page_size : int\n            The number of documents per page of results.\n\n        Returns\n        -------\n        |list| of |dict|\n            Documents matching the query.\n\n        \"\"\"\n        return self.collection.find(query, sorter, page, page_size)\n\n    def find_by_id(self, doc_ids):\n        \"\"\"Find one or more documents by id.\n\n        Parameters\n        ----------\n        doc_ids : |str| or |list| of |str|\n            A document id or a list of document ids.\n\n        Returns\n        -------\n        |dict|, |list| of |dict|, or |None|\n            Documents in the Distillery's |Collection| that match the\n            given id(s). Returns a |list| of documents if `doc_ids` is\n            a |list|; otherwise returns a single document. If no matches\n            are found, returns |None|.\n\n        \"\"\"\n        return self.collection.find_by_id(doc_ids)\n\n    def filter_ids_by_content(self, doc_ids, value):\n        \"\"\"Find the ids of documents with text that matches a value.\n\n        Parameters\n        ----------\n        doc_ids : |list| of |str|\n            The ids of documents to filter.\n\n        value : |str|\n            A value used to find matching documents.\n\n        Returns\n        -------\n        |list| of |str|\n            The subset of ids for documents containing the given `value`\n            in one or more of its text-searchable fields.\n\n        \"\"\"\n        fields = self.container.get_text_fields()\n        return self.collection.filter_ids(doc_ids, fields, value)\n\n    @cached_property\n    def taste(self):\n        \"\"\"A |Taste| for sampling the Distillery's documents.\n\n        Returns\n        -------\n        |Taste| or |None|\n            The |Taste| associated with the Distillery's |Container|,\n            if it has one. Otherwise, returns |None|.\n\n        \"\"\"\n        if hasattr(self.container, 'taste'):\n            return self.container.taste\n\n    def get_searchable_date_field(self):\n        \"\"\"Get the name of a searchable document date field.\n\n        Finds the name of a |DataField| in the Distillery's |Container|\n        that can be used to filter documents by date. This must be a\n        DateTimeField, not merely a CharField containing a date string\n        (since CharFields can't be indexed and searched as dates).\n\n        The method will first attempt to return the\n        :attr:`tastes.models.Taste.datetime` of the Distillery's\n        :attr:`~Distillery.taste`. If that fails and\n        :attr:`~Distillery.is_shell` is |False| (indicating that\n        documents are saved by Cyphon), it will instead return the field\n        that Cyphon uses to store the time when a document is saved.\n\n        Returns\n        -------\n        |str| or |None|\n            The name of the |DataField| in the Distillery's |Container|\n            that is used to filter documents by date. Returns |None| if\n            no such field exists.\n\n        \"\"\"\n        if self.taste and self.taste.datetime:\n            return self.taste.datetime\n        else:\n            return self._get_date_saved_field()\n\n    def get_date_field(self):\n        \"\"\"Get the name of the document date field.\n\n        Finds the name of the |DataField| in the Distillery's |Container|\n        that represents the document's date.\n\n        The method will first attempt to return the date field defined\n        by the Distillery's :attr:`~Distillery.taste`, which can be\n        either a DateTimeField or a CharField. If that fails and\n        :attr:`~Distillery.is_shell` is |False| (indicating that\n        documents are saved by Cyphon), it will instead return the field\n        that Cyphon uses to store the time when a document is saved.\n\n        Returns\n        -------\n        |str| or |None|\n            The name of the |DataField| in the Distillery's |Container|\n            that stores the date associated with a document. Returns\n            |None| if no such field exists.\n\n        Warning\n        -------\n        This method is used to find the name of the date field in a\n        document, without regard to field type (which could be\n        'CharField'). Thus, it will not necessarily return a field\n        that can actually be searched as a date. For that use case,\n        try the :meth:`~Distillery.get_searchable_date_field` method.\n\n        \"\"\"\n        if self.taste:\n            date_field = self.taste.get_date_field()\n            if date_field:\n                return date_field\n\n        return self._get_date_saved_field()\n\n    def _get_taste_date(self, doc):\n        \"\"\"Get the date from a document's teaser.\n\n        Takes a document and returns a |datetime| for it, as defined by\n        the Distillery's |Taste|, if it has one. Otherwise, returns |None|.\n        \"\"\"\n        if self.taste:\n            return self.taste.get_date(doc)\n\n    def get_date(self, doc):\n        \"\"\"Get the |datetime| associated with a document.\n\n        Attempts to return the date defined by the Distillery's |Taste|.\n        If none exists, attempts to return the date when the Distillery\n        saved the data.\n\n        Parameters\n        ----------\n        doc : dict\n            A document in the Distillery's |Collection|.\n\n        Returns\n        -------\n        |datetime| or |None|\n            The date associated with the document, if one exists.\n            Otherwise, returns |None|.\n\n        Warning\n        -------\n        If the Distillery is only used to retrieve documents saved by\n        other means (e.g., Logstash), the document will not contain the\n        '_saved_date' field that Cyphon adds to saved documents. In this\n        case, `get_date()` will return |None| if no date is defined\n        by the Distillery's |Taste|.\n\n        \"\"\"\n        taste_date = self._get_taste_date(doc)\n        if taste_date:\n            return taste_date\n        else:\n            date = doc.get(self._DATE_KEY)\n            return parse_date(date)\n\n    def get_sample(self, doc):\n        \"\"\"Get a teaser for a document.\n\n        Returns\n        -------\n        dict\n             A teaser for the document.\n\n        \"\"\"\n        return self.container.get_sample(doc)\n\n    def get_blind_sample(self, doc):\n        \"\"\"Get a redacted teaser for a document.\n\n        Creates a redacted teaser for a document, using the Distillery's\n        |Taste| and |CodeBook|.\n\n        Parameters\n        ----------\n        doc : dict\n\n        Returns\n        -------\n        dict\n            A redacted teaser for the document.\n\n        \"\"\"\n        if self.codebook:\n            return self.container.get_blind_sample(doc, self.codebook)\n        else:\n            return self.container.get_sample(doc)\n\n    def save_data(self, doc, doc_id, collection, platform=None):\n        \"\"\"Save a document to the Distillery's |Collection|.\n\n        Takes a distilled document and info on the location of the\n        raw data from which it was derived. Updates the document with\n        a reference to the raw data location and saves the distilled\n        document to the Distillery's |Collection|.\n\n        Parameters\n        ----------\n        doc : dict\n            A distilled document to be saved.\n\n        doc_id : str\n            The id of the raw document from which the distilled document\n            was derived.\n\n        collection : str\n            A string representation of the |Collection| where the raw\n            data resides (e.g., 'elasticsearch.cyphon.twitter').\n\n        platform : str\n            A string representation of the |Platform| from which the\n            data originated.\n\n        Returns\n        -------\n        str\n            The id of the saved document.\n\n        \"\"\"\n        doc = self._add_date(doc)\n        doc = self._add_distillery_info(doc)\n        if doc_id and collection:\n            doc = self._add_raw_data_info(doc, doc_id, collection)\n        if platform:\n            doc = self._add_platform_info(doc, platform)\n        doc = self._add_label(doc)\n        doc_id = self._save_and_send_signal(doc)\n        return doc_id\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, 1, 1, null, null, 1, null, null, 1, 1, 1, 1, null, 1, null, null, 1, 1, 1, null, null, null, null, null, null, null, null, null, 1, null, null, 1, 1, null, 1, null, null, 1, 1, 1, null, null, null, null], "name": "distilleries/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines serializers for |Distilleries|.\n\n====================================  ========================================\nClass                                 Description\n====================================  ========================================\n:class:`~DistilleryDetailSerializer`  Serializer for |Distillery| detail view.\n:class:`~DistilleryListSerializer`    Serializer for |Distillery| list view.\n====================================  ========================================\n\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom bottler.containers.serializers import ContainerSerializer\nfrom .models import Distillery\nfrom contexts.serializers import ContextSerializer\n\n\nclass DistilleryDetailSerializer(serializers.ModelSerializer):\n    \"\"\"Serializer for a |Distillery| object.\"\"\"\n\n    id = serializers.ReadOnlyField(source='pk')  # pylint: disable=C0103\n    container = ContainerSerializer()\n    name = serializers.CharField(source='__str__')\n    contexts = ContextSerializer(many=True)\n\n    class Meta(object):\n        \"\"\"Metadata options.\"\"\"\n\n        model = Distillery\n        depth = 2\n        fields = (\n            'collection',\n            'container',\n            'contexts',\n            'id',\n            'name',\n            'url',\n        )\n\n\nclass DistilleryListSerializer(serializers.ModelSerializer):\n    \"\"\"Serializer for a |Distillery| list.\"\"\"\n\n    id = serializers.ReadOnlyField(source='pk')  # pylint: disable=C0103\n    name = serializers.CharField(source='__str__')\n\n    class Meta(object):\n        \"\"\"Metadata options.\"\"\"\n\n        model = Distillery\n        depth = 1\n        fields = (\n            'id',\n            'name',\n            'url',\n        )\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, 1, null, null, null], "name": "distilleries/signals.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreates a signal to send when a |Distillery| saves a document.\n\n========================  ===================================\nConstant                  Description\n========================  ===================================\n:const:`~document_saved`  |Signal| that a document was saved.\n========================  ===================================\n\n\"\"\"\n\n# third party\nfrom django.dispatch import Signal\n\n# pylint: disable=C0103\ndocument_saved = Signal(providing_args=['doc', 'distillery', 'doc_id'])\n\"\"\"|Signal|\n\nSend a signal when a |Distillery| saves a document to a |Collection|.\n\"\"\"\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, 1, null, null, 1, null, null, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, 1, 1, null, 0, 0], "name": "distilleries/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines views for |Distilleries| using the Django REST framework.\n\n==============================  ===========================================\nClass                           Description\n==============================  ===========================================\n:class:`~DistilleryPagination`  Pagination for |Distillery| views.\n:class:`~DistilleryViewSet`     `ReadOnlyModelViewSet`_ for |Distilleries|.\n==============================  ===========================================\n\n\"\"\"\n\n# third party\nfrom rest_framework import viewsets\nfrom rest_framework.response import Response\nfrom rest_framework.decorators import list_route\nfrom rest_framework.pagination import PageNumberPagination\n\n# local\nfrom .models import Distillery\nfrom .serializers import DistilleryDetailSerializer\n\n\nclass DistilleryPagination(PageNumberPagination):\n    \"\"\"Pagination for |Distillery| views.\n\n    Paginates |Distilleries| using Django REST framework's\n    `PageNumberPagination`_.\n    \"\"\"\n\n    page_size = 50\n\n\nclass DistilleryViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"REST API views for Distilleries.\"\"\"\n\n    queryset = Distillery.objects.all()\n    serializer_class = DistilleryDetailSerializer\n    pagination_class = DistilleryPagination\n\n    @list_route(methods=['get'], url_path='have-alerts')\n    def have_alerts(self, request, *args, **kwargs):\n        \"\"\"Get |Distilleries| that are associated with |Alerts|.\n\n        Parameters\n        ----------\n        request : :class:`rest_framework.request.Request`\n            A Django REST framework HTTP `Request`_ object.\n\n        Returns\n        -------\n        :class:`rest_framework.response.Response`\n            A Django REST framework HTTP `Response`_ object containing\n            a list of JSON serialized |Distilleries| associated with\n            |Alerts|.\n\n        \"\"\"\n        filtered_qs = self.filter_queryset(self.get_queryset())\n        w_alerts_qs = Distillery.objects.have_alerts(filtered_qs)\n        page = self.paginate_queryset(w_alerts_qs)\n\n        if page is not None:\n            serializer = self.get_serializer(page, many=True)\n            return self.get_paginated_response(serializer.data)\n\n        serializer = self.get_serializer(filtered_qs, many=True)\n        return Response(serializer.data)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "engines/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "engines/elasticsearch/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, 1, 1, null, null, null], "name": "engines/elasticsearch/client.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreates an Elasticsearch client instance for use in other modules.\n\n=======================  =============================\nConstant                 Description\n=======================  =============================\n:const:`~ELASTICSEARCH`  Elasticsearch client.\n:const:`~TIMEOUT`        Request timeout in seconds.\n:const:`~VERSION`        Elasticsearch version number.\n=======================  =============================\n\n\"\"\"\n\n# third party\nfrom django.conf import settings\nimport elasticsearch\n\n_ES_SETTINGS = settings.ELASTICSEARCH\n\nTIMEOUT = _ES_SETTINGS['TIMEOUT']\n\"\"\"|int|\n\nRequest timeout in seconds.\n\"\"\"\n\n\nELASTICSEARCH = elasticsearch.Elasticsearch(_ES_SETTINGS['HOSTS'],\n                                            timeout=TIMEOUT)\n\"\"\":class:`~elasticsearch.Elasticsearch`\n\nLow-level Elasticsearch client. Provides a straightforward mapping from\nPython to Elasticsearch REST endpoints.\n\"\"\"\n\n\nVERSION = ELASTICSEARCH.info()['version']['number']\n\"\"\"|str|\n\nThe Elasticsearch version number (e.g., '5.2.0').\n\"\"\"\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, null, 1, 1, null, null, 1, 1, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, 1, 1, 1, null, 1, 1, 1, null, null, null, 1, 1, 1, 1, 1, 0, null, 1, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, null, 1, 1, 1, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, 1, null, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, 1, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, 1, 1, null, 1, null, null, null, null, null, 1, null, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, 1, null, 1, null, null, null, null, null, null, 1, 1, 1, null, null, null, null, 1, null, 1, 1, 1, 1, null, 1, null, null, null, null, null, null, 1, 1, 1, 1, 1, null, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, 1, null, 1], "name": "engines/elasticsearch/engine.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines an Elasticsearch Engine subclass and related decorators.\n\n======================================  ======================================\nClass                                   Description\n======================================  ======================================\n:class:`~ElasticsearchEngine`           Interface for an index and doc_type.\n======================================  ======================================\n\n======================================  ======================================\nConstant                                Description\n======================================  ======================================\n:const:`~ENGINE_CLASS`                  Name of module's Engine subclass.\n:const:`~MULTIPLE_FIELD_NAME_MAPPINGS`  Whether a field can have >1 data type.\n:const:`~TIME_SERIES_ENABLED`           Whether time-series are supported.\n======================================  ======================================\n\n======================================  ======================================\nDecorator                               Description\n======================================  ======================================\n:func:`~catch_connection_error`         Catch and log ConnectionErrors.\n:func:`~wait_for_status`                Wait for a certain cluster state.\n======================================  ======================================\n\n\"\"\"\n\n# standard library\nimport datetime\nfrom functools import wraps\nimport logging\n\n# third party\nfrom django.utils import timezone\nimport elasticsearch\n\n# local\nfrom engines.elasticsearch import queries as es_queries\nfrom engines.elasticsearch import results as es_results\nfrom engines.elasticsearch import sorter as es_sorter\nfrom engines.engine import Engine, MAX_RESULTS, PAGE_SIZE\nfrom .client import ELASTICSEARCH, TIMEOUT\nfrom .mapper import create_mapping\n\n_LOGGER = logging.getLogger(__name__)\n\n\nENGINE_CLASS = 'ElasticsearchEngine'\n\"\"\"|str|\n\nThe name of the Engine subclass defined in this module.\n\"\"\"\n\n\nMULTIPLE_FIELD_NAME_MAPPINGS = False\n\"\"\"|bool|\n\nWhether the Engine allows fields with the same name to be mapped to\ndifferent data types in the same index.\n\"\"\"\n\n\nTIME_SERIES_ENABLED = True\n\"\"\"|bool|\n\nWhether this Engine can store data in a time series, for example, by\ncreating timestamped indexes (e.g. 'logstash-%Y-%m-%d'). This is used\nfor easily archiving or deleting old data.\n\"\"\"\n\n\ndef catch_connection_error(func):\n    \"\"\"Catch and log :exc:`~elasticsearch.exceptions.ConnectionError`.\n\n    Decorator for functions that require an Elasticsearch connection.\n    If a connection cannot be established, catches and logs the error.\n\n    Parameters\n    ----------\n    func : function\n        The function to modify.\n\n    Returns\n    -------\n    function\n        The modified function.\n\n    \"\"\"\n    @wraps(func)  # preserve name and docstring of wrapped function\n    def _decorator(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except elasticsearch.exceptions.ConnectionError:\n            _LOGGER.error('Cannot connect to Elasticsearch')\n    return _decorator\n\n\ndef wait_for_status(status, timeout=TIMEOUT):\n    \"\"\"\n    Wait for a particular Elasticsearch cluster status.\n\n    Decorator for functions that require a particular cluster state.\n    Waits for the cluster to attain the given status before executing\n    the function.\n\n    Parameters\n    ----------\n    status : str\n        The desired cluster state. Options are: 'green', 'yellow', 'red'.\n\n    timeout : |int| or |float|\n        The number of seconds to wait for the desired state.\n\n    Returns\n    -------\n    function\n        The modified function.\n\n    \"\"\"\n    def _decorator(func):\n        @wraps(func)  # preserve name and docstring of wrapped function\n        def _call(*args, **kwargs):\n            ELASTICSEARCH.cluster.health(wait_for_status=status,\n                                         request_timeout=timeout)\n            return func(*args, **kwargs)\n        return _call\n    return _decorator\n\n\nclass ElasticsearchEngine(Engine):\n    \"\"\"An interface for an Elasticsearch index and doc_type.\n\n    Provides basic CRUD operations for a particular document type\n    within a particular Elasticsearch index or time series\n    (e.g., 'logstash-%Y-%m-%d').\n\n    The index and doc_type are determined by the |Collection| used\n    to initialize the Engine instance. The mapping is based on the\n    |Container| associated with that |Collection|.\n\n    Parameters\n    ----------\n    collection : |Collection|\n        The |Collection| that defines the index and doc_type of the\n        documents to be handled by the Engine. This is also used to\n        determine the mapping.\n\n    Attributes\n    ----------\n    warehouse_collection : Collection\n        The |Collection| that defines the index and doc_type of the\n        documents to be handled by the Engine.\n\n    schema : `list` of `DataFields`\n        |DataFields| that describe the nature of each field in the\n        document type handled by the Engine. Used to create a mapping.\n\n    \"\"\"\n\n    @catch_connection_error\n    @wait_for_status('yellow')\n    def __init__(self, collection):\n        \"\"\"Initialize an ElasticsearchEngine instance.\n\n        Creates an Elasticsearch index with the Engine's index name\n        and a mapping defined by the Engine's schema, if one does not\n        already exist.\n        \"\"\"\n        super(ElasticsearchEngine, self).__init__(collection)\n        self._index_name = self.warehouse_collection.get_warehouse_name()\n        self._doc_type = self.warehouse_collection.name\n        self._in_time_series = self.warehouse_collection.in_time_series()\n\n        if not self._in_time_series and not self._index_exists():\n            self._create_index()\n\n    def __str__(self):\n        \"\"\"Get a string representation of the Engine instance.\n\n        Returns a printable string showing the index and doc_type.\n        \"\"\"\n        return '%s.%s' % (self._index_name, self._doc_type)\n\n    @staticmethod\n    def _current_date():\n        \"\"\"Get the current date.\n\n        Returns the current timezone-aware date as a string in ISO format.\n        \"\"\"\n        current_dt = timezone.now()\n        current_date = datetime.date(current_dt.year, current_dt.month,\n                                     current_dt.day)\n        return current_date.isoformat()\n\n    @property\n    def _index_for_insert(self):\n        \"\"\"Get the name of the index for inserting docs.\n\n        Returns the name of the index into which new documents should be\n        inserted. If the index belongs to a time series, the index name\n        will include the current date in ISO format.\n        \"\"\"\n        if self._in_time_series:\n            return self._index_name + '-' + self._current_date()\n        else:\n            return self._index_name\n\n    @property\n    def _params_for_insert(self):\n        \"\"\"Create basic parameters for inserting docs.\n\n        Returns a dictionary with a base set of parameters for inserting\n        new documents. These parameters specify the index and doc_type\n        under which new documents should be inserted.\n        \"\"\"\n        return {'index': self._index_for_insert, 'doc_type': self._doc_type}\n\n    @property\n    def _index_for_search(self):\n        \"\"\"Get the index name or pattern for searching docs.\n\n        Returns the name of the index(es) that should be used in document\n        searches. If the Engine represents a time series of indexes,\n        the name will contain wildcards so that all indexes belonging\n        to the time series will be included in a search.\n        \"\"\"\n        if self._in_time_series:\n            return self._index_name + ',' + self._index_name + '-*-*-*'\n        else:\n            return self._index_name\n\n    @property\n    def _params_for_search(self):\n        \"\"\"Create basic parameters for searching docs.\n\n        Returns a dictionary with a base set of parameters for searching\n        documents. These parameters specify the index and doc_type that\n        should be searched.\n        \"\"\"\n        return {'index': self._index_for_search, 'doc_type': self._doc_type}\n\n    def _index_exists(self):\n        \"\"\"Find out if the index already exists.\n\n        Returns a Boolean indicating whether the index containing the\n        Engine's doc_type already exists.\n        \"\"\"\n        return ELASTICSEARCH.indices.exists(self._index_for_insert)\n\n    def _create_index(self):\n        \"\"\"Create an index for inserting docs.\n\n        Creates an Elasticsearch index with the Engine's index name and\n        a mapping defined by the Engine's schema.\n        \"\"\"\n        index = self._index_for_insert\n        mappings = self._create_mapping()\n        params = {'index': index, 'ignore': 400, 'body': mappings}\n        ELASTICSEARCH.indices.create(**params)\n\n    def _create_mapping(self):\n        \"\"\"Create a mapping for the index.\n\n        Returns a dict of properties for mapping the data fields in\n        Elasticsearch.\n        \"\"\"\n        return create_mapping(self._doc_type, self.schema)\n\n    def _filter_by_id(self, doc_ids):\n        \"\"\"Get docs matching one or more ids from multiple indexes.\n\n        Takes a document id or a list of document ids, and returns\n        documents matching the given id(s) from indexes associated with\n        the Engine instance. Used to locate documents across multiple\n        indexes, as in the case of a time series (timestamped indexes).\n        \"\"\"\n        is_list = isinstance(doc_ids, list)\n        if not is_list:\n            doc_ids = [doc_ids]\n\n        params = self._params_for_search\n        query = es_queries.ids_query(doc_ids)\n        params.update({\n            'body': query, '_source': True,\n            'ignore_unavailable': True\n        })\n        results = ELASTICSEARCH.search(**params)\n        formatted_results = es_results.get_source(results)\n        if is_list:\n            return formatted_results\n        elif len(formatted_results) > 0:\n            return formatted_results[0]\n\n    def _find_multiple_ids(self, doc_ids):\n        \"\"\"Get docs matching a list of ids from an index.\n\n        Takes a list of document ids and returns a list of matching\n        documents from the index associated with the Engine.\n        \"\"\"\n        params = self._params_for_search\n        params.update({'body': {'ids': doc_ids}, 'refresh': True})\n        results = ELASTICSEARCH.mget(**params)\n        return es_results.get_found_docs(results)\n\n    def _find_single_id(self, doc_id):\n        \"\"\"Get a doc matching an id from an index.\n\n        Takes a document id and returns the matching document from the\n        index associated with the Engine.\n        \"\"\"\n        params = self._params_for_search\n        query = es_queries.id_query(doc_id)\n        params.update(query)\n        result = ELASTICSEARCH.get(**params)\n        if result['found']:\n            return es_results.get_source_with_id(result)\n\n    def _get_search_results(self, query, source, size=MAX_RESULTS, offset=0):\n        \"\"\"Return the raw search result from the Elasticsearch API.\n\n        Parameters\n        ----------\n        query : dict\n            Query parameters.\n\n        source : |bool| or |list| of |str|\n            |True| or |False| to return the _source field or not, or a\n            list of specific fields to return.\n\n        size : int\n            The maximum number of results to return.\n\n        offset : int\n            The number of results to skip when returning the result set.\n\n        Returns\n        -------\n        dict\n             The raw result from the Elasticsearch API.\n\n        \"\"\"\n        params = self._params_for_search\n\n        params.update({\n            'body': query,\n            '_source': source,\n            'size': size,\n            'from_': offset,\n            'ignore_unavailable': True,\n        })\n\n        return ELASTICSEARCH.search(**params)\n\n    @catch_connection_error\n    @wait_for_status('yellow')\n    def find_by_id(self, doc_ids):\n        \"\"\"Find one or more documents by id.\n\n        Parameters\n        ----------\n        doc_ids : |str| or |list| of |str|\n            A document id or a list of document ids.\n\n        Returns\n        -------\n        |dict|, |list| of |dict|, or |None|\n            Documents corresponding to the given id(s). Returns a list\n            of documents if doc_ids is a list; otherwise returns a\n            single document. If no matches are found, returns `None`.\n\n        \"\"\"\n        if self._in_time_series:\n            return self._filter_by_id(doc_ids)\n        elif isinstance(doc_ids, list):\n            return self._find_multiple_ids(doc_ids) or None\n        else:\n            return self._find_single_id(doc_ids)\n\n    @catch_connection_error\n    @wait_for_status('yellow')\n    def find(self, query, sorter=None, page=1, page_size=PAGE_SIZE):\n        \"\"\"Find documents matching a query.\n\n        Parameters\n        ----------\n        query : |EngineQuery|\n            An |EngineQuery| defining critieria for matching documents\n            in the index or time series.\n\n        sorter : |Sorter| or |None|\n            A |Sorter| defining how results should be ordered.\n\n        page : int\n            The page of results to return.\n\n        page_size : int\n            The number of documents per page of results.\n\n        Returns\n        -------\n        |list| of |dict|\n            A dictionary with keys 'count' and 'results'. The 'count'\n            value is the total number of documents matching the search\n            criteria. The 'results' value is a list of documents from\n            the search result, with the doc ids added to each document.\n\n        \"\"\"\n        offset = self.get_offset(page, page_size)\n        es_query = es_queries.ElasticsearchQuery(query.subqueries,\n                                                 query.joiner)\n        params = es_query.params\n\n        if sorter:\n            elastic_sorter = es_sorter.ElasticsearchSorter(sorter.sort_list)\n            params.update(elastic_sorter.params)\n\n        results = self._get_search_results(\n            params,\n            source=self.field_names,\n            size=page_size,\n            offset=offset\n        )\n        return es_results.get_results_and_count(results)\n\n    @catch_connection_error\n    @wait_for_status('yellow')\n    def filter_ids(self, doc_ids, fields, value):\n        \"\"\"Find the ids of documents that match a value.\n\n        Parameters\n        ----------\n        doc_ids : |list| of |str|\n            The ids of documents to filter.\n\n        fields : |list| of |DataFields|\n            |DataFields| that should be examined for a matching value.\n\n        value : str\n            A value used to find matching documents.\n\n        Returns\n        -------\n        |list| of |str|\n            The subset of ids for documents containing the given `value`\n            in one or more of the specified `fields`.\n\n        \"\"\"\n        query = es_queries.ids_and_value_filter(doc_ids, fields, value)\n        results = self._get_search_results(query, source=False)\n        return es_results.get_doc_ids(results)\n\n    def insert(self, doc):\n        \"\"\"Insert the document into the index.\n\n        Parameters\n        ----------\n        doc : dict\n            A document to insert into the Elasticsearch index.\n\n        Returns\n        -------\n        str\n            The id of the inserted document.\n\n        \"\"\"\n        params = self._params_for_insert\n        params.update({'body': doc, 'refresh': True})\n        if not self._index_exists():\n            self._create_index()\n        doc = ELASTICSEARCH.index(**params)\n        return doc['_id']\n\n    def _remove_by_id_wildcard(self, doc_ids):\n        \"\"\"Remove one or more docs from multiple indexes.\n\n        Takes a document id or a list of document ids and removes the\n        document(s) from the Elasticsearch index(es) associated with the\n        Engine. Used for removing documents from time series indexes.\n        \"\"\"\n        params = self._params_for_search\n        query = es_queries.ids_query(doc_ids)\n        params.update({\n            'body': query,\n            '_source': False,\n            'ignore_unavailable': True\n        })\n        results = ELASTICSEARCH.search(**params)\n\n        for hit in es_results.get_hits(results):\n            params = es_results.get_doc_info(hit)\n            params.update({'refresh': True})\n            ELASTICSEARCH.delete(**params)\n\n    def _remove_by_id_simple(self, doc_ids):\n        \"\"\"Remove one or more docs from an index.\n\n        Takes a document id or a list of document ids and removes the\n        document(s) from the Elasticsearch index associated with the\n        Engine.\n        \"\"\"\n        for doc_id in doc_ids:\n            params = self._params_for_search\n            query = es_queries.id_query(doc_id)\n            params.update(query)\n            ELASTICSEARCH.delete(**params)\n\n    @catch_connection_error\n    @wait_for_status('yellow')\n    def remove_by_id(self, doc_ids):\n        \"\"\"Remove the documents with the given ids.\n\n        Parameters\n        ----------\n        doc_ids : |str| or |list| of |str|\n            An id or list of ids of documents to remove from the index.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        if not isinstance(doc_ids, list):\n            doc_ids = [doc_ids]\n\n        if self._in_time_series:\n            return self._remove_by_id_wildcard(doc_ids)\n        else:\n            return self._remove_by_id_simple(doc_ids)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, 1, null, 1, null, null, 1, null, null, null, null, 1, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, 1, 1, null, 1, 0, null, null, 1, 1, 1, null, null, null, 1, 1, 1, 1, null, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, 1, 1, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, 1, 0, 0, null, 0, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, 1, 1, null, 0, null, 1], "name": "engines/elasticsearch/mapper.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nFunctions for creating Elasticsearch mappings.\n\nThis module provides functions for determining Elasticsearch mappings\nbased on field types.\n\n========================  ===================================\nFunction                  Description\n========================  ===================================\n:func:`~create_mapping`   Get mappings parameter dict.\n:func:`~get_data_type`    Get data type for a field type.\n:func:`~get_index_types`  Classify fields by indexing method.\n========================  ===================================\n\n\"\"\"\n\n# third party\nfrom django.conf import settings\n\n# local\nfrom bottler.datafields.models import DataField\nfrom .client import VERSION\n\n_DATE_KEY = settings.DISTILLERIES['DATE_KEY']\n\n\ndef _get_field_mappings():\n    \"\"\"\n    Returns a dictionary for creating mappings that work with a newer or\n    older version of Elasticsearch.\n    \"\"\"\n    if isinstance(VERSION, str) and VERSION < '5.0':\n        return {\n            'CharField': {\n                'type': 'string',\n                'index': 'not_analyzed'\n            },\n            'ChoiceField': {\n                'type': 'string',\n                'index': 'not_analyzed'\n            },\n            'ListField': {\n                'type': 'string',\n                'index': 'not_analyzed'\n            },\n            'BooleanField': {\n                'type': 'boolean',\n                'index': 'not_analyzed'\n            },\n            'DateTimeField': {\n                'type': 'date',\n                'index': 'not_analyzed',\n                'ignore_malformed': True\n            },\n            'EmailField': {\n                'type': 'string',\n                'index': 'not_analyzed'\n            },\n            'FileField': {\n                'type': 'string',\n                'index': 'not_analyzed'\n            },\n            'FloatField': {\n                'type': 'float',\n                'index': 'not_analyzed'\n            },\n            'IntegerField': {\n                'type': 'integer',\n                'index': 'not_analyzed'\n            },\n            'GenericIPAddressField': {\n                'type': 'string',\n                'index': 'not_analyzed'\n            },\n            'PointField': {\n                'type': 'geo_point',\n                'ignore_malformed': True\n            },\n            'TextField': {\n                'type': 'string',\n                'index': 'analyzed'\n            },\n            'URLField': {\n                'type': 'string',\n                'index': 'not_analyzed'\n            }\n        }\n    else:\n        return {\n            'CharField': {\n                'type': 'keyword',\n            },\n            'ChoiceField': {\n                'type': 'keyword',\n            },\n            'ListField': {\n                'type': 'keyword',\n            },\n            'BooleanField': {\n                'type': 'boolean',\n            },\n            'DateTimeField': {\n                'type': 'date',\n                'ignore_malformed': True\n            },\n            'EmailField': {\n                'type': 'keyword',\n            },\n            'FileField': {\n                'type': 'keyword',\n            },\n            'FloatField': {\n                'type': 'float',\n            },\n            'IntegerField': {\n                'type': 'integer',\n            },\n            'GenericIPAddressField': {\n                'type': 'keyword',\n            },\n            'PointField': {\n                'type': 'geo_point',\n                'ignore_malformed': True\n            },\n            'TextField': {\n                'type': 'text',\n            },\n            'URLField': {\n                'type': 'keyword',\n            }\n        }\n\n\n_MAPPINGS = _get_field_mappings()\n\n\ndef _map_field(mapping, field, properties=None):\n    \"\"\"\n    Takes a mapping dictionary, a field name, and a properties dictionary.\n    If the field is nested (e.g., 'user.name'), returns a nested mapping\n    dictionary.\n    \"\"\"\n    fields = field.split('.', 1)\n\n    if properties is None:\n        properties = {'properties': {}}\n\n    if 'properties' not in properties:\n        properties['properties'] = {}\n\n    # base case: not a nested field\n    if len(fields) == 1:\n        new_map = {fields[0]: mapping}\n        properties['properties'].update(new_map)\n\n    # recursive case: nested field\n    else:\n        if fields[0] in properties['properties']:\n            new_properties = properties['properties'][fields[0]]\n            new_map = _map_field(mapping, fields[1], new_properties)\n            properties['properties'][fields[0]].update(new_map)\n        else:\n            new_map = _map_field(mapping, fields[1])\n            properties['properties'][fields[0]] = new_map\n\n    return properties\n\n\ndef create_mapping(doc_type, fields):\n    \"\"\"Return a mappings parameter dict for an Elasticsearch index.\n\n    Parameters\n    ----------\n    doc_type : str\n        An Elasticsearch doc_type.\n\n    fields : |list| of |dict|\n        List of dictionaries in the form of `{FIELD_NAME_KEY: <field name>,\n        FIELD_TYPE_KEY: <field type>}`.\n\n    Returns\n    -------\n    dict\n        Mappings parameter for a doc_type in an Elasticsearch index.\n\n    \"\"\"\n    default = {'type': 'text'}\n\n    # add mapping for the _saved_date field added to every record\n    fields.append(DataField(field_name=_DATE_KEY, field_type='DateTimeField'))\n\n    properties = {'properties': {}}\n    for field in fields:\n        mapping = _MAPPINGS.get(field.field_type, default)\n        prop = _map_field(mapping, field.field_name, properties)\n        properties.update(prop)\n\n    mappings = {\n        'settings': {\n            'index.mapping.ignore_malformed': True\n        },\n        'mappings': {\n            doc_type: properties\n        }\n    }\n\n    return mappings\n\n\ndef get_data_type(field_type):\n    \"\"\"Return the data type for a particular field type.\n\n    Identifies the Elasticsearch v5.x data type that corresponds to a\n    given Django model field type.\n\n    Parameters\n    -------\n    field_type : str\n        The type of field, e.g. 'CharField'.\n\n    Returns\n    -------\n    str\n        The Elasticsearch data type used to map fields of the given\n        field type.\n\n    \"\"\"\n    data_type = _MAPPINGS[field_type]['type']\n\n    # convert Elasticsearch v2.x string types to corresponding v5.x\n    # 'keyword' or 'text' types, based on whether the field is analyzed\n    if VERSION < '5.0' and data_type == 'string':\n        if _MAPPINGS[field_type]['index'] == 'not_analyzed':\n            return 'keyword'\n        else:\n            return 'text'\n    else:\n        return data_type\n\n\ndef get_index_types(fields):\n    \"\"\"Classify fields as 'text', 'keyword', or 'other'.\n\n    Categorizes |DataFields| according to how they are indexed by\n    Elasticsearch. This is useful for determining how to correctly\n    query the given fields.\n\n    Parameters\n    ----------\n    fields : |list| of |DataFields|\n        The fields to classify.\n\n    Returns\n    -------\n    dict\n        A dictionary with keys 'text', 'keyword', and 'other' mapped to\n        lists of |DataFields| of those types.\n\n    \"\"\"\n    mappings = {\n        'text': [],\n        'keyword': [],\n        'other': []\n    }\n\n    for field in fields:\n        data_type = get_data_type(field.field_type)\n        if data_type in ['text', 'keyword']:\n            mappings[data_type].append(field)\n        else:\n            mappings['other'].append(field)\n\n    return mappings\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 0, null, 1, null, 1, 1, null, 1, 1, null, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, 1, null, 1, 1, 1, 1, null, 1, 1, 1, null, null, null, null, null, null, 1, null, 1, 1, 1, 1, 1, 0, 0, null, 0, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, 1, null, null, null, 1, null, null, 0, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, 1, 1, null, 1, null, 1, 1, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, 1, 1, null, 1, 1, 1, 1, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, 1, null, 1, 1, null, null, 1, null, 1, null, null, null, null, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, 1, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, 1, 1], "name": "engines/elasticsearch/queries.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines classes and helper functions for constructing Elasticsearch queries.\n\n====================================  =========================================\nClass                                 Description\n====================================  =========================================\n:class:`~ElasticsearchQuery`          Create a query for Elasticsearch.\n:class:`~ElasticsearchQueryFieldset`  Format a |QueryFieldset| for\n                                      Elasticsearch.\n====================================  =========================================\n\n====================================  =========================================\nFunction                              Description\n====================================  =========================================\n:func:`~bool_query`                   Create a bool query.\n:func:`~id_query`                     Create a query to find a doc by id.\n:func:`~ids_and_value_filter`         Create a query for docs matching a value.\n:func:`~ids_filter`                   Return a filter for docs using ids.\n:func:`~ids_query`                    Create a query to find docs by id.\n:func:`~ids_selector`                 Create a query for docs by id.\n:func:`~regex_query`                  Create a regexp query.\n====================================  =========================================\n\n\"\"\"\n\n# standard library\nimport json\n\n# local\nfrom engines.queries import EngineQuery, EngineQueryFieldset\nfrom .mapper import get_data_type, get_index_types\n\n# map logical operators to those used by Elasticsearch\n_ELASTIC_QUERY_JOINERS = {\n    'OR': 'should',\n    'AND': 'filter'\n}\n\n\ndef regex_query(field_name, value):\n    \"\"\"Create a regexp query.\n\n    Constructs an Elasticsearch regexp query that will match documents\n    in which the specified value is found somewhere within the content\n    of the given field.\n\n    Parameters\n    ----------\n    field_name : str\n        The name of the field to be queried.\n\n    value : str\n        A value that should appear somewhere in the field's content.\n\n    Returns\n    -------\n    dict\n        An Elasticsearch regexp query.\n\n    \"\"\"\n    return {'regexp': {field_name: '.*\"%s\".*' % value}}\n\n\ndef bool_query(must=None, should=None, must_not=None, filter_expr=None):\n    \"\"\"Create a bool query.\n\n    Parameters\n    ----------\n    must : |dict|, |list| of |dict|, or |None|\n        One or more query clauses that documents must match. For use\n        when 'AND' logic is needed to join query terms.\n\n    should : |list| of |dict| or |None|\n        A list of query clauses for which documents must match at least\n        one. For use when 'OR' logic is needed to join query terms.\n\n    must_not : |dict|, |list| of |dict| or |None|\n        One or more query query clauses which documents must not match.\n        For use when 'NOT' logic is needed.\n\n    filter_expr : |dict| or |None|\n        A query clause that documents must match. For use when 'AND'\n        logic is needed to join query terms. Preferred over the `must`\n        parameter since we're not using relevance scores and it's more\n        efficient.\n\n    Returns\n    -------\n    dict\n        An Elasticsearch bool query.\n\n    \"\"\"\n    query_dict = {}\n\n    if must:\n        query_dict.update({'must': must})\n    else:\n        query_dict.update({'must': {'match_all': {}}})\n\n    if should:\n        query_dict.update({'should': should, 'minimum_should_match': 1})\n\n    if must_not:\n        query_dict.update({'must_not': must_not})\n\n    if filter_expr:\n        query_dict.update(filter_expr)\n\n    return {'bool': query_dict}\n\n\ndef ids_selector(doc_ids):\n    \"\"\"Create a query for documents with the given ids.\n\n    Parameters\n    ----------\n    doc_id : |list| of |str|\n        The document ids to match.\n\n    Returns\n    -------\n    dict\n        A query for documents matching the given `doc_ids`.\n\n    \"\"\"\n    ids = [doc_id for doc_id in doc_ids if doc_id is not None]\n    return {'ids': {'values': ids}}\n\n\ndef ids_filter(doc_ids):\n    \"\"\"Create a filter for documents with the given ids.\n\n    Parameters\n    ----------\n    doc_ids : |list| of |str|\n        The document ids to match.\n\n    Returns\n    -------\n    dict\n        A query for documents matching the given `doc_ids`.\n\n    \"\"\"\n    return {'filter': [ids_selector(doc_ids)]}\n\n\ndef ids_query(doc_ids):\n    \"\"\"Create a query for documents with the given ids.\n\n    Parameters\n    ----------\n    doc_ids : |list| of |str|\n        The document ids to match.\n\n    Returns\n    -------\n    dict\n        A query for documents matching the given `doc_ids`.\n\n    \"\"\"\n    return {'query': ids_selector(doc_ids)}\n\n\ndef id_query(doc_id):\n    \"\"\"Create a query for a document with the given id.\n\n    Parameters\n    ----------\n    doc_id : str\n        The document id to match.\n\n    Returns\n    -------\n    dict\n        A query for a document with the given `doc_id`.\n\n    \"\"\"\n    return {'id': doc_id, 'refresh': True, 'ignore': 404}\n\n\ndef ids_and_value_filter(doc_ids, fields, value):\n    \"\"\"Create a query to find documents that contain the given value.\n\n    Constructs a query that will find documents associated with the set\n    of `doc_ids` that also contain the given `value` somewhere within\n    the content of one of the given `fields`.\n\n    Parameters\n    ----------\n    doc_ids : |list| of |str|\n        The document ids to match.\n\n    fields : |list| of |DataFields|\n        |DataFields| indicating the fields in documents that should be\n        examined for a matching value.\n\n    value : |str|\n        A value used to find matching documents.\n\n    Returns\n    -------\n    list\n        Document ids for which at least one of the specified `fields`\n        contains the given `value`.\n\n    \"\"\"\n    mappings = get_index_types(fields)\n    full_text_fields = mappings['text']\n    exact_text_fields = mappings['keyword']\n\n    exact_text_query = []\n    full_text_query = None\n\n    if exact_text_fields:\n        for field in exact_text_fields:\n            regexp = regex_query(field.field_name, value)\n            exact_text_query.append(regexp)\n\n    if full_text_fields:\n        analyzed_fields = [field.field_name for field in full_text_fields]\n        full_text_query = {\n            'multi_match': {\n                'query': value,\n                'fields': analyzed_fields\n            }\n        }\n\n    id_filter = ids_filter(doc_ids)\n\n    if exact_text_query and full_text_query:\n        should_queries = [full_text_query] + exact_text_query\n        query = bool_query(should=should_queries, filter_expr=id_filter)\n    elif exact_text_query:\n        query = bool_query(should=exact_text_query, filter_expr=id_filter)\n    elif full_text_query:\n        query = bool_query(must=full_text_query, filter_expr=id_filter)\n    else:\n        return None\n        # TODO(LH): raise exception?\n\n    return {'query': query}\n\n\nclass ElasticsearchQueryFieldset(EngineQueryFieldset):\n    \"\"\"Format a |QueryFieldset| for Elasticsearch.\n\n    Parameters\n    ----------\n    fieldset : |QueryFieldset|\n        A |QueryFieldset| providing the basis for a query expression.\n\n    Attributes\n    ----------\n    field_name : str\n        The name of the field being queried.\n\n    field_type : str\n        The type of field being queried (e.g., 'CharField'). Corresponds\n        to a value in |FIELD_TYPE_CHOICES|.\n\n    raw_value : str\n        The `value` from the |QueryFieldset| used to initialize the\n        object instance.\n\n    raw_operator : str\n        The `operator` from the |QueryFieldset| used to initialize the\n        object instance. Corresponds to a value in |OPERATOR_CHOICES|.\n\n    operator : str\n        The engine-specific operator that should be used for building\n        the query expression.\n\n    negate : bool\n        Indicates whether the `operator` should be negated by applying\n        'NOT' logic to the query expression.\n\n    value : |str|, |int|, |float|, |dict|, or |list|\n        The value that should be used in the query expression, to be\n        compared against the value of the field being queried.\n\n    \"\"\"\n\n    QUERY_OPERATORS = {\n        'eq': 'match',                  # equals\n        'in': 'term',                   # list contains value\n        'gt': 'gt',                     # greater than\n        'gte': 'gte',                   # greater than or equal to\n        'lt': 'lt',                     # less than\n        'lte': 'lte',                   # less than or equal to\n        'regex': 'match',               # text contains regex\n        'not:eq': 'not:match',          # does not equal\n        'not:in': 'not:term',           # list does not contain value\n        'not:regex': 'not:match',       # text does not contain regex\n        'not:missing': 'exists',        # is not null\n        'within': 'within'              # point is within polygon\n    }\n    \"\"\"|dict|\n\n    Maps the values in |OPERATOR_CHOICES| to the corresponding query\n    operators in Elasticsearch.\n    \"\"\"\n\n    QUERY_JOINERS = _ELASTIC_QUERY_JOINERS\n    \"\"\"|dict|\n\n    Maps the values in |LOGIC_CHOICES| to the corresponding query\n    operators in Elasticsearch.\n    \"\"\"\n\n    NEGATE_OPERATOR = 'not:'\n    \"\"\"|dict|\n\n    The Engine's equivalent of a 'NOT' operator. Used for negating a\n    |QueryFieldset|.\n    \"\"\"\n\n    @staticmethod\n    def _negate_query(query):\n        \"\"\"Negate a query.\n\n        Takes a dictionary representing a query and applies 'NOT' logic.\n        Returns a dictionary representing the negated query.\n        \"\"\"\n        # return {'not': query}\n        return bool_query(must_not=query)\n\n    def format_value(self):\n        \"\"\"Format a value for a query expression.\n\n        Transforms the `raw_value` attribute into a value that can be\n        used in an Elasticsearch query expression.\n\n        Returns\n        -------\n        |str|, |int|, |float|, |dict|, or |list|\n            A value that can be used in the query expression.\n\n        \"\"\"\n        if self.raw_value is not None:\n            # if string value, convert to lowercase\n            # so it can be compared to indexed terms\n            if get_data_type(self.field_type) in 'text':\n                return self.raw_value.lower()\n\n            # if location search, convert geojson value back to dictionary\n            if self.operator == 'within':\n                return json.loads(self.raw_value)\n\n            # otherwise no special formatting is needed\n            else:\n                return self.raw_value\n\n        else:\n            return ''\n\n    def _default_query(self):\n        \"\"\"Create a generic query.\n\n        Returns a generic field query.\n        \"\"\"\n        return {self.operator: {self.field_name: self.value}}\n\n    def _match_phrase(self):\n        \"\"\"Match value as a phrase.\n\n        Returns a selector for a match_phrase query.\n        \"\"\"\n        return {'match_phrase': {self.field_name: self.value}}\n\n    def _match_term(self):\n        \"\"\"Match value as a term.\n\n        Returns a selector for a term query.\n        \"\"\"\n        return {'match': {self.field_name: self.value}}\n\n    def _exists_query(self):\n        \"\"\"Check if a field exists.\n\n        Returns a selector for an exists query.\n        \"\"\"\n        return {'exists': {'field': self.field_name}}\n\n    def _range_query(self):\n        \"\"\"Create a range query.\n\n        Returns a selector for an open-ended range query (e.g., \"greater\n        than\", \"less than or equal to\", etc.).\n        \"\"\"\n        return {'range': {self.field_name: {self.operator: self.value}}}\n\n    def _regex_query(self):\n        \"\"\"Create a regex query.\n\n        Returns a selector for matching a field using a regular\n        expression.\n        \"\"\"\n        return regex_query(self.field_name, self.value)\n\n    def _contains_query(self):\n        \"\"\"Match value as phrase or fragment.\n\n        Returns a list of filters to capture results for either an exact\n        phrase or a word fragment.\n        \"\"\"\n        regex_filter = [\n            self._match_phrase(),\n            self._regex_query()\n        ]\n        if self.negate:\n            return bool_query(must_not=regex_filter)\n        else:\n            return bool_query(should=regex_filter)\n\n    def _eq_query(self):\n        \"\"\"Match the exact value.\n\n        Returns a selector for examining equality, negated when\n        appropriate. The exact form of the selector depends on whether\n        or not the field is analyzed by Elasticsearch.\n        \"\"\"\n        if get_data_type(self.field_type) == 'text':\n            query = self._match_phrase()\n        else:\n            query = self._match_term()\n\n        if self.negate:\n            query = self._negate_query(query)\n\n        return bool_query(filter_expr={'filter': query})\n\n    def _polygon_filter(self, polygon_feature):\n        \"\"\"Create a polygon filter.\n\n        Takes a GeoJSON polygon feature and returns a polygon filter.\n        \"\"\"\n        geometry = polygon_feature['geometry']\n\n        assert geometry['type'] == 'Polygon', 'Feature is a %s not a Polygon' \\\n            % geometry['type']\n\n        return {\n            'geo_polygon': {\n                self.field_name: {\n                    'points': geometry['coordinates'][0]\n                },\n                # 'validation_method': 'COERCE'\n            }\n        }\n\n    def _geo_query(self):\n        \"\"\"Create a geofilter.\n\n        If the object's `value` attribute represents a feature collection,\n        returns a geofilter based on the feature collection.\n        \"\"\"\n        feature_collection = self.value\n        features = feature_collection['features']\n        if len(features) < 2:\n            return self._polygon_filter(features[0])\n        else:\n            poly_filters = []\n            for feature in features:\n                poly_filter = self._polygon_filter(feature)\n                poly_filters.append(poly_filter)\n            return bool_query(should=poly_filters)\n\n    def _get_query(self):\n        \"\"\"Create a base query prior to negation.\n\n        Returns a base selector for use in an Elasticsearch query,\n        prior to applying any negation.\n        \"\"\"\n        if self.operator == 'exists':\n            return self._exists_query()\n\n        elif self.operator == 'within':\n            return self._geo_query()\n\n        elif self.operator in ['gt', 'gte', 'lt', 'lte']:\n            return self._range_query()\n\n        else:\n            return self._default_query()\n\n    def _get_selector(self):\n        \"\"\"Create a query selector with negation if needed.\n\n        Returns a selector for use in an Elasticsearch query, negated\n        when appropriate.\n        \"\"\"\n        query = self._get_query()\n        if self.negate:\n            return self._negate_query(query)\n        else:\n            return query\n\n    @property\n    def selector(self):\n        \"\"\"Create a query expression.\n\n        Creates a dictionary suitable for use as a selector in an\n        Elasticsearch query.\n\n        Returns\n        -------\n        dict\n            A query expression based on the |QueryFieldset| used to\n            initialize the object instance.\n\n        \"\"\"\n        if 'regex' in self.raw_operator:\n            return self._contains_query()\n\n        elif 'eq' in self.raw_operator:\n            return self._eq_query()\n\n        else:\n            return self._get_selector()\n\n\nclass ElasticsearchQuery(EngineQuery):\n    \"\"\"Create a query for Elasticsearch.\n\n    Defines search parameters for querying the index and document type\n    serviced by an |ElasticsearchEngine| instance. Uses those\n    parameters to format an Elasticsearch query.\n\n    Attributes\n    ----------\n    subqueries : list of QueryFieldsets and/or EngineQueries\n        Any combination of |QueryFieldsets| and child |EngineQueries|\n        to be used in constructing a query. Child |EngineQueries| are\n        used to construct more complex (nested) query expressions.\n\n    joiner : str\n        A logical operator for combining query terms. Corresponds to a\n        value in |LOGIC_CHOICES|.\n\n    \"\"\"\n\n    QUERY_JOINERS = _ELASTIC_QUERY_JOINERS\n    \"\"\"|dict|\n\n    Maps the values in |LOGIC_CHOICES| to the corresponding logical\n    operators in Elasticsearch.\n    \"\"\"\n\n    fieldset_model = ElasticsearchQueryFieldset\n    \"\"\"|type|\n\n    The |EngineQueryFieldset| subclass used to model fieldsets for\n    Elasticsearch.\n    \"\"\"\n\n    @staticmethod\n    def join_subqueries(subqueries, joiner):\n        \"\"\"Return a query expression.\n\n        Parameters\n        ----------\n        fieldsets : |list| of :class:`~ElasticsearchQueryFieldset`\n            :class:`ElasticsearchQueryFieldsets<ElasticsearchQueryFieldset>`\n            for defining a query.\n\n        joiner : str\n            A logical operator specifying how multiple query fieldsets\n            should be combined. Corresponds to a value in |LOGIC_CHOICES|.\n\n        \"\"\"\n        bool_query = {joiner: subqueries}\n\n        if 'should' in bool_query:\n            bool_query.update({'minimum_should_match': 1})\n\n        if 'must' not in bool_query:\n            bool_query.update({'must': {'match_all': {}}})\n\n        return {'bool': bool_query}\n\n    @property\n    def params(self):\n        \"\"\"Return parameters for a query.\n\n        Returns\n        -------\n        dict\n            A query expression based on the parameters of the object\n            instance.\n\n        \"\"\"\n        query = self._get_query(self)\n        return {'query': query}\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, null, null], "name": "engines/elasticsearch/results.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines helper fuctions for formatting Elasticsearch query results.\n\n==============================  =============================================\nFunction                        Description\n==============================  =============================================\n:func:`~get_count`              Get the number of matching docs.\n:func:`~get_doc_ids`            Get the ids of matching docs.\n:func:`~get_doc_info`           Get the index, doc_type, and id of a doc.\n:func:`~get_found_docs`         Get docs from a multi-get request.\n:func:`~get_hits`               Get docs from a search result.\n:func:`~get_results_and_count`  Get docs and doc count from a search result.\n:func:`~get_source`             Get `_source` fields with added `_id` fields.\n:func:`~get_source_with_id`     Get a doc's `_source` field with its `_id`.\n==============================  =============================================\n\n\"\"\"\n\n\ndef get_count(results):\n    \"\"\"Get the number of documents in an Elasticsearch search result.\n\n    Parameters\n    ----------\n    results : dict\n        An Elasticsearch search result.\n\n    Returns\n    -------\n    int\n        The total number of documents matching the search criteria.\n\n    \"\"\"\n    return results['hits']['total']\n\n\ndef get_hits(results):\n    \"\"\"Return a list of documents from an Elasticsearch search result.\n\n    Parameters\n    ----------\n    results : dict\n        An Elasticsearch search result.\n\n    Returns\n    -------\n    |list| of |dict|\n        The list of documents in the search result.\n\n    \"\"\"\n    return results['hits']['hits']\n\n\ndef get_doc_info(result):\n    \"\"\"Get the index, doc_type, and id associated with a document.\n\n    Parameters\n    ----------\n    result : dict\n        A document from an Elasticsearch search result.\n\n    Returns\n    -------\n    dict\n        A dictionary with keys 'index', 'doc_type', and 'id',\n        containing the name of the index in which the document resides,\n        the doc_type of the document, and its id.\n\n    \"\"\"\n    return {\n        'index': result['_index'],\n        'doc_type': result['_type'],\n        'id': result['_id']\n    }\n\n\ndef get_doc_ids(results):\n    \"\"\"Get the ids of documents contained in a search result.\n\n    Parameters\n    ----------\n    results : dict\n        An Elasticsearch search result.\n\n    Returns\n    -------\n    |list| of |str|\n        A list of ids of the documents contained in the search result.\n\n    \"\"\"\n    return [hit['_id'] for hit in get_hits(results)]\n\n\ndef get_source_with_id(result):\n    \"\"\"Return a document's `_source` field with its `_id` added.\n\n    Parameters\n    ----------\n    result : dict\n        A document from a set of Elasticsearch search results.\n\n    Returns\n    -------\n    dict\n        The document's `_source` field updated with the doc's `_id`.\n\n    \"\"\"\n    result['_source'].update({'_id': result['_id']})\n    return result['_source']\n\n\ndef get_source(results):\n    \"\"\"Get the documents contained in a search result.\n\n    Extracts documents from an Elasticsearch search result, adds the\n    document id to each document, and returns the list of documents.\n\n    Parameters\n    ----------\n    results : dict\n        An Elasticsearch search result.\n\n    Returns\n    -------\n    |list| of |dict|\n        The documents from the search result, with the doc ids added.\n\n    \"\"\"\n    return [get_source_with_id(hit) for hit in get_hits(results)]\n\n\ndef get_found_docs(results):\n    \"\"\"Get the documents found through a multi-get request.\n\n    This method weeds out failed matches from an mget result set.\n\n    Parameters\n    ----------\n    results : dict\n         An Elasticsearch mget (find by id) result.\n\n    Returns\n    -------\n    |list| of |dict|\n        The documents found by the mget request, with the doc ids added.\n\n    \"\"\"\n    docs = results['docs']\n    matched_docs = []\n    for doc in docs:\n        if doc.get('found'):\n            formatted_doc = get_source_with_id(doc)\n            matched_docs.append(formatted_doc)\n    return matched_docs\n\n\ndef get_results_and_count(data):\n    \"\"\"Get the documents and document count from a search result.\n\n    Parameters\n    ----------\n    data : dict\n        An Elasticsearch search result.\n\n    Returns\n    -------\n    dict\n        A dictionary with keys 'count' and 'results'. The 'count' value\n        is the total number of documents matching the search criteria.\n        The 'results' value is a list of documents from the search\n        result, with the doc ids added to each document.\n\n    \"\"\"\n    count = get_count(data)\n    results = get_source(data)\n    return {\n        'count': count,\n        'results': results,\n    }\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, null, 1, 1, null, null, null, null, 1, null, null], "name": "engines/elasticsearch/sorter.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Sorter subclass for ordering Elasticsearch documents.\n\n=============================  ====================================\nClass                          Description\n=============================  ====================================\n:class:`~ElasticsearchSorter`  Criteria to sort Elasticsearch docs.\n=============================  ====================================\n\n\"\"\"\n\n# local\nfrom engines.sorter import Sorter\nfrom .mapper import get_data_type\n\n\nclass ElasticsearchSorter(Sorter):\n    \"\"\"Criteria to sort documents by a set of fields.\n\n    Parameters\n    ----------\n    sort_list : |list| of |SortParams|\n        The |SortParams| used to define the overall order of documents.\n\n    \"\"\"\n\n    _SORT_ORDERS = {\n        'ASC': 'asc',\n        'DESC': 'desc'\n    }\n    \"\"\"Map generic sort orders to Elasticsearch sort orders.\"\"\"\n\n    @property\n    def params(self):\n        \"\"\"Format and return parameters to sort documents.\n\n        Returns\n        -------\n        dict\n           Elasticsearch parameters for sorting documents.\n\n        \"\"\"\n        params = []\n        for sort in self.sort_list:\n            data_type = get_data_type(sort.field_type)\n\n            # don't sort fields that are analyzed/tokenized\n            if data_type is not 'text':\n                params.append({\n                    sort.field_name: {\n                        'order': self._SORT_ORDERS[sort.order],\n                    }\n                })\n        return {\n            'sort': params\n        }\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, 1, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1], "name": "engines/engine.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nProvides a base |Engine| class for interacting with data stores.\n\nAn |Engine| performs CRUD operations on a set of documents in a data\nstore, represented by a |Collection|. Essentially, an |Engine| shuttles\ndocuments to and from that |Collection|.\n\n=====================  =================================================\nClass                  Description\n=====================  =================================================\n:class:`~Engine`       Interface for a data store.\n=====================  =================================================\n\n=====================  =================================================\nConstant               Description\n=====================  =================================================\n:const:`~MAX_RESULTS`  Maximum number of results to return for a search.\n=====================  =================================================\n\n\"\"\"\n\n# third party\nfrom django.conf import settings\n\n# local\nfrom cyphon.baseclass import BaseClass\n\nPAGE_SIZE = settings.PAGE_SIZE\n\nMAX_RESULTS = 1000\n\"\"\"|int|\n\nMaximum number of results to return from a query.\n\"\"\"\n\n\nclass Engine(BaseClass):\n    \"\"\"An interface for a data store.\n\n    Base class used to define subclasses for interacting with specific\n    data stores (such as MongoDB or Elasticsearch).\n\n    An Engine performs CRUD operations on a set of documents in a\n    data store that are represented by a |Collection|. The |Collection|\n    can correspond to any one of the following:\n\n        - a table in a relational database\n        - a collection in a NoSQL database\n        - a document type in a search engine index\n\n    Essentially, an Engine shuttles documents to and from a storage\n    location. It can insert or remove documents from that location and\n    fetch query results.\n\n    Parameters\n    ----------\n    collection : |Collection|\n        The |Collection| that determines both the schema and the storage\n        location of the documents to be handled by the Engine instance.\n\n    Attributes\n    ----------\n    warehouse_collection : Collection\n        The |Collection| that defines the storage location of the\n        documents to be handled by the Engine instance.\n\n    schema : `list` of `DataFields`\n        |DataFields| that describe the nature of each field in the\n        document type handled by the Engine.\n\n    \"\"\"\n\n    def __init__(self, collection):\n        \"\"\"Initialize an Engine instance.\"\"\"\n        self.warehouse_collection = collection\n        self.schema = collection.get_schema()\n\n    @property\n    def field_names(self):\n        \"\"\"List the fields in the Engine's schema.\n\n        Returns\n        -------\n        |list| of |str|\n            Field names for fields in the Engine's schema. Nested fields\n            are denoted using dot notation (e.g., \"user.screen_name\").\n\n        \"\"\"\n        return [field.field_name for field in self.schema]\n\n    @staticmethod\n    def get_offset(page, page_size):\n        \"\"\"Get the number of documents to skip when returning results.\n\n        Parameters\n        ----------\n        page : int\n            The page of results to return.\n\n        page_size : int\n            The number of documents per page.\n\n        Returns\n        -------\n        int\n            The number of documents to skip when returning the results.\n\n        \"\"\"\n        return (int(page) - 1) * int(page_size)\n\n    def find_by_id(self, doc_ids):\n        \"\"\"Find one or more documents by id.\n\n        Parameters\n        ----------\n        doc_ids : |str| or |list| of |str|\n            A document id or a list of document ids.\n\n        Returns\n        -------\n        |dict|, |list| of |dict|, or |None|\n            Documents corresponding to the given id(s). Returns a list\n            of documents if doc_ids is a list; otherwise returns a\n            single document. If no matches are found, returns `None`.\n\n        Notes\n        -----\n        This method needs to be implemented in derived classes.\n\n        \"\"\"\n        return self.raise_method_not_implemented()\n\n    def find(self, query, sorter=None, page=1, page_size=PAGE_SIZE):\n        \"\"\"Find documents matching a query.\n\n        Parameters\n        ----------\n        query : |EngineQuery|\n            An |EngineQuery| defining critieria for matching documents\n            in the index or time series.\n\n        sorter : |Sorter| or |None|\n            A |Sorter| defining how results should be ordered.\n\n        page : int\n            The page of results to return.\n\n        page_size : int\n            The number of documents per page of results.\n\n        Returns\n        -------\n        |list| of |dict|\n            Documents matching the query.\n\n        Notes\n        -----\n        This method needs to be implemented in derived classes.\n\n        \"\"\"\n        return self.raise_method_not_implemented()\n\n    def filter_ids(self, doc_ids, fields, value):\n        \"\"\"Find the ids of documents that match a value.\n\n        Parameters\n        ----------\n        doc_ids : |list| of |str|\n            The ids of documents to filter.\n\n        fields : |list| of |DataField|\n            |DataFields| that should be examined for a matching value.\n\n        value : |str|\n            A value used to find matching documents.\n\n        Returns\n        -------\n        |list| of |str|\n            The subset of ids for documents containing the given `value`\n            in one or more of the specified `fields`.\n\n        Notes\n        -----\n        This method needs to be implemented in derived classes.\n\n        \"\"\"\n        return self.raise_method_not_implemented()\n\n    def insert(self, doc):\n        \"\"\"Insert the document into the data store.\n\n        Parameters\n        ----------\n        doc : dict\n            A document to insert in the data store.\n\n        Returns\n        -------\n        str\n            The id of the inserted document.\n\n        Notes\n        -----\n        This method needs to be implemented in derived classes.\n\n        \"\"\"\n        return self.raise_method_not_implemented()\n\n    def remove_by_id(self, doc_ids):\n        \"\"\"Remove the documents with the given ids.\n\n        Parameters\n        ----------\n        doc_ids : |str| or |list| of |str|\n            An id or list of ids of documents to remove from the data\n            store.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This method needs to be implemented in derived classes.\n\n        \"\"\"\n        return self.raise_method_not_implemented()\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "engines/mongodb/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, null, 1, null, null, null], "name": "engines/mongodb/client.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCreates a MongoDB client instance for use in other modules.\n\n========================  ===========================\nConstant                  Description\n========================  ===========================\n:const:`~MONGODB_CLIENT`  MongoDB client.\n:const:`~TIMEOUT`         Request timeout in seconds.\n========================  ===========================\n\n\"\"\"\n\n# third party\nfrom django.conf import settings\nimport pymongo\n\n_MONGODB_SETTINGS = settings.MONGODB\n\nTIMEOUT = _MONGODB_SETTINGS['TIMEOUT']\n\"\"\"|int|\n\nRequest timeout in seconds.\n\"\"\"\n\nMONGODB_CLIENT = pymongo.MongoClient(_MONGODB_SETTINGS['HOST'],\n                                     serverSelectionTimeoutMS=TIMEOUT)\n\"\"\":class:`~pymongo.MongoClient`\n\nClient for a MongoDB instance.\n\"\"\"\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, 1, 1, 1, null, null, 1, 1, 1, 1, 1, 1, null, 1, null, 1, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, 1, 0, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, 1, null, 1, 1, 1, null, null, 1, null, 1, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, null, 1, 1, null, 1, 1, 1, 1, 1, 1, null, null, 1, null, null, 1, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, null, 1, 1, null, null, 1, null, null, null, null, null, null, 1, 1, 0, null, 1, null, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, 1, null, 1, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, null, 1, null, 1, null, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, 1], "name": "engines/mongodb/engine.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a MongoDB Engine subclass and related decorators.\n\n======================================  ======================================\nClass                                   Description\n======================================  ======================================\n:class:`~MongoDbEngine`                 Interface for a database collection.\n======================================  ======================================\n\n======================================  ======================================\nConstant                                Description\n======================================  ======================================\n:const:`~ENGINE_CLASS`                  Name of module's Engine subclass.\n:const:`~MULTIPLE_FIELD_NAME_MAPPINGS`  Whether a field can have >1 data type.\n:const:`~TIME_SERIES_ENABLED`           Whether time-series are supported.\n======================================  ======================================\n\n======================================  ======================================\nDecorator                               Description\n======================================  ======================================\n:func:`~catch_timeout_error`            Catch ServerSelectionTimeoutErrors.\n======================================  ======================================\n\n\"\"\"\n\n# standard library\nfrom functools import wraps\nimport logging\n\n# third party\nfrom bson import ObjectId\nfrom django.conf import settings\nimport pymongo\n\n# local\nfrom engines.engine import Engine, MAX_RESULTS, PAGE_SIZE\nfrom engines.mongodb import queries as mongodb_queries\nfrom engines.mongodb import sorter as mongodb_sorter\nfrom engines.mongodb import results as mongodb_results\nfrom utils.parserutils import parserutils\nfrom .client import MONGODB_CLIENT\n\n_DISTILLERY_SETTINGS = settings.DISTILLERIES\n\n_LOGGER = logging.getLogger(__name__)\n\n\nENGINE_CLASS = 'MongoDbEngine'\n\"\"\"|str|\n\nThe name of the Engine subclass defined in this module.\n\"\"\"\n\n\nMULTIPLE_FIELD_NAME_MAPPINGS = True\n\"\"\"|bool|\n\nWhether the Engine allows fields with the same name to be mapped to\ndifferent data types in the same database.\n\"\"\"\n\n\nTIME_SERIES_ENABLED = False\n\"\"\"|bool|\n\nWhether this Engine can store data in a time series, for example, by\ncreating timestamped collections (e.g. 'logstash-%Y-%m-%d').\n\"\"\"\n\n\ndef catch_timeout_error(func):\n    \"\"\"Catch and log :exc:`~pymongo.errors.ServerSelectionTimeoutError`.\n\n    Decorator for functions that require a MongoDB connection.\n    If a MongoDB request times out, catches and logs the error.\n\n    Parameters\n    ----------\n    func : function\n        The function to modify.\n\n    Returns\n    -------\n    function\n        The modified function.\n\n    \"\"\"\n    @wraps(func)  # preserve name and docstring of wrapped function\n    def _decorator(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except pymongo.errors.ServerSelectionTimeoutError:\n            _LOGGER.error('Cannot connect to MongoDB')\n    return _decorator\n\n\nclass MongoDbEngine(Engine):\n    \"\"\"An interface for a MongoDB database collection.\n\n    Provides basic CRUD operations for a particular collection\n    within a particular MongoDB database.\n\n    The database and collection are determined by the |Collection|\n    used to initialize the Engine instance. The schema is based on\n    the |Container| associated with that |Collection|.\n\n    Parameters\n    ----------\n    collection : |Collection|\n        The |Collection| that defines the database and collection of\n        the documents to be handled by the Engine. This is also used\n        to create a text index for the database collection.\n\n    Attributes\n    ----------\n    warehouse_collection : Collection\n        The |Collection| that defines the database and collection of\n        the documents to be handled by the Engine.\n\n    schema : `list` of `DataFields`\n        |DataFields| that describe the nature of each field in the\n        document type handled by the Engine. Used to create a text index.\n\n\n    \"\"\"\n\n    TEXT_INDEXES = ('CharField', 'ListField')\n\n    @catch_timeout_error\n    def __init__(self, collection):\n        \"\"\"Initialize a MongoDbEngine instance.\n\n        Creates a MongoDB collection with a text index if one does not\n        already exist.\n        \"\"\"\n        super(MongoDbEngine, self).__init__(collection)\n\n        self._db_name = self.warehouse_collection.get_warehouse_name()\n        self._collection_name = self.warehouse_collection.name\n        self._collection = MONGODB_CLIENT[self._db_name][self._collection_name]\n\n        # unique index on _raw_data keys to prevent duplicate docs\n        self._create_unique_index()\n\n        if self.schema:\n            self._create_text_index(self.schema)\n\n    def __str__(self):\n        \"\"\"Get a string representation of the Engine instance.\n\n        Returns a printable string showing the database and collection.\n        \"\"\"\n        return '%s.%s' % (self._db_name, self._collection_name)\n\n    def _create_text_index(self, fields=None):\n        \"\"\"Create a text index for the database collection.\n\n        Takes a list of fields and creates a text index based on the\n        Engine's schema, if it has one. Otherwise, creates a text index\n        for any field that contains string content.\n        \"\"\"\n        collection = self._collection\n        index_name = 'TextIndex'\n\n        if fields:\n            index = []\n            for field in self.schema:\n                if field.field_type in self.TEXT_INDEXES:\n                    index.append((field.field_name, pymongo.TEXT))\n            return collection.create_index(index, background=True,\n                                           name=index_name)\n        else:\n            return collection.create_index([('$**', pymongo.TEXT)],\n                                           name=index_name)\n\n    @catch_timeout_error\n    def _create_unique_index(self):\n        \"\"\"Create an index based on raw data reference fields.\n\n        Creates a compound index on the fields that contain the location\n        of the raw data from which a document was derived. This prevents\n        duplicate documents from being saved.\n        \"\"\"\n        data_key = _DISTILLERY_SETTINGS['RAW_DATA_KEY']\n\n        fields = [\n            'BACKEND_KEY',\n            'WAREHOUSE_KEY',\n            'COLLECTION_KEY',\n            'DOC_ID_KEY'\n        ]\n        keys = ['%s.%s' % (data_key, _DISTILLERY_SETTINGS[field])\n                for field in fields]\n        formatted_keys = [(key, pymongo.ASCENDING) for key in keys]\n        return self._collection.create_index(formatted_keys, unique=True,\n                                             sparse=True)\n\n    @staticmethod\n    def _restore_object_id(doc_id):\n        \"\"\"Convert a string to an ObjectId.\n\n        Takes a string representing an ObjectId and returns it as an\n        ObjectID instance.\n        \"\"\"\n        if isinstance(doc_id, str):\n            if 'ObjectId' in doc_id:\n                return parserutils.restore_type_from_str(doc_id)\n            else:\n                return ObjectId(doc_id)\n        else:\n            return doc_id\n\n    def _restore_object_ids(self, doc_ids):\n        \"\"\"Convert one or more strings to ObjectIds.\n\n        Takes a string representing an ObjectId or a list of strings\n        representing ObjectIds. Returns the string(s) as ObjectId(s).\n        \"\"\"\n        if isinstance(doc_ids, list):\n            return [self._restore_object_id(doc_id) for doc_id in doc_ids]\n        else:\n            return self._restore_object_id(doc_ids)\n\n    def _get_search_results(self, query, projection=None, sorter=None,\n                            page=1, page_size=MAX_RESULTS):\n        \"\"\"Find matching documents.\n\n        Parameters\n        ----------\n        query : dict\n            Search parameters.\n\n        projection : |list| of |str| or None\n            The fields to return from matching documents.\n\n        sorter : |Sorter| or |None|\n            A |Sorter| defining how results should be ordered.\n\n        page : int\n            The page of results to return.\n\n        page_size : int\n            The number of documents per page.\n\n        Returns\n        -------\n        |list| of |dict|\n            Documents matching the query.\n\n        \"\"\"\n        offset = (page - 1) * page_size\n        query_args = [query]\n\n        if projection:\n            query_args.append(projection)\n\n        cursor = self._collection.find(*query_args)\n\n        if sorter:\n            m_sorter = mongodb_sorter.MongoDbSorter(sorter.sort_list)\n            cursor = cursor.sort(m_sorter.params)\n\n        return cursor.skip(offset).limit(page_size)\n\n    def _find_multiple_ids(self, doc_ids):\n        \"\"\"Find documents by their ids.\n\n        Takes a list of hexadecimal document id strings and returns\n        the corresponding documents.\n        \"\"\"\n        id_filter = mongodb_queries.ids_filter(doc_ids)\n        docs = self._get_search_results(id_filter)\n        return mongodb_results.get_results(docs)\n\n    def _find_single_id(self, doc_id):\n        \"\"\"Find a document by its id.\n\n        Takes a hexadecimal document id string and returns the\n        corresponding document.\n        \"\"\"\n        id_filter = mongodb_queries.id_query(doc_id)\n        doc = self._collection.find_one(id_filter)\n        return mongodb_results.get_results(doc)\n\n    @catch_timeout_error\n    def find_by_id(self, doc_ids):\n        \"\"\"Find one or more documents by id.\n\n        Parameters\n        ----------\n        doc_ids : |str| or |list| of |str|\n            A hexadecimanl document id or a list of ids.\n\n        Returns\n        -------\n        |dict|, |list| of |dict|, or |None|\n            Documents corresponding to the given id(s). Returns a list\n            of documents if doc_ids is a list; otherwise returns a\n            single document. If no matches are found, returns `None`.\n\n        \"\"\"\n        obj_ids = self._restore_object_ids(doc_ids)\n\n        if isinstance(obj_ids, list):\n            data = self._find_multiple_ids(obj_ids)\n        else:\n            data = self._find_single_id(obj_ids)\n\n        return data or None\n\n    @catch_timeout_error\n    def find(self, query, sorter=None, page=1, page_size=PAGE_SIZE):\n        \"\"\"Find documents matching a query.\n\n        Parameters\n        ----------\n        query : |EngineQuery|\n            An |EngineQuery| defining critieria for matching documents.\n\n        sorter : |Sorter| or |None|\n            A |Sorter| defining how results should be ordered.\n\n        page : int\n            The page of results to return.\n\n        page_size : int\n            The number of documents per page of results.\n\n        Returns\n        -------\n        |list| of |dict|\n            A dictionary with keys 'count' and 'results'. The 'count'\n            value is the total number of documents matching the search\n            criteria. The 'results' value is a list of documents from\n            the search result, with the doc ids added to each document.\n\n        \"\"\"\n        query = mongodb_queries.MongoDbQuery(query.subqueries, query.joiner)\n        projection = self.field_names\n        docs = self._get_search_results(query.params, projection, sorter,\n                                        page, page_size)\n        return mongodb_results.get_results_and_count(docs)\n\n    @catch_timeout_error\n    def filter_ids(self, doc_ids, fields, value):\n        \"\"\"Find the ids of documents that match a value.\n\n        Parameters\n        ----------\n        doc_ids : |list| of |str|\n            Hexadecimal ids of documents to filter.\n\n        fields : |list| of |DataField|\n            |DataFields| that should be examined for a matching value.\n\n        value : str\n            A value used to find matching documents.\n\n        Returns\n        -------\n        |list| of |str|\n            The subset of hexadecimal ids for documents containing the\n            given `value` in one or more of the specified `fields`.\n\n        \"\"\"\n        obj_ids = self._restore_object_ids(doc_ids)\n        query = mongodb_queries.ids_and_value_filter(obj_ids, fields, value)\n        projection = {}  # only return ObjectIds\n        results = self._get_search_results(query, projection)\n        return mongodb_results.get_doc_ids(results)\n\n    def insert(self, doc):\n        \"\"\"Insert the document into the collection.\n\n        Parameters\n        ----------\n        doc : dict\n            A document to insert into the MongoDB collection.\n\n        Returns\n        -------\n        str\n            The hexadecimal id of the inserted document.\n\n        Notes\n        ------\n        If a document with the same key already exists, catches the\n        :class:`~pymongo.errors.DuplicateKeyError` and returns the id\n        of the original document.\n\n        \"\"\"\n        try:\n            inserted_result = self._collection.insert_one(doc)\n            obj_id = inserted_result.inserted_id\n\n        except pymongo.errors.DuplicateKeyError as error:\n            errmsg = error.details['errmsg']\n            key_val = parserutils.get_dup_key_val(errmsg)\n            dup = self._collection.find_one(key_val)\n            obj_id = dup['_id']\n\n        return str(obj_id)\n\n    def remove_by_id(self, doc_ids):\n        \"\"\"Remove the documents with the given ids.\n\n        Parameters\n        ----------\n        doc_ids : |str| or |list| of |str|\n            A hexadecimal id or list of ids of documents to remove\n            from the collection.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        doc_ids = self._restore_object_ids(doc_ids)\n        if isinstance(doc_ids, list):\n            id_filter = mongodb_queries.ids_filter(doc_ids)\n            return self._collection.delete_many(id_filter)\n        else:\n            id_filter = mongodb_queries.id_query(doc_ids)\n            return self._collection.delete_one(id_filter)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, null, 1, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, 1, null, null, null, null], "name": "engines/mongodb/queries.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines classes and helper functions for constructing MongoDB queries.\n\n====================================  =========================================\nClass                                 Description\n====================================  =========================================\n:class:`~MongoDbQuery`                Create a query for MongoDB.\n:class:`~MongoDbQueryFieldset`        Format a |QueryFieldset| for MongoDB.\n====================================  =========================================\n\n====================================  =========================================\nFunction                              Description\n====================================  =========================================\n:func:`~id_query`                     Create a query to find a doc by id.\n:func:`~ids_and_value_filter`         Create a query for docs matching a value.\n:func:`~ids_filter`                   Create a filter for docs using ids.\n:func:`~regex_query`                  Create a regex query.\n====================================  =========================================\n\n\"\"\"\n\n# standard library\nimport json\nimport re\n\n# local\nfrom engines.queries import EngineQueryFieldset, EngineQuery\nfrom utils.parserutils.parserutils import restore_type\n\n# map logical operators to those used by MongoDB\n_MONGODB_QUERY_JOINERS = {\n    'OR': '$or',\n    'AND': '$and'\n}\n\n\ndef regex_query(field_name, value):\n    \"\"\"Create a regex query.\n\n    Constructs a MongoDB regex query that will match documents in which\n    the specified value is found somewhere within the content of the\n    given field.\n\n    Parameters\n    ----------\n    field_name : str\n        The name of the field to be queried.\n\n    value : str\n        A value that should appear somewhere in the field's content.\n\n    Returns\n    -------\n    dict\n        A MongoDB regexp query.\n\n    \"\"\"\n    return {field_name: {'$regex': value, '$options': 'i'}}\n\n\ndef ids_filter(doc_ids):\n    \"\"\"Create a filter for documents with the given ids.\n\n    Parameters\n    ----------\n    doc_id : |list| of |ObjectIds|\n        The document ids to match.\n\n    Returns\n    -------\n    dict\n        A query for documents matching the given `doc_ids`.\n\n    \"\"\"\n    return {'_id': {'$in': doc_ids}}\n\n\ndef id_query(doc_id):\n    \"\"\"Create a query for a document with the given id.\n\n    Parameters\n    ----------\n    doc_id : |ObjectId|\n        The document id to match.\n\n    Returns\n    -------\n    dict\n        A query for a document with the given `doc_id`.\n\n    \"\"\"\n    return {'_id': doc_id}\n\n\ndef ids_and_value_filter(obj_ids, fields, value):\n    \"\"\"Create a query to find documents that contain the given value.\n\n    Constructs a query that will find documents associated with the set\n    of `doc_ids` that also contain the given `value` somewhere within\n    the content of one of the given `fields`.\n\n    Parameters\n    ----------\n    doc_ids : |list| of |str|\n        The document ids to match.\n\n    fields : |list| of |DataFields|\n        |DataFields| indicating the fields in documents that should be\n        examined for a matching value.\n\n    value : |str|\n        A value used to find matching documents.\n\n    Returns\n    -------\n    list\n        Document ids for which at least one of the specified `fields`\n        contains the given `value`.\n\n    \"\"\"\n    query = ids_filter(obj_ids)\n    regex_q = [regex_query(field.field_name, value) for field in fields]\n    query.update({_MONGODB_QUERY_JOINERS['OR']: regex_q})\n    return query\n\n\nclass MongoDbQueryFieldset(EngineQueryFieldset):\n    \"\"\"Format a |QueryFieldset| for MongoDB.\n\n    Parameters\n    ----------\n    fieldset : |QueryFieldset|\n        A |QueryFieldset| providing the basis for a query expression.\n\n    Attributes\n    ----------\n    field_name : str\n        The name of the field being queried.\n\n    field_type : str\n        The type of field being queried (e.g., 'CharField'). Corresponds\n        to a value in |FIELD_TYPE_CHOICES|.\n\n    raw_value : str\n        The `value` from the |QueryFieldset| used to initialize the\n        object instance.\n\n    raw_operator : str\n        The `operator` from the |QueryFieldset| used to initialize the\n        object instance. Corresponds to a value in |OPERATOR_CHOICES|.\n\n    operator : str\n        The engine-specific operator that should be used for building\n        the query expression.\n\n    negate : bool\n        Indicates whether the `operator` should be negated by applying\n        'NOT' logic to the query expression.\n\n    value : |str|, |int|, |float|, |dict|, or |list|\n        The value that should be used in the query expression, to be\n        compared against the value of the field being queried.\n\n    \"\"\"\n\n    QUERY_OPERATORS = {\n        'eq': '$eq',                    # equals\n        'in': '$in',                    # list contains value\n        'gt': '$gt',                    # greater than\n        'gte': '$gte',                  # greater than or equal to\n        'lt': '$lt',                    # less than\n        'lte': '$lte',                  # less than or equal to\n        'regex': '$regex',              # text contains regex\n        'not:eq': '$ne',                # does not equal\n        'not:in': '$nin',               # list does not contain value\n        'not:regex': '$not:$regex',     # text does not contain regex\n        'not:missing': '$ne:None',      # is not null\n        'within': '$geoWithin'          # within polygon(s)\n    }\n    \"\"\"|dict|\n\n    Maps the values in |OPERATOR_CHOICES| to the corresponding\n    query operators in MongoDB.\n    \"\"\"\n\n    QUERY_JOINERS = _MONGODB_QUERY_JOINERS\n    \"\"\"|dict|\n\n    Maps the values in |LOGIC_CHOICES| to the corresponding query\n    operators in MongoDB.\n    \"\"\"\n\n    NEGATE_OPERATOR = '$not:'\n    \"\"\"|dict|\n\n    The Engine's equivalent of a 'NOT' operator. Used for negating a\n    |QueryFieldset|.\n    \"\"\"\n\n    def format_value(self):\n        \"\"\"Format a value for a query expression.\n\n        Transforms the `raw_value` attribute into a value that can be\n        used in a MongoDB query expression.\n\n        Returns\n        -------\n        |str|, |int|, |float|, |dict|, or |list|\n            A value that can be used in the query expression.\n\n        \"\"\"\n        value = restore_type(self.field_type, self.raw_value)\n        if self.operator == '$regex':\n            return re.compile(value, re.IGNORECASE)\n        elif self.operator == '$geoWithin':\n            return json.loads(value)\n        elif self.operator in ['$in', '$nin']:\n            return [value]  # MongoDB requires array here\n        else:\n            return value\n\n    def _polygon_filter(self, polygon_feature):\n        \"\"\"Create a polygon filter.\n\n        Takes a GeoJSON polygon or multipolygon feature and returns\n        a $geoWithin filter for that field.\n        \"\"\"\n        geometry = polygon_feature['geometry']\n\n        assert geometry['type'] in ['Polygon', 'MuliPolygon'], \\\n            'Feature is a %s not a Polygon or MuiltPolygon' % geometry['type']\n        return {\n            self.field_name: {\n                '$geoWithin': {\n                    '$geometry': polygon_feature['geometry']\n                }\n            }\n        }\n\n    def _regex_query(self):\n        \"\"\"Create a regex query.\n\n        Returns a selector for matching a field using a regular\n        expression.\n        \"\"\"\n        if self.negate:\n            return {self.field_name: {'$not': self.value}}\n        else:\n            return regex_query(self.field_name, self.value)\n\n    def _not_null_query(self):\n        \"\"\"Create a query for a non-null value.\n\n        Returns a query that matches documents in which a field\n        is not null.\n        \"\"\"\n        return {self.field_name: {'$ne': None}}\n\n    def _default_query(self):\n        \"\"\"Create a generic query.\n\n        Returns a generic field query.\n        \"\"\"\n        return {self.field_name: {self.operator: self.value}}\n\n    @property\n    def selector(self):\n        \"\"\"Create a query expression.\n\n        Creates a dictionary suitable for use as a selector in a\n        MongoDB query.\n\n        Returns\n        -------\n        dict\n            A query expression based on the |QueryFieldset| used to\n            initialize the object instance.\n\n        \"\"\"\n        query_functions = {\n            '$ne:None': self._not_null_query,\n            '$geoWithin': self._geo_query,\n            '$regex': self._regex_query\n        }\n        query_function = query_functions.get(self.operator, self._default_query)\n        return query_function()\n\n\nclass MongoDbQuery(EngineQuery):\n    \"\"\"Create a query for MongoDB.\n\n    Defines search parameters for querying the database and collection\n    serviced by a |MongoDBEngine| instance. Uses those parameters to\n    format a MongoDB query.\n\n    Attributes\n    ----------\n    subqueries : list of QueryFieldsets and/or EngineQueries\n        Any combination of |QueryFieldsets| and child |EngineQueries|\n        to be used in constructing a query. Child |EngineQueries| are\n        used to construct more complex (nested) query expressions.\n\n    joiner : str\n        A logical operator for combining query terms. Corresponds to a\n        value in |LOGIC_CHOICES|.\n\n    \"\"\"\n\n    QUERY_JOINERS = _MONGODB_QUERY_JOINERS\n    \"\"\"|dict|\n\n    Maps the values in |LOGIC_CHOICES| to the corresponding logical\n    operators in MongoDB.\n    \"\"\"\n\n    fieldset_model = MongoDbQueryFieldset\n    \"\"\"|type|\n\n    The |EngineQueryFieldset| subclass used to model fieldsets for\n    MongoDB.\n    \"\"\"\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, 1, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1], "name": "engines/mongodb/results.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines helper fuctions for formatting MongoDB query results.\n\n==============================  ============================================\nFunction                        Description\n==============================  ============================================\n:func:`~get_count`              Get the number of matching docs.\n:func:`~get_doc_ids`            Get the ids of matching docs.\n:func:`~get_results`            Get docs from a search result.\n:func:`~get_results_and_count`  Get docs and doc count from a search result.\n==============================  ============================================\n\n\"\"\"\n\n# third party\nfrom pymongo.cursor import Cursor\n\n\ndef _convert_obj_ids_to_strings(data):\n    \"\"\"Convert ObjectIds to hexadecimal strings.\n\n    Takes a dictionary or a list of dictionaries of MongoDB BSON\n    documents. Transforms their ObjectIds into strings so the documents\n    are JSON serializable and the doc ids are easily accessed.\n    \"\"\"\n    if isinstance(data, list):\n        for doc in data:\n            doc['_id'] = str(doc['_id'])\n    elif isinstance(data, dict):\n        data['_id'] = str(data['_id'])\n\n    return data\n\n\ndef get_count(data):\n    \"\"\"Get the number of documents in a MongoDB search result.\n\n    Parameters\n    ----------\n    data : `~pymongo.cursor.Cursor`\n        A MongoDB search result.\n\n    Returns\n    -------\n    int\n        The total number of documents matching the search criteria.\n\n    \"\"\"\n    if isinstance(data, Cursor):\n        return data.count()\n\n\ndef get_results(data):\n    \"\"\"Get documents from a MongoDB search result.\n\n    Transforms MongoDB BSON documents into JSON serializable documents.\n    This process converts the ObjectIds into hexadecimal strings.\n\n    Parameters\n    ----------\n    data : `~pymongo.cursor.Cursor`\n        A MongoDB search result.\n\n    Returns\n    -------\n    |list| of |dict|\n        A list of JSON serializable documents.\n\n    \"\"\"\n    if isinstance(data, Cursor):\n        data = list(data)\n    return _convert_obj_ids_to_strings(data)\n\n\ndef get_results_and_count(data):\n    \"\"\"Get the documents and document count from a search result.\n\n    Parameters\n    ----------\n    data : `~pymongo.cursor.Cursor`\n        A MongoDB search result.\n\n    Returns\n    -------\n    dict\n        A dictionary with keys 'count' and 'results'. The 'count' value\n        is the total number of documents matching the search criteria.\n        The 'results' value is a list of documents from the search\n        result, with the ObjectIds converted to hexadecimal strings.\n\n    \"\"\"\n    count = get_count(data)\n    results = get_results(data)\n    return {\n        'count': count,\n        'results': results,\n    }\n\n\ndef get_doc_ids(results):\n    \"\"\"Get the ids of documents contained in a MongoDB search result.\n\n    Parameters\n    ----------\n    results : `~pymongo.cursor.Cursor`\n        A MongoDB search result.\n\n    Returns\n    -------\n    |list| of |str|\n        Hexadecimal ids of documents contained in the search result.\n\n    \"\"\"\n    docs = get_results(results)\n    return [doc['_id'] for doc in docs]\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, 1, null], "name": "engines/mongodb/sorter.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Sorter subclass for ordering MongoDB documents.\n\n=======================  ==============================\nClass                    Description\n=======================  ==============================\n:class:`~MongoDbSorter`  Criteria to sort MongoDB docs.\n=======================  ==============================\n\n\"\"\"\n\n# third party\nimport pymongo\n\n# local\nfrom engines.sorter import Sorter\n\n\nclass MongoDbSorter(Sorter):\n    \"\"\"Criteria to sort documents by a set of fields.\n\n    Parameters\n    ----------\n    sort_list : |list| of |SortParams|\n        The |SortParams| used to define the overall order of documents.\n\n    \"\"\"\n\n    _SORT_ORDERS = {\n        'ASC': pymongo.ASCENDING,\n        'DESC': pymongo.DESCENDING\n    }\n    \"\"\"Map generic sort orders to MongoDB sort orders.\"\"\"\n\n    @property\n    def params(self):\n        \"\"\"Format and return parameters to sort documents.\n\n        Returns\n        -------\n        dict\n           MongoDB parameters for sorting documents.\n\n        \"\"\"\n        return [(sort.field_name, self._SORT_ORDERS[sort.order])\n                for sort in self.sort_list]\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, 1, 1, null, 1, 1, 1, 1, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 0, 0, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 0, 0, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 0, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, 1, null, null, null, null, null, null, null, 0, null, 1, null, null, null, null, null, 1, 1, 1, 1, null, 1, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, null, 1, null, null, null, null, null, null, 1, 0, null, 1, null, 1, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, null, null, 1, null, 1, null, null, 1, 1, 1, null, null, 1, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 0, 0, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, 1], "name": "engines/queries.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines base classes for constructing queries.\n\n=============================  ==========================================\nClass                          Description\n=============================  ==========================================\n:class:`~EngineQuery`          Create a query for a data store.\n:class:`~EngineQueryFieldset`  Format a |QueryFieldset| for a data store.\n=============================  ==========================================\n\n\"\"\"\n\n# local\nfrom cyphon.baseclass import BaseClass\nfrom cyphon.fieldsets import QueryFieldset\n\n# map logical operators to those used by the data store\n_ENGINE_QUERY_JOINERS = {\n    'OR': 'OR',\n    'AND': 'AND'\n}\n\n\nclass EngineQueryFieldset(BaseClass):\n    \"\"\"\n    Format a |QueryFieldset| for a particular data store.\n\n    Parameters\n    ----------\n    fieldset : |QueryFieldset|\n        A |QueryFieldset| providing the basis for a query expression.\n\n    Attributes\n    ----------\n    field_name : str\n        The name of the field being queried.\n\n    field_type : str\n        The type of field being queried (e.g., \"CharField\"). Corresponds\n        to a value in |FIELD_TYPE_CHOICES|.\n\n    raw_value : str\n        The `value` from the |QueryFieldset| used to initialize the\n        object instance.\n\n    raw_operator : str\n        The `operator` from the |QueryFieldset| used to initialize the\n        object instance. Corresponds to a value in |OPERATOR_CHOICES|.\n\n    operator : str\n        The engine-specific operator that should be used for building\n        the query expression.\n\n    negate : bool\n        Indicates whether the `operator` should be negated by applying\n        'NOT' logic to the query expression.\n\n    value : `str`, `int`, `float`, `dict`, or `list`\n        The value that should be used in the query expression, to be\n        compared against the value of the field being queried.\n\n    \"\"\"\n\n    QUERY_OPERATORS = {\n        'eq': NotImplemented,            # equals\n        'in': NotImplemented,            # list contains value\n        'gt': NotImplemented,            # greater than\n        'gte': NotImplemented,           # greater than or equal to\n        'lt': NotImplemented,            # less than\n        'lte': NotImplemented,           # less than or equal to\n        'regex': NotImplemented,         # text contains regex\n        'not:eq': NotImplemented,        # does not equal\n        'not:in': NotImplemented,        # list does not contain value\n        'not:regex': NotImplemented,     # text does not contain regex\n        'not:missing': NotImplemented,   # is not null\n        'within': NotImplemented         # within polygon(s)\n    }\n    \"\"\"|dict|\n\n    Maps the values in |OPERATOR_CHOICES| to the corresponding query\n    operators for the Engine.\n\n    Notes\n    -----\n    Must be overridden in derived classes.\n\n    \"\"\"\n\n    QUERY_JOINERS = _ENGINE_QUERY_JOINERS\n    \"\"\"`dict`\n\n    Maps the values in |LOGIC_CHOICES| to the corresponding logical\n    operators for the Engine.\n\n    Notes\n    -----\n    Must be overridden in derived classes.\n\n    \"\"\"\n\n    NEGATE_OPERATOR = NotImplemented\n    \"\"\"`str`\n\n    The Engine's equivalent of a 'NOT' operator. Used for negating a\n    |QueryFieldset|.\n\n    Notes\n    -----\n    Must be overridden in derived classes.\n\n    \"\"\"\n\n    def __init__(self, fieldset):\n        \"\"\"Initialize an EngineQueryFieldset instance.\"\"\"\n        self.field_name = fieldset.field_name\n        self.field_type = fieldset.field_type\n        self.raw_value = fieldset.value\n        self.raw_operator = fieldset.operator\n\n        operator = self.get_operator(self.raw_operator)\n        negate_operator = self.get_negate_operator()\n        self.negate = bool(negate_operator in operator)\n        self.operator = operator.replace(negate_operator, '')\n\n        # format value once we set self.operator\n        self.value = self.format_value()\n\n    def get_operator(self, raw_operator):\n        \"\"\"Return an operator for the query expression.\n\n        Parameters\n        ----------\n        raw_operator : str\n            Corresponds to the value of an option in |OPERATOR_CHOICES|.\n\n        Returns\n        -------\n        str\n            The operator that should be used for building the query\n            expression.\n\n        Raises\n        ------\n        NotImplementedError\n            If :const:`~engines.queries.EngineQueryFieldset.QUERY_OPERATORS`\n            has not been properly implemented.\n\n        \"\"\"\n        operator = self.QUERY_OPERATORS.get(raw_operator)\n        if operator in [None, NotImplemented]:\n            undefined_operator = 'QUERY_OPERATORS[\\'$s\\']' % raw_operator\n            return self.raise_attr_not_implemented(undefined_operator)\n        else:\n            return operator\n\n    def get_joiner(self, raw_joiner):\n        \"\"\"Return a logical operator to join fieldsets.\n\n        Parameters\n        ----------\n        raw_joiner : str\n            The value of an option in |LOGIC_CHOICES|.\n\n        Returns\n        -------\n        str\n            The logical operator that should be used to combine\n            fieldsets in the manner specified by the `raw_joiner`\n            parameter.\n\n        Raises\n        ------\n        NotImplementedError\n            If :const:`~engines.queries.EngineQueryFieldset.QUERY_JOINERS`\n            has not been properly implemented.\n\n        \"\"\"\n        joiner = self.QUERY_JOINERS.get(raw_joiner)\n        if joiner in [None, NotImplemented]:\n            undefined_joiner = 'QUERY_JOINERS[\\'%s\\']' % raw_joiner\n            return self.raise_attr_not_implemented(undefined_joiner)\n        else:\n            return joiner\n\n    def get_negate_operator(self):\n        \"\"\"Return an operator to negate a query expression.\n\n        Returns\n        -------\n        str\n            The Engine's equivalent of a 'NOT' operator.\n\n        Raises\n        ------\n        NotImplementedError\n            If :const:`~engines.queries.EngineQueryFieldset.NEGATE_OPERATOR`\n            has not been implemented.\n\n        \"\"\"\n        if self.NEGATE_OPERATOR is NotImplemented:\n            return self.raise_attr_not_implemented('NEGATE_OPERATOR')\n        else:\n            return self.NEGATE_OPERATOR\n\n    def format_value(self):\n        \"\"\"Return a value that can be used in the query expression.\n\n        Transforms the `raw_value` attribute into a value that can be\n        used in a query expression.\n\n        Returns\n        -------\n        |str|, |int|, |float|, |dict|, or |list|\n            A value that can be used in the query expression.\n\n        Raises\n        ------\n        NotImplementedError\n            If the method has not been implemented.\n\n        Notes\n        -----\n        This method must be implemented in derived classes.\n\n        \"\"\"\n        return self.raise_method_not_implemented()\n\n    def _polygon_filter(self, polygon_feature):\n        \"\"\"Create a polygon filter.\n\n        Takes a GeoJSON polygon or multipolygon feature and returns\n        a query expression for a geofilter. This method must be\n        implemented in derived classes for the `_geo_query` method\n        to work.\n        \"\"\"\n        return self.raise_method_not_implemented()\n\n    def _geo_query(self):\n        \"\"\"Create a geofilter.\n\n        If the object's `value` attribute represents a feature collection,\n        returns a geofilter based on the feature collection.\n        \"\"\"\n        feature_collection = self.value\n        features = feature_collection['features']\n        if len(features) < 2:\n            return self._polygon_filter(features[0])\n        else:\n            or_key = self.get_joiner('OR')\n            geo_filter = {or_key: []}\n            for feature in features:\n                poly_filter = self._polygon_filter(feature)\n                geo_filter[or_key].append(poly_filter)\n\n            return geo_filter\n\n    @property\n    def selector(self):\n        \"\"\"Return a query expression.\n\n        Returns\n        -------\n        dict\n            A query expression based on the |QueryFieldset| used to\n            initialize the object instance.\n\n        Raises\n        ------\n        NotImplementedError\n            If the method has not been implemented.\n\n        \"\"\"\n        return self.raise_attr_not_implemented()\n\n\nclass EngineQuery(BaseClass):\n    \"\"\"Create a query for a data store.\n\n    Defines search parameters for a |Collection| serviced by an |Engine|\n    instance.\n\n    Attributes\n    ----------\n    subqueries : `list` of `QueryFieldsets` and/or `EngineQueries`\n        Any combination of |QueryFieldsets| and child |EngineQueries|\n        to be used in constructing a query. Child |EngineQueries| are\n        used to construct more complex (nested) query expressions.\n\n    joiner : str\n        A logical operator for combining query terms. Corresponds to a\n        value in |LOGIC_CHOICES|.\n\n    \"\"\"\n\n    QUERY_JOINERS = _ENGINE_QUERY_JOINERS\n    \"\"\"|dict|\n\n    Maps the values in |LOGIC_CHOICES| to the corresponding logical\n    operators for the Engine.\n\n    Notes\n    -----\n    Must be overridden in derived classes.\n\n    \"\"\"\n\n    fieldset_model = NotImplemented\n    \"\"\"|type|\n\n    The |EngineQueryFieldset| subclass used to model fieldsets for the\n    Engine.\n\n    Notes\n    -----\n    Must be overridden in derived classes.\n\n    \"\"\"\n\n    def __init__(self, subqueries, joiner='AND'):\n        \"\"\"Initialize an EngineQuery instance.\"\"\"\n        self.subqueries = subqueries\n        self.joiner = self.get_joiner(joiner)\n\n    def _get_fieldset_model(self):\n        \"\"\"Get the EngineQueryFieldset subclass used for the data store.\n\n        Returns the |EngineQueryFieldset| subclass used to model\n        fieldsets for the Engine, if one has been defined. Otherwise,\n        raises a NotImplementedError.\n        \"\"\"\n        if self.fieldset_model is NotImplemented:\n            return self.raise_attr_not_implemented('fieldset_model')\n        else:\n            return self.fieldset_model\n\n    def _get_selector(self, fieldset):\n        \"\"\"Create a query expression from a fieldset.\n\n        Takes a |QueryFieldset| and returns a query expression.\n        \"\"\"\n        fieldset_model = self._get_fieldset_model()\n        fieldset_obj = fieldset_model(fieldset)\n        return fieldset_obj.selector\n\n    def _get_query(self, query):\n        \"\"\"Create a query expression.\n\n        Takes an |EngineQuery| or |QueryFieldset| and returns a query\n        expression. If the `query` argument is an |EngineQuery|,\n        recursively examines all its components to form the expression.\n        \"\"\"\n        query_phrases = []\n\n        for subquery in query.subqueries:\n\n            # base case\n            if isinstance(subquery, QueryFieldset):\n                subquery_filter = self._get_selector(subquery)\n                query_phrases.append(subquery_filter)\n\n            # recursive case\n            elif isinstance(subquery, EngineQuery):\n                query_class = type(self)\n                classquery = query_class(subquery.subqueries, subquery.joiner)\n                subquery_filter = self._get_query(classquery)\n                query_phrases.append(subquery_filter)\n\n        return self.join_subqueries(query_phrases, query.joiner)\n\n    def get_joiner(self, raw_joiner):\n        \"\"\"Return a logical operator to join fieldsets.\n\n        Parameters\n        ----------\n        raw_joiner : str\n            Corresponds to the value of an option in |LOGIC_CHOICES|.\n\n        Returns\n        -------\n        str\n            The logical operator that should be used to combine\n            fieldsets in the manner specified by the `raw_joiner`\n            parameter.\n\n        Raises\n        ------\n        NotImplementedError\n            If :const:`~engines.queries.EngineQuery.QUERY_JOINERS`\n            has not been properly implemented.\n\n        \"\"\"\n        joiner = self.QUERY_JOINERS.get(raw_joiner)\n        if joiner in [None, NotImplemented]:\n            undefined_joiner = 'QUERY_JOINERS[\\'%s\\']' % raw_joiner\n            return self.raise_attr_not_implemented(undefined_joiner)\n        else:\n            return joiner\n\n    @staticmethod\n    def join_subqueries(subqueries, joiner):\n        \"\"\"Return a query expression.\n\n        Parameters\n        ----------\n        fieldsets : |list| of |QueryFieldsets|\n            |QueryFieldsets| for defining a query.\n\n        joiner : str\n            A logical operator specifying how multiple query fieldsets\n            should be combined. Corresponds to a value in |LOGIC_CHOICES|.\n\n        Raises\n        ------\n        NotImplementedError\n            If the method has not been implemented.\n\n        Notes\n        -----\n        This method may be overridden in derived classes.\n\n        \"\"\"\n        return {joiner: subqueries}\n\n    @property\n    def params(self):\n        \"\"\"Return parameters for a query.\n\n        Returns\n        -------\n        dict\n            A query expression constructed from the object's\n        :attr:`~EngineQuery.fieldsets`.\n\n        \"\"\"\n        return self._get_query(self)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, null, null, null, null, null, null, null, null, null, null], "name": "engines/registry.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nProvides constants for locating |Engine| subclasses.\n\n[`source`_]\n\n=========================  ================================================\nConstant                   Description\n=========================  ================================================\n:const:`~ENGINES_PACKAGE`  The name of this package.\n:const:`~ENGINE_MODULE`    Name for modules containing |Engine| subclasses.\n:const:`~CURRENT_PATH`     Path containing `engines` subpackages.\n:const:`~BACKEND_CHOICES`  Choices for data stores (e.g., Elasticsearch).\n=========================  ================================================\n\n.. _source: ../_modules/engines/registry.html\n\n\"\"\"\n\n# standard library\nimport os\n\n# local\nfrom utils.choices import choices\n\n\ndef _get_this_package():\n    \"\"\"Get the name of this package.\n\n    Returns the name of the package in which this module resides.\n    \"\"\"\n    current_path = os.path.dirname(__file__)\n    return os.path.basename(current_path)\n\n\nENGINES_PACKAGE = _get_this_package()\n\"\"\"|str|\n\nThe name of this package, which contains subpackages for specific\nbackends.\n\"\"\"\n\nENGINE_MODULE = 'engine'\n\"\"\"|str|\n\nStandard name for a module in an `engines` subpackage that contains an\n|Engine| sublclass used to interact with a data store.\n\"\"\"\n\nCURRENT_PATH = os.path.dirname(os.path.abspath(__file__))\n\"\"\"|str|\n\nPath containing `engines` subpackages for particular backends.\n\"\"\"\n\nBACKEND_CHOICES = choices.get_package_choices(CURRENT_PATH)\n\"\"\"|tuple| of |tuple|\n\nBackend choices, based on `engines` subpackages. Each item provides a\n(value, label) choice for a package, which can be used in a `choices`\nargument for a CharField in a Django Model, e.g.::\n\n    (\n        ('elasticsearch', 'elasticsearch'),\n        ('mongodb', 'mongodb'),\n    )\n\n\"\"\"\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, 0], "name": "engines/sorter.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines classes for ordering documents.\n\n=======================  =========================================\nClass                    Description\n=======================  =========================================\n:class:`~SortParam`      Criteria to sort docs by a field.\n:class:`~Sorter`         Criteria to sort docs by a set of fields.\n=======================  =========================================\n\n\"\"\"\n\n# local\nfrom cyphon.baseclass import BaseClass\n\n\nclass SortParam(object):\n    \"\"\"Criteria to sort documents by values of a particular field.\n\n    Parameters\n    ----------\n    field_name : str\n        The name of the field by which documents should be sorted.\n\n    field_type : str\n        The type of field by which documents should be sorted (e.g.,\n        'CharField'). See |FIELD_TYPE_CHOICES| for a list of field types.\n\n    order : str\n        The order in which field values should be sorted. Choices are\n        'ASC' (ascending) or 'DESC' (descending).\n\n    Attributes\n    ----------\n    field_name : str\n        The name of the field by which documents should be sorted.\n\n    field_type : str\n        The type of field by which documents should be sorted (e.g.,\n        'CharField'). See |FIELD_TYPE_CHOICES| for a list of field types.\n\n    order : str\n        The order in which field values should be sorted. Choices are\n        'ASC' (ascending) or 'DESC' (descending).\n\n    \"\"\"\n\n    def __init__(self, field_name, field_type, order):\n        \"\"\"Initialize a SortParam instance.\"\"\"\n        self.field_name = field_name\n        self.field_type = field_type\n        self.order = order\n\n\nclass Sorter(BaseClass):\n    \"\"\"Criteria to sort documents by a set of fields.\n\n    Parameters\n    ----------\n    sort_list : |list| of |SortParams|\n        The |SortParams| used to define the overall order of documents.\n\n    \"\"\"\n\n    def __init__(self, sort_list):\n        \"\"\"Initialize a Sorter instance.\"\"\"\n        self.sort_list = sort_list\n\n    @property\n    def params(self):\n        \"\"\"Format and return parameters to sort documents.\n\n        Raises\n        ------\n        NotImplementedError\n            If the method has not been implemented.\n\n        \"\"\"\n        return self.raise_attr_not_implemented('params')\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "inspections/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, null, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, 1, null], "name": "inspections/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines ModelAdmins for Inspections and InspectionSteps, and registers\nthem with Django Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom . import models\n\n\nclass InspectionStepInLineAdmin(admin.TabularInline):\n    \"\"\"\n    Customizes admin inline tables for InspectionSteps.\n    \"\"\"\n    model = models.InspectionStep\n\n\nclass InspectionStepAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for InspectionSteps.\n    \"\"\"\n    list_display = [\n        'id', \n        'inspection',\n        'sieve',\n        'result_value',\n        'rank',\n    ]\n    list_display_links = ['id', ]\n\n\nclass InspectionAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Inspections.\n    \"\"\"\n    inlines = [InspectionStepInLineAdmin, ]\n    save_as = True\n\n\nadmin.site.register(models.InspectionStep, InspectionStepAdmin)\nadmin.site.register(models.Inspection, InspectionAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, 1, null, 1, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 0, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, 1, null, null, null, null, null, null, 1, null, 1, 1, 1, null, 1, 0, null, 1, 1, null], "name": "inspections/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.db import models\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.models import GetByNameManager\nfrom sifter.datasifter.datasieves.models import DataSieve\n\n\nclass Inspection(models.Model):\n    \"\"\"\n\n    Attributes:\n        name: a string representing the name of the Inspection\n        steps: one or more InspectionSteps associated with the Inspection \n    \"\"\"\n    name = models.CharField(max_length=255, unique=True)\n\n    objects = GetByNameManager()\n\n    def __str__(self):\n        return self.name\n\n    def get_result(self, data):\n        \"\"\"\n\n        Notes\n        -----\n        This method should have the same name as the corresponding \n        method in a LabProcedure.\n\n        \"\"\"\n        steps = self.steps.all()\n        for step in steps:\n            if step.is_match(data):\n                return step.result_value\n        return None\n\n\nclass InspectionStep(models.Model):\n    \"\"\"\n    Defines a step in an Inspection.\n\n    Attributes:\n        inspection: the Inspection associated with the InspectionStep\n        sieve: a DataSieve for examining data\n        result_value: a value to be returned if the datasieve returns True for\n            the data examined\n        rank: an integer representing the order of the step in an Inspection;\n            steps are performed in ascending order (the lowest rank first)\n\n    \"\"\"\n    inspection = models.ForeignKey(\n        Inspection,\n        related_name='steps',\n        related_query_name='step',\n        verbose_name=_('Inspection'),\n        help_text=_('The Inspection in which this step is included.')\n    )\n    sieve = models.ForeignKey(\n        DataSieve,\n        related_name='inspection_steps',\n        related_query_name='inspection_step',\n        help_text=_('The DataSieve used to inspect the data during this step.')\n    )\n    result_value = models.CharField(\n        max_length=255,\n        help_text=_('The value to be returned if the DataSieve returns True '\n                    'for the data examined.')\n    )\n    rank = models.IntegerField(\n        default=0,\n        help_text=_('An integer representing the order of this step in the '\n                    'Inspection. Steps are performed in ascending order, '\n                    'with the lowest number examined first.')\n    )\n\n    objects = GetByNameManager()\n\n    class Meta:\n        ordering = ['rank']\n        unique_together = [('inspection', 'sieve'), ('inspection', 'rank')]\n\n    def __str__(self):\n        return '%s <- %s (rank: %s)' % (self.sieve, self.result_value, self.rank)\n\n    def is_match(self, data):\n        return self.sieve.is_match(data)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "lab/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "lab/geoip/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, 1, null, 1, null, 1, null, null, 1, null, null, null, null, 0, 0, null, 0, 0, null, null, null, 1, null, null, null, 1, null, 1, null, 0, null, 0, 0, 0, null, 0, 0, null, null, null, 0, null, 1], "name": "lab/geoip/geoip.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# standard library\nimport ipaddress\nimport logging\n\n# third party\nfrom django.conf import settings\nfrom geoip2.database import Reader\nfrom geoip2.errors import AddressNotFoundError\n\n_GEOIP_SETTINGS = settings.GEOIP\n\n_LOGGER = logging.getLogger(__name__)\n\n\ndef is_public_ip_addr(ip_address):\n    \"\"\"\n    Takes an IPv4 or IPv6 address and returns a Boolean indicating\n    whether it is public.\n    \"\"\"\n    try:\n        return not ipaddress.ip_address(ip_address).is_private\n\n    except ValueError:\n        _LOGGER.warning('\"%s\" does not appear to be an IPv4 or IPv6 address.',\n                        ip_address)\n\n\ndef get_lng_lat(ip_address):\n    \"\"\"\n    Takes an IPv4 or IPv6 address and returns a 2-tuple of (longitude, latitude).\n    \"\"\"\n    coord = None\n\n    if ip_address and is_public_ip_addr(ip_address):\n\n        db_reader = Reader(_GEOIP_SETTINGS['CITY_DB_PATH'])\n\n        try:\n            result = db_reader.city(ip_address)\n            coord = (result.location.longitude, result.location.latitude)\n\n        except AddressNotFoundError:\n            _LOGGER.warning('The address %s is not in the GeoLite2 database.',\n                           ip_address)\n\n        finally:\n            db_reader.close()\n\n    return coord\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "lab/language/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, null, null, 0, null, null, null, null, null, null, null, null, null, null, 0, null, null, 0, null, 0, 0, null, 0, null], "name": "lab/language/classifier.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom langdetect import detect_langs\n\n\ndef assign_language(text):\n    \"\"\"\n    Uses Google's language detection algorithm to assign a language to a text\n    string. If the language cannot be determined with at least 99% confidence,\n    the function returns the string 'none'. In such cases, MongoDB's text index  \n    will use simple tokenization with no list of stop words and no stemming.\n    See http://docs.mongodb.org/manual/reference/text-search-languages/\n    for more info.\n\n    \"\"\"\n    # languages supported by MongoDB's text index\n    supported_langs = ['da', 'nl', 'en', 'fi', 'fr', 'de', 'hu', 'it', 'nb',\n                       'pt', 'ro', 'ru', 'es', 'sv', 'tr']\n\n    langs = detect_langs(text)\n\n    if langs[0].prob >= 0.99 and langs[0].lang in supported_langs:\n        return langs[0].lang\n    else:\n        return 'none'\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "lab/procedures/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, 1, null, null, 1, 1, null, null, 1, 1, null], "name": "lab/procedures/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom lab.procedures.models import Protocol, Procedure\n\n\nclass ProtocolAdmin(admin.ModelAdmin):\n    pass\n\n\nclass ProcedureAdmin(admin.ModelAdmin):\n    pass\n\n\nadmin.site.register(Protocol, ProcedureAdmin)\nadmin.site.register(Procedure, ProcedureAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, 1, 1, null, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, 0, 0, 0, 0, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, null, null, 1, null, null, null, 1, null, null, null, null, 1, null, 1, null, null, null, 1, null, 1, 0, null, 1, null, null, null, 1, null, null, 1, null, 1, null, 1, null, null, null, 1, null, null, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, 0, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 0], "name": "lab/procedures/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# standard library\nimport importlib\nimport logging\n\n# third party\nfrom django.db import models\nfrom django.core.exceptions import ObjectDoesNotExist\n\n# local\nfrom lab.registry import LAB_CHOICES\nfrom utils.parserutils import parserutils\nfrom utils.validators.validators import IDENTIFIER_VALIDATOR\n\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass ProtocolManager(models.Manager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def get_by_natural_key(self, package, module, function):\n        \"\"\"\n        Allows retrieval of a Lab by its natural key instead of its\n        primary key.\n        \"\"\"\n        try:\n            return self.get(package=package, module=module, function=function)\n        except ObjectDoesNotExist:\n            LOGGER.error('%s \"%s.%s.%s\" does not exist',\n                         self.model.__name__, package, module, function)\n\n\nclass Protocol(models.Model):\n    \"\"\"\n\n    Attributes:\n        name: a string representing the name of the Protocol\n        package: the name of a subpackage within the labs package that will\n            analyze the data\n        module: the name of the module the package that will analyze the data\n        function: the name of the function that will analyze the data\n\n    \"\"\"\n    name = models.CharField(max_length=255, unique=True)\n    package = models.CharField(\n        max_length=32,\n        validators=[IDENTIFIER_VALIDATOR],\n        choices=LAB_CHOICES\n    )\n    module = models.CharField(\n        max_length=32,\n        validators=[IDENTIFIER_VALIDATOR]\n    )\n    function = models.CharField(\n        max_length=32,\n        validators=[IDENTIFIER_VALIDATOR]\n    )\n\n    objects = ProtocolManager()\n\n    class Meta:\n        \"\"\"\n        Metadata options.\n        \"\"\"\n        unique_together = ('package', 'module', 'function')\n\n    def __str__(self):\n        return self.name\n\n    def _get_module(self):\n        \"\"\"\n        Returns the module for analyzing the data.\n        \"\"\"\n        module_full_name = 'lab.%s.%s' % (self.package, self.module)\n\n        # load the module (will raise ImportError if module cannot be loaded)\n        module = importlib.import_module(module_full_name)\n\n        return module\n\n    def process(self, data):\n        \"\"\"\n        Passes the data to the classfying function and returns the result.\n        \"\"\"\n        module = self._get_module()\n\n        # get the classifier function (will raise AttributeError if function cannot be found)\n        func = getattr(module, self.function)\n\n        return func(data)\n\n\nclass Procedure(models.Model):\n    \"\"\"\n\n    Attributes:\n        name: a string representing the name of the procedure\n        protocol: a Protocol used to analyze\n        field_name: the name of the field containing the data to analyze. If no\n            field_name is provide, the entire data dictionary is analyzed.\n    \"\"\"\n    name = models.CharField(max_length=255, unique=True)\n    protocol = models.ForeignKey(Protocol)\n    field_name = models.CharField(max_length=255, blank=True, null=True)\n\n    def __str__(self):\n        return self.name\n\n    def _analyze(self, data):\n        return self.protocol.process(data)\n\n    def get_result(self, data):\n        \"\"\"\n        Takes a data dictionary and analyzes it using the Procedure's protocol.\n        If the Procedure has a field_name, only the corresponding field within\n        the data dictionary is analyzed. Otherwise, the entire data dictionary\n        is analyzed with the protocol.\n\n        Notes\n        -----\n        This method should have the same name as the corresponding\n        method in an Inspection.\n        \"\"\"\n        if self.field_name:\n            value = parserutils.get_dict_value(self.field_name, data)\n            return self._analyze(value)\n        else:\n            return self._analyze(data)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, 1, 1], "name": "lab/registry.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nProvides package choices that can be used to limit choices for Labs.\nConstructs choices from the names of subpackages in the Labs package.\n\n\"\"\"\n\n# standard library\nimport os\n\n# local\nfrom utils.choices import choices\n\n\ndef get_this_package():\n    \"\"\"\n    Returns the name of the package in which this module resides.\n    \"\"\"\n    current_path = os.path.dirname(__file__)\n    return os.path.basename(current_path)\n\n\nLABS_PACKAGE = get_this_package()\n\nABSOLUTE_PATH = os.path.dirname(os.path.abspath(__file__))\nLAB_CHOICES = choices.get_package_choices(ABSOLUTE_PATH)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, 1, null, 1, null, 1], "name": "manage.py", "source": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\nimport os\nimport sys\n\nif __name__ == \"__main__\":\n    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"cyphon.settings.default\")\n\n    from django.core.management import execute_from_command_line\n\n    execute_from_command_line(sys.argv)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1], "name": "monitors/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\ndefault_app_config = 'monitors.apps.MonitorsConfig'\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, null], "name": "monitors/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclass for Monitors and registers Monitors with\nDjango Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom .models import Monitor\n\n\nclass MonitorAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Monitors.\n    \"\"\"\n    readonly_fields = (\n        'status',\n        'created_date',\n        'last_updated',\n        'last_healthy',\n        'last_alert_date',\n        'last_alert_id',\n        'last_active_distillery',\n        'last_saved_doc',\n    )\n    fieldsets = (\n        (None, {\n            'description': _('A Monitor monitors one or more Distilleries to '\n                             'make sure data is being saved at a minimal rate.'\n                             'If data is not being saved at the expected rate, '\n                             'the Monitor will generate an Alert.'),\n            'fields': (\n                'name',\n                'groups',\n            )\n        }),\n        (_('Monitoring'), {\n            'fields': (\n                'enabled',\n                'distilleries',\n                'time_interval',\n                'time_unit',\n            )\n        }),\n        (_('Alerting'), {\n            'fields': (\n                'alerts_enabled',\n                'repeating_alerts',\n                'alert_level',\n                'last_alert_date',\n                'last_alert_id',\n            )\n        }),\n        (_('Status'), {\n            'fields': (\n                'status',\n                'last_updated',\n                'last_healthy',\n\n            ),\n        }),\n        (_('Most Recent Data'), {\n            'classes': ('pre', ),\n            'fields': (\n                'last_active_distillery',\n                'last_saved_doc',\n            ),\n        }),\n        (_('History'), {\n            'fields': (\n                'created_date',\n            ),\n        }),\n    )\n    filter_horizontal = ('distilleries', )\n    list_display = (\n        'name',\n        'enabled',\n        'time_interval',\n        'time_unit',\n        'alerts_enabled',\n        'repeating_alerts',\n        'alert_level',\n        'status',\n        'last_updated',\n        'last_healthy',\n    )\n    list_editable = (\n        'time_interval',\n        'time_unit',\n        'alert_level',\n    )\n    list_filter = (\n        'alerts_enabled',\n        'repeating_alerts',\n        'alert_level',\n        'status',\n    )\n    save_as = True\n\n\nadmin.site.register(Monitor, MonitorAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, 1, null, 1, null, null, null, 1, null], "name": "monitors/apps.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.apps import AppConfig\n\n\nclass MonitorsConfig(AppConfig):\n    \"\"\"\n\n    \"\"\"\n    name = 'monitors'\n    verbose_name = 'Monitors'\n\n    def ready(self):\n        \"\"\"\n\n        \"\"\"\n        import monitors.signals\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, 1, 1, 1, null, null, 1, 1, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, 1, null, null, null, 1, 1, 1, null, null, null, 1, 1, 1, 1, null, null, null, null, null, 1, null, null, null, null, null, null, 1, 1, null, 1, null, 1, 1, null, 1, null, null, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, 1, null, 1, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, 1, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, null, 1, 1, 1, 1, 1, null, 1, null, null, null, null, null, 1, 1, 1, 1, 1, 1, null, 1, null, null, null, null, null, 1, 1, 1, null, 1, null], "name": "monitors/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Monitor class for monitoring the rate at which data is saved\nto Distilleries. Monitors can generate Alerts if data is not being saved\nat the expected rate.\n\"\"\"\n\n# standard library\nimport json\n\n# third party\nfrom django.db import models\nfrom django.utils import timezone\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom alarms.models import Alarm, AlarmManager\nfrom alerts.models import Alert\nfrom cyphon.choices import (\n    ALERT_LEVEL_CHOICES,\n    MONITOR_STATUS_CHOICES,\n    TIME_UNIT_CHOICES,\n)\nfrom distilleries.models import Distillery\nimport utils.dateutils.dateutils as dt\n\n\nclass Monitor(Alarm):\n    \"\"\"\n    A Monitor monitors one or more Distilleries for saved data.\n    It can be used to generate Alerts if data is not being saved\n    to the Distilleries at an expected rate.\n\n    Attributes\n    ----------\n    name : str\n        The name of the |Monitor|.\n\n    enabled : bool\n        If True, the Monitor will be included in Monitor status updates.\n\n    distilleries : Distilleries\n        One or more Distilleries that the Monitor should watch.\n\n    time_interval : int\n        Maximum length of time that the Monitor's Distilleries can have\n        no activity before the Monitor status changes to unhealthy.\n\n    time_unit : str\n        The time units for the time_interval. Possible values are\n        constrained to TIME_UNIT_CHOICES.\n\n    alerts_enabled : bool\n        If True, the Monitor is allowed to generate Alerts.\n\n    repeating_alerts : bool\n        If True, the Monitor will generate an Alert at every time\n        interval when its status is unhealthy. If False, the Monitor\n        will only generate an Alert when its status changes from healthy\n        to unhealthy.\n\n    alert_level : str\n        The level to use when generating Alerts. Possible values are\n        constrained to MONITOR_STATUS_CHOICES.\n\n    last_alert_date : datetime\n        A |datetime| indicating the created_date for the last Alert\n        generated by the monitor.\n\n    last_alert_id : int\n        A positive integer indicating the id of the last Alert\n        generated by the monitor.\n\n    status : str\n        The current status of the Monitor. Possible values are\n        constrained to MONITOR_STATUS_CHOICES.\n\n    created_date : datetime\n        A |datetime| indicating when the Monitor was created.\n\n    last_updated : datetime\n        A |datetime| indicating when the Monitor status was last\n        updated (though the status may not have changed).\n\n    last_healthy : datetime\n        A |datetime| indicating when the Monitor last had a healthy\n        status.\n\n    last_active_distillery : Distillery\n        The last Distillery that was saved to among the Distilleries\n        being monitored.\n\n    last_saved_doc : str\n        The document id of the last document that was saved among the\n        Distilleries being monitored.\n\n    \"\"\"\n    distilleries = models.ManyToManyField(\n        Distillery,\n        related_name='+',  # do not create backwards relation\n        limit_choices_to={'is_shell': False}\n    )\n    time_interval = models.IntegerField()\n    time_unit = models.CharField(max_length=3, choices=TIME_UNIT_CHOICES)\n    alerts_enabled = models.BooleanField(default=True)\n    repeating_alerts = models.BooleanField(default=False)\n    alert_level = models.CharField(\n        max_length=20,\n        choices=ALERT_LEVEL_CHOICES\n    )\n    last_alert_date = models.DateTimeField(blank=True, null=True)\n    last_alert_id = models.PositiveIntegerField(blank=True, null=True)\n    status = models.CharField(\n        max_length=20,\n        choices=MONITOR_STATUS_CHOICES\n    )\n    created_date = models.DateTimeField(auto_now_add=True)\n    last_updated = models.DateTimeField(auto_now=True)\n    last_healthy = models.DateTimeField(blank=True, null=True)\n    last_active_distillery = models.ForeignKey(\n        Distillery,\n        blank=True,\n        null=True,\n        verbose_name=_('distillery')\n    )\n    last_saved_doc = models.CharField(\n        max_length=255,\n        blank=True,\n        null=True,\n        verbose_name=_('document id')\n    )\n\n    _HEALTHY = 'GREEN'\n    _UNHEALTHY = 'RED'\n\n    objects = AlarmManager()\n\n    def __str__(self):\n        return self.name\n\n    def _get_interval_in_seconds(self):\n        \"\"\"\n        Returns the number of minutes in the Monitor's time interval.\n        \"\"\"\n        return dt.convert_time_to_seconds(self.time_interval, self.time_unit)\n\n    def _get_inactive_seconds(self):\n        \"\"\"\n        Returns the number of seconds since a document was saved to one\n        of the Monitor's distilleries.\n        \"\"\"\n        if self.last_healthy is not None:\n            time_delta = timezone.now() - self.last_healthy\n        else:\n            time_delta = timezone.now() - self.created_date\n        return time_delta.seconds\n\n    def _get_last_alert_seconds(self):\n        \"\"\"\n        Returns the number of seconds since the Monitor last generated\n        an Alert.\n        \"\"\"\n        if self.last_alert_date is not None:\n            time_delta = timezone.now() - self.last_alert_date\n            return time_delta.seconds\n\n    def _get_inactive_interval(self):\n        \"\"\"\n        Returns a string with the approximate time since a document was\n        saved to one of the Monitor's distilleries (e.g., '35 s', '6 m',\n        '2 h', '1 d'). The time is rounded down to the nearest integer.\n        \"\"\"\n        seconds = self._get_inactive_seconds()\n        return dt.convert_seconds(seconds)\n\n    def _is_overdue(self):\n        \"\"\"\n        Returns a Boolean indicating whether the time since a document\n        was last saved to one of the Monitor's distilleries exceeds the\n        Monitor's interval.\n        \"\"\"\n        return self._get_inactive_seconds() > self._get_interval_in_seconds()\n\n    def _get_title(self):\n        \"\"\"\n        Returns a title for an Alert.\n        \"\"\"\n        downtime = self._get_inactive_interval()\n        return 'Health monitor \"%s\" has seen no activity for over %s.' \\\n               % (self.name, downtime)\n\n    def _alert_due(self):\n        \"\"\"\n        If the Monitor has previously created an Alert, returns a\n        Boolean indicating whether the last time an Alert was generated\n        exceeds the Monitor's interval. If the Monitor has never created\n        an Alert, returns True. For Monitors with repeating Alerts, this\n        is used to determine whether enough time has passed to generate\n        another Alert.\n        \"\"\"\n        last_alert_time = self._get_last_alert_seconds()\n        if last_alert_time:\n            return last_alert_time > self._get_interval_in_seconds()\n        else:\n            return True\n\n    def _create_alert(self):\n        \"\"\"\n        Generates an Alert based on the Monitor's alert_level. Returns\n        the saved Alert.\n        \"\"\"\n        title = self._get_title()\n        alert = Alert(\n            title=title,\n            level=self.alert_level,\n            alarm=self,\n            distillery=self.last_active_distillery,\n            doc_id=self.last_saved_doc\n        )\n        alert.save()\n        return alert\n\n    def _alert(self, old_status):\n        \"\"\"\n        Takes a string representing the Monitor's status prior to its\n        last update. Determines whether an Alert should be generated,\n        and, if so, creates the Alert and saves the Alert's created_date\n        to the Monitor's last_alert_date field and the Alert's id to the\n        last_alert_id field. Returns None.\n        \"\"\"\n        repeat_alert = self.repeating_alerts and self._alert_due()\n        status_changed = old_status != self._UNHEALTHY\n        if self.alerts_enabled and (repeat_alert or status_changed):\n            alert = self._create_alert()\n            self.last_alert_date = alert.created_date\n            self.last_alert_id = alert.pk\n            self.save()\n\n    def _find_last_doc(self):\n        \"\"\"\n        Returns the last document saved in the last active Distillery,\n        if one exists. Otherwise, returns None.\n        \"\"\"\n        return self.last_active_distillery.find_by_id(self.last_saved_doc)\n\n    @property\n    def interval(self):\n        \"\"\"\n        Returns a string with the Monitor's time_interval and time_unit.\n        \"\"\"\n        return str(self.time_interval) + self.time_unit\n\n    def register_healthy(self, distillery, doc_id):\n        \"\"\"\n        Takes a Distillery and a document id string. Updates the\n        Monitor's status as healthy, records the current time in the\n        last_healthy field, and records the Distillery and doc id to the\n        last_active_distillery and last_saved_doc fields.\n        \"\"\"\n        self.last_healthy = timezone.now()\n        self.last_active_distillery = distillery\n        self.last_saved_doc = doc_id\n        self.status = self._HEALTHY\n        self.save()\n\n    def update_status(self):\n        \"\"\"\n        Determines whether the Monitor's status should be changed to\n        unhealthy. If so, updates the status and creates an Alert if\n        appropriate. Returns the Monitor's updated status.\n        \"\"\"\n        old_status = self.status\n        if self._is_overdue():\n            self.status = self._UNHEALTHY\n            self._alert(old_status)\n        self.save()  # update record even if healthy\n        return self.status\n\n    def last_doc(self):\n        \"\"\"\n        Returns a string of the content for the last document saved to\n        one of the Monitor's distilleries. If the Monitor has no record\n        of a last saved document, returns None.\n        \"\"\"\n        if self.last_active_distillery:\n            doc = self._find_last_doc()\n            return json.dumps(doc, indent=4)\n\n    last_doc.short_description = _('Last saved document')\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, 1, 1, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "monitors/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nSerializers for Monitors.\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom distilleries.serializers import DistilleryListSerializer\nfrom .models import Monitor\n\n\nclass MonitorSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Distilleries.\n    \"\"\"\n    distilleries = DistilleryListSerializer(many=True)\n    last_active_distillery = DistilleryListSerializer()\n\n    class Meta:\n        model = Monitor\n        depth = 1\n        fields = (\n            'name',\n            'enabled',\n            'distilleries',\n            'interval',\n            'alerts_enabled',\n            'alert_level',\n            'status',\n            'last_updated',\n            'last_healthy',\n            'last_active_distillery',\n            'last_saved_doc',\n            'last_doc',\n        )\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, 1, 1, 1, null, 1], "name": "monitors/signals.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a reciever for the Distillery package's document_saved signal.\n\"\"\"\n\n# third party\nfrom django.db import close_old_connections\nfrom django.dispatch import receiver\n\n# local\nfrom distilleries.signals import document_saved\nfrom monitors.models import Monitor\n\n\n@receiver(document_saved)\ndef update_monitors(sender, doc, distillery, doc_id, **args):\n    \"\"\"\n    Receiver for the Warehouse package's document_saved signal.\n\n    \"\"\"\n    active_monitors = Monitor.objects.find_enabled()\n    monitors = active_monitors.filter(distilleries=distillery)\n    for monitor in monitors:\n        monitor.register_healthy(distillery, doc_id)\n\n    close_old_connections()\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, 1, null, null, null, null, 1, 1, 1, null, 1, 1, 1, null, 0, 0, null], "name": "monitors/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nViews for Monitors.\n\"\"\"\n\n# third party\nfrom rest_framework import viewsets\nfrom rest_framework.response import Response\nfrom rest_framework.decorators import list_route\n\n# local\nfrom .models import Monitor\nfrom .serializers import MonitorSerializer\n\n\nclass MonitorViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"\n    Read only viewset for Monitors.\n    \"\"\"\n    queryset = Monitor.objects.all()\n    serializer_class = MonitorSerializer\n\n    @list_route(methods=['get'], url_path='enabled')\n    def enabled(self, request, *args, **kwargs):\n        \"\"\"\n        Returns a list of Monitors that are enabled.\n        \"\"\"\n        enabled_qs = Monitor.objects.find_enabled()\n        filtered_qs = self.filter_queryset(enabled_qs)\n        page = self.paginate_queryset(filtered_qs)\n\n        if page is not None:\n            serializer = self.get_serializer(page, many=True)\n            return self.get_paginated_response(serializer.data)\n\n        serializer = self.get_serializer(filtered_qs, many=True)\n        return Response(serializer.data)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1], "name": "notifications/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\ndefault_app_config = 'notifications.apps.NotificationsConfig'\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, null, 1, null, null, null, 1, null], "name": "notifications/apps.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.apps import AppConfig\n\n\nclass NotificationsConfig(AppConfig):\n    \"\"\"\n\n    \"\"\"\n    name = 'notifications'\n\n    def ready(self):\n        \"\"\"\n\n        \"\"\"\n        import notifications.signals\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, null], "name": "notifications/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nSerializers for notications.\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n\nclass SubscribeSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for the notification subscribe view.\n    \"\"\"\n    registration_id = serializers.CharField(max_length=254)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, 1, 1, 1, null, null, 1, null, 1, null, 1, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, 1, 1, 1, 1, 1, null, 1, 1, null, 1, null, null, 1, null, null, null, 1, null, 1, 1, null, 1, 1, null, null, null, null, null, 1, 1, null, null, null, 1, null, 0, 0, null, null, null, 1, null, null, null, null, 1, null, 1, 0, null, null, 1, 1, 1, 1, null, 1, 1], "name": "notifications/signals.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nMethods that handle signals necessary for push notifications.\n\"\"\"\n\n# standard library\nimport logging\nimport requests\n\n# third party\nfrom constance import config\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.db.models.signals import post_save\nfrom django.dispatch import receiver\n\n# local\nfrom alerts.models import Alert\n\n_NOTIFICATION_SETTINGS = settings.NOTIFICATIONS\n\n_PUSH_NOTIFICATION_URL = 'https://android.googleapis.com/gcm/send'\n\n_PUSH_NOTIFICATION_REQUEST_HEADERS = {\n    'Content-Type': 'application/json',\n    'Authorization': 'key=' + _NOTIFICATION_SETTINGS['PUSH_NOTIFICATION_KEY']\n}\n\n_LOGGER = logging.getLogger(__name__)\n\n\ndef get_registration_ids(alert):\n    \"\"\"\n    Takes an Alert and returns a list of push notification ids for users\n    who should be notified.\n    \"\"\"\n    user_model = get_user_model()\n    queryset = Alert.objects.filter(pk=alert.pk)\n    registration_ids = []\n    for user in user_model.objects.all():\n        can_view = Alert.objects.filter_by_user(user, queryset)\n\n        if can_view and user.push_notification_id:\n            registration_ids.append(user.push_notification_id)\n\n    return registration_ids\n\n\ndef send_push_notifications(alert):\n    \"\"\"\n    Sends push notifications to all the users that registered for them.\n    \"\"\"\n    registration_ids = get_registration_ids(alert)\n\n    if registration_ids:\n        data = {'registration_ids': registration_ids}\n\n        try:\n            push_request = requests.post(\n                _PUSH_NOTIFICATION_URL,\n                headers=_PUSH_NOTIFICATION_REQUEST_HEADERS,\n                json=data\n            )\n\n            if push_request.status_code != 200:\n                _LOGGER.error('Could not send push notifications. '\n                              'Received error from Chrome server: %s',\n                              push_request.text)\n            else:\n                _LOGGER.info('Push notifications sent successfully')\n\n        except requests.exceptions.SSLError:\n            _LOGGER.error('Could not send push notifications. '\n                          'SSL certificate verification failed. ')\n\n\n@receiver(post_save, sender=Alert)\ndef handle_alert_post_save_signal(**kwargs):\n    \"\"\"\n    Handles the Alert models post_save signal.\n    \"\"\"\n    if config.PUSH_NOTIFICATIONS_ENABLED:\n\n        if not _NOTIFICATION_SETTINGS['PUSH_NOTIFICATION_KEY']:\n            _LOGGER.error('Could not send push notifications. '\n                          'No PUSH_NOTIFICATION_KEY was provided')\n        else:\n            is_new_alert = kwargs.get('created', False)\n            alert = kwargs.get('instance')\n            ignored_levels = _NOTIFICATION_SETTINGS['IGNORED_ALERT_LEVELS']\n            should_notify = alert.level not in ignored_levels\n\n            if is_new_alert and should_notify:\n                send_push_notifications(alert)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, null, null, null], "name": "notifications/urls.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nUrls for push notifications.\n\"\"\"\n\n# third party\nfrom django.conf.urls import url\n\n# local\nfrom . import views\n\n\nurlpatterns = [\n\turl(r'^subscribe/$', views.SubscribeView.as_view(), \n\t\tname='notifications_subscribe'),\n\turl(r'test/$', views.TestNotifications.as_view(), name='notifications_test'),\n\turl(r'^$', views.NotificationView.as_view(), name='notifications_get')\n]\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, 1, 1, 1, null, null, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, 1, null, null, null, 1, 1, null, 1, null, null, null, 1, null, 1, 1, 1, 1, 1, 1, 1, 1, null, 1, null, null, null, null, null, 1, null, null, null, 1, 1, null, 1, null, null, null, 1, null, null, null, 1, 1, null, null, null, 1, null, null, null, 1, 1, 1, 1, null, null, null, 1, 1, 1, null, null, 1, 1, null, null, null, 1, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, 0, 0, null], "name": "notifications/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nViews for push notifications.\n\"\"\"\n\n# third party\nfrom django.contrib.auth import get_user_model\nfrom django.core.exceptions import ObjectDoesNotExist\nfrom django.db import IntegrityError\nfrom rest_framework import status\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\n# local\nfrom alerts.models import Alert\nfrom .serializers import SubscribeSerializer\nfrom .signals import send_push_notifications\n\nLEVEL_IMAGES = {\n    'CRITICAL': '/assets/img/cyphon-push-notification-critical.png',\n    'HIGH': '/assets/img/cyphon-push-notification-high.png',\n    'MEDIUM': '/assets/img/cyphon-push-notification-medium.png',\n    'LOW': '/assets/img/cyphon-push-notification-low.png',\n    'INFO': '/assets/img/cyphon-push-notification-info.png'\n}\n\n\nclass SubscribeView(APIView):\n    \"\"\"\n    View that allows a user to subscribe to push notifications\n    \"\"\"\n    serializer_class = SubscribeSerializer\n    permission_classes = [IsAuthenticated, ]\n\n    def post(self, request):\n        \"\"\"\n        Subscribes a user to push notifications\n        \"\"\"\n        serializer = SubscribeSerializer(data=request.data)\n\n        if serializer.is_valid() and request.user.is_authenticated:\n            user = request.user\n            user.push_notification_id = serializer.data['registration_id']\n            try:\n                user.save()\n                return Response(status.HTTP_202_ACCEPTED)\n            except IntegrityError:\n                return Response(serializer.errors, status.HTTP_406_NOT_ACCEPTABLE)\n        else:\n            return Response(\n                serializer.errors,\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n\nclass NotificationView(APIView):\n    \"\"\"\n    View that allows a user to get notification data relavent to them.\n    \"\"\"\n    permission_classes = []\n    authentication_classes = []\n\n    def get(self, request):\n        \"\"\"\n        Creates and returns a notification object for push notifications.\n        \"\"\"\n        registration_id = request.query_params.get('registration_id')\n\n        # If there was no registration id sent with the request, return a\n        # 400 error.\n        if not registration_id:\n            return Response({\n                'errors': ['registration_id parameter was not given']\n            }, status=status.HTTP_400_BAD_REQUEST)\n\n        user_model = get_user_model()\n\n        # Check if there is a user with the registration id. If there isn't,\n        # return a 400 error.\n        try:\n            user = user_model.objects.get(push_notification_id=registration_id)\n        except ObjectDoesNotExist:\n            return Response({\n                'errors': ['registration_id is not valid']\n            }, status=status.HTTP_400_BAD_REQUEST)\n\n        new_alerts = Alert.objects.filter(status='NEW')\n        alerts_for_user = Alert.objects.filter_by_user(user, new_alerts)\n        alert = alerts_for_user.first()\n\n        # If there is no alert classified as new, return a 404 error.\n        if not alert:\n            return Response({\n                'errors': ['alert object not present']\n            }, status=status.HTTP_404_NOT_FOUND)\n\n        notification = {\n            'title': '{}: {}'.format(alert.level, alert.distillery),\n            'tag': 'cyphon-alert-{}'.format(alert.id),\n            'message': alert.title,\n            'icon': LEVEL_IMAGES[alert.level]\n        }\n\n        return Response(notification)\n\n\nclass TestNotifications(APIView):\n    \"\"\"\n    View specifically used to test notifications on the server.\n    \"\"\"\n\n    def get(self, request):\n        \"\"\"\n        Sends a push notication.\n        \"\"\"\n        send_push_notifications()\n        return Response()\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "parsers/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, null, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null], "name": "parsers/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin for a FieldParser.\n\"\"\"\n\n# third party\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.admin import ConfigToolAdmin, CONFIG_TOOL_CLASSES\nfrom cyphon.forms import CONFIG_TOOL_INPUTS\nfrom .forms import ParserForm\n\n\nclass ParserAdmin(ConfigToolAdmin):\n    \"\"\"\n    Customizes admin pages for DataParsers.\n    \"\"\"\n    list_display = [\n        'name',\n        'method',\n        'regex',\n        'formatter',\n    ]\n    list_display_links = ['name', ]\n    fieldsets = (\n        ('Test this parser', {\n            'classes': CONFIG_TOOL_CLASSES,\n            'description': _('Enter a test string and click \"Run test\" '\n                             'to check what the parser will return '\n                             'for the string.'),\n            'fields': CONFIG_TOOL_INPUTS,\n        }),\n        (None, {\n            'fields': [\n                'name',\n                'method',\n                'regex',\n                'formatter',\n            ]\n        }),\n    )\n    save_as = True\n    form = ParserForm\n\n\nclass FieldParserAdmin(ConfigToolAdmin):\n    \"\"\"\n    Customizes admin pages for DataParsers.\n    \"\"\"\n    list_display = [\n        'name',\n        'source_fields',\n        'method',\n        'regex',\n        'formatter',\n    ]\n    list_display_links = ['name', ]\n    fieldsets = (\n        ('Test this parser', {\n            'classes': CONFIG_TOOL_CLASSES,\n            'description': _('Enter a test string and click \"Run test\" '\n                             'to check what the parser will return '\n                             'for the string.'),\n            'fields': CONFIG_TOOL_INPUTS,\n        }),\n        (None, {\n            'fields': [\n                'name',\n                'source_fields',\n                'method',\n                'regex',\n                'formatter',\n            ]\n        }),\n    )\n    form = ParserForm\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, null, null], "name": "parsers/forms.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines forms for Parsers.\n\"\"\"\n\n# local\nfrom cyphon.forms import ConfigToolForm\n\n\nclass ParserForm(ConfigToolForm):\n    \"\"\"\n    Defines a form for adding or updating a Parser.\n    \"\"\"\n    pass\n\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, 1, null, null, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, 0, null, 1, 1, null, 1, 1, 1, null, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, null, 1, 1, 1, 1, 0, 0, null, null, 1, null, 1, null, null, null, 0, 0, 0, null, 1, null, null, null, 1, null, 1, null, null, null, 1, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, 0, 0, null, 1, null, null, null, null, 0, 0, null, 0, null, 1, null, null, null, 1, null, 1, 0, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, 1, null, 1, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, 1, 1, null, 1, null, null, null, 1, 1, 1, null, null, 0, null, 1, null, null, null, null, 1, 1, null, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, 1, 1, 1, null, 1, null, null, null, null, null, 1, 0, 1, 0, null, 1, null, 1, null, null, null, null, null, null, null, null, 1, 1, 0, 0, null, 0, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, 1, 1, 1, 1, null], "name": "parsers/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Parser mixin for obtaining matches for regular expressions.\n\"\"\"\n\n# standard library\nimport logging\nimport re\n\n# third party\nfrom django.db import models\nfrom django.core.exceptions import ValidationError\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom utils.dateutils import dateutils\nfrom utils.parserutils import parserutils\nfrom utils.validators import validators\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass Parser(models.Model):\n    \"\"\"\n    An abstract base class for parsing a value from an object, such as a string\n    or dictionary.\n\n    Attributes:\n        formatter: a template that will be used to format the parsed value,\n            For example, 'https://twitter.com/{}/' may be used to construct a\n            link to a Twitter profile.\n        regex: a string representing a pattern to be compiled as a regular\n            expression\n        method: a string specifying the form of a result to be obtained from a\n            regex search, e.g., the number of matches, presence/absence of a\n            match, or the value of a substring from the first match\n    \"\"\"\n    METHOD_CHOICES = (\n        ('COPY', 'Copy'),\n        ('COUNT', 'Number of Occurrences'),\n        ('DATE', 'Date from string'),\n        ('P/A', 'Presence/Absence'),\n        ('SUBSTRING', 'Substring'),\n    )\n\n    name = models.CharField(\n        max_length=255,\n        unique=True,\n        help_text=_('It\\'s a good idea to name parsers after the source '\n                    'field(s) they are parsing and the method they use, e.g., '\n                    '\"screen_name__COPY.\"')\n    )\n    method = models.CharField(\n        max_length=40,\n        choices=METHOD_CHOICES,\n        default='COPY',\n        help_text=_('The method used to extract data. \"Copy\" will return the '\n                    'entire contents of the source field(s). \"Number of '\n                    'Occurrences\" will return the number of times a match for '\n                    'the regex is found in the source field(s). \"Presence/'\n                    'Absence\" will return a Boolean indicating whether a regex '\n                    'match is found. \"Substring\" will return the first '\n                    'substring group defined in the Parser\\'s regex.')\n    )\n    regex = models.CharField(\n        max_length=255,\n        blank=True,\n        null=True,\n        default=None,\n        validators=[validators.regex_validator],\n        help_text=_('A regular expression used to match substrings in the '\n                    'text of the source field(s). Not required if the method '\n                    'is \"Copy.\"')\n    )\n    formatter = models.CharField(\n        max_length=255,\n        blank=True,\n        null=True,\n        default=None,\n        help_text=_('A Python format string that will be used to format the '\n                    'parsed value. For example, \"https://twitter.com/{}/\" '\n                    'may be used to construct a link to a Twitter profile. ')\n    )\n\n    class Meta:\n        abstract = True\n\n    def __str__(self):\n        return self.name\n\n    def clean(self):\n        super(Parser, self).clean()\n\n        if self.method not in ['COPY', 'DATE'] and not self.regex:\n            method_name = self.get_method_display()\n            raise ValidationError(_('A regex must be provided to use the '\n                                    '%s method.' % method_name))\n\n    def _search(self, string):\n        \"\"\"\n        Takes a string and returns a re.MatchObject for the Parser's regex.\n        \"\"\"\n        # TODO(LH): catch exceptions for malformed regex\n        return re.search(self.regex, string, re.DOTALL | re.IGNORECASE)\n\n    def _is_present(self, string):\n        \"\"\"\n        Takes a string and returns a Boolean indicating whether the string\n        contains a match for the Parser's regex.\n        \"\"\"\n        matches = self._search(string)\n        if matches:\n            return True\n        return False\n\n    def _get_substring(self, string):\n        \"\"\"\n        Takes a string and, if the string contains a match for the Parser's\n        regex, returns the first substring group defined in the Parser's regex.\n        Otherwise, returns None.\n        \"\"\"\n        match = self._search(string)\n        if match:\n            try:\n                return match.group(1)\n            except IndexError:\n                LOGGER.error('The parser cannot return a value because no '\n                             'group is defined in the r\\'%s\\'regex pattern.',\n                             self.regex)\n        return None\n\n    def _get_date(self, string):\n        \"\"\"\n        Converts a string into a datetime object.\n        \"\"\"\n        if self.regex:\n            string = self._get_substring(string)\n        return dateutils.date_from_str(string)\n\n    def _findall(self, string):\n        \"\"\"\n        Takes a string and returns a list of strings matching the Parser's regex.\n        \"\"\"\n        return re.findall(self.regex, string, re.DOTALL | re.IGNORECASE)\n\n    def _get_count(self, string):\n        \"\"\"\n        Takes a string and returns the number of matches for the Parser's regex.\n        \"\"\"\n        matches = self._findall(string)\n        return len(matches)\n\n    def _parse(self, value):\n        \"\"\"\n        Takes a string and returns a parsing result according to the Parser's\n        method.\n        \"\"\"\n        if self.method == 'COPY':\n            return value\n        else:\n            methods = {\n                'COUNT': self._get_count,\n                'P/A': self._is_present,\n                'SUBSTRING': self._get_substring,\n                'DATE': self._get_date,\n            }\n\n            func = methods[self.method]\n            return func(str(value))\n\n    def _format(self, result):\n        \"\"\"\n\n        \"\"\"\n        template = self.formatter\n        return template.format(result)\n\n    def _apply_template(self, result):\n        \"\"\"\n        Takes a result string and returns a string that formats the result\n        with the Parser's formatter.\n        \"\"\"\n        if isinstance(result, list):\n            return [self._format(item) for item in result]\n        else:\n            return self._format(result)\n\n    def process(self, value):\n        \"\"\"\n        Takes a value and returns a parsed result.\n        \"\"\"\n        result = self._parse(value)\n\n        if self.formatter and self.method != 'DATE':\n            return self._apply_template(result)\n        else:\n            return result\n\n\nclass StringParser(Parser):\n    \"\"\"\n    A StringParser provides proper validation for parsing and formatting strings.\n    \"\"\"\n\n    def clean(self):\n        \"\"\"\n        Adds custom validations to the model's clean() method.\n        \"\"\"\n        super(StringParser, self).clean()\n\n        validators.validate_str_substitution(self.formatter, 1)\n\n    class Meta:\n        abstract = True\n\n\nclass FieldParser(Parser):\n    \"\"\"\n    A FieldParser is a Parser designed to parse objects that contain fields\n    accessible through dictionary keys. It extends the Parser class with the\n    source_fields attribute:\n\n    Attribute:\n        source_fields: comma-separated field names from a dictionary that will\n            be used to assemble a value for a field in a custom object (defined\n            by a DataField). For example, 'user.screen_name,id_str' may be\n            used to construct a link to a tweet.\n\n    \"\"\"\n    source_fields = models.CharField(\n        max_length=255,\n        verbose_name=_('source field(s)'),\n        help_text=_('One or more fields in a raw data document from which '\n                    'data will be extracted. Multiple field names should be '\n                    'separated by commas. Nested fields should be denoted using '\n                    'dot notation. For example, \"user.first_name,user.last_name\" '\n                    'will parse the fields {user: {first_name: \"Jane\", '\n                    'last_name: \"Smith\"}}.')\n    )\n\n    class Meta:\n        abstract = True\n\n    def clean(self):\n        \"\"\"\n        Adds custom validations to the model's clean() method.\n        \"\"\"\n        super(FieldParser, self).clean()\n        self._validate_formatter()\n\n    def _validate_formatter(self):\n        \"\"\"\n        Ensures that the formatter can accomodate the number of source_fields.\n        \"\"\"\n        if self.method in ['COPY', 'SUBSTRING']:\n            fields = self.source_fields.split(',')\n            validators.validate_str_substitution(self.formatter, len(fields))\n        else:\n            # for COUNT and P/A, results will be aggregated into one value\n            validators.validate_str_substitution(self.formatter, 1)\n\n    def _get_values(self, doc):\n        \"\"\"\n        Takes a dictionary and returns values for the keys specified by the\n        source_fields.\n        \"\"\"\n        fields = self.source_fields.split(',')\n        values = []\n\n        for field in fields:\n            key = field.strip() # in case there were spaces after commas\n            value = parserutils.get_dict_value(key, doc)\n            values.append(value)\n\n        return values\n\n    def _parse_all(self, values):\n        \"\"\"\n        Takes a list of values and returns a list of parsing results\n        according to the Parser's method.\n        \"\"\"\n        parsed_values = []\n        for value in values:\n            new_value = self._parse(value)\n            parsed_values.append(new_value)\n        return parsed_values\n\n    def _aggregate(self, parsed_results):\n        \"\"\"\n        Takes a list of parsed results. If the Parser's method is COUNT or P/A,\n        aggregates the results into a single-item list. Otherwise, returns the\n        original list.\n        \"\"\"\n        if self.method == 'COUNT':\n            return [sum(parsed_results)]\n        elif self.method == 'P/A':\n            return [True in parsed_results]\n        else:\n            return parsed_results\n\n    @staticmethod\n    def _extract_result(aggregated_results):\n        \"\"\"\n        Takes a list of aggregated_results, and returns either a single result\n        or a list of results, depending on the length of the original list.\n        If more than one result is contained in the list, returns the orginal\n        list. If only one result is in the list, returns that result. If no\n        results are contained in the list, returns an empty string.\n        \"\"\"\n        if len(aggregated_results) == 1:\n            return aggregated_results[0]\n        elif len(aggregated_results) > 1:\n            return aggregated_results\n        else:\n            return ''\n\n    def _apply_template(self, aggregated_results):\n        \"\"\"\n        Takes a list of results and returns a string that formats the results\n        with the Parser's formatter.\n        \"\"\"\n        template = self.formatter\n        return template.format(*aggregated_results)\n\n    def _format(self, aggregated_results):\n        \"\"\"\n        Takes a list of aggregated_results and formats them with the\n        formatter if one is provided. Otherwise, formats them according to\n        how many results are returned.\n        \"\"\"\n        if self.formatter:\n            return self._apply_template(aggregated_results)\n        else:\n            return self._extract_result(aggregated_results)\n\n    def process(self, doc):\n        \"\"\"\n        Takes a dictionary and returns a parsed result from the dictionary.\n        \"\"\"\n        values = self._get_values(doc)\n        parsed_results = self._parse_all(values)\n        aggregated_results = self._aggregate(parsed_results)\n        return self._format(aggregated_results)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1], "name": "platforms/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\nfrom pkgutil import extend_path\n\n# import all subpackages (twitter, facebook, etc.)\n__path__ = extend_path(__path__, __name__)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "platforms/apihandler.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n# \"\"\"\n# Defines a base class for API handler classes.\n# \"\"\"\n\n# # third party\n# from django.utils.functional import cached_property\n\n# # local\n# from aggregator.funnels.models import Funnel\n# from cyphon.baseclass import BaseClass\n# from warehouses.models import Warehouse, Collection\n\n\n# class ApiResponse(object):\n#     \"\"\"\n#     Describes an API response.\n#     \"\"\"\n#     def __init__(self, status_code=None, data=None):\n#         self.status_code = status_code\n#         self.data = data or []\n\n\n# class ApiHandler(BaseClass):\n#     \"\"\"\n#     Base class for handling social media APIs.\n\n#     Attributes:\n#         emissary: a Plumber object for providing a KeySet and Meter for the API\n#         task: the task that should be performed\n\n#         distillery: a Distillery object for saving data from the API\n\n#     \"\"\"\n\n#     def __init__(self, emissary, porter):\n#         self.emissary = emissary\n#         # self.task = task\n#         self.porter = None # handles result\n\n#     # def __str__(self):\n#     #     return 'distillery_%s__emissary_%s' % (self.distillery.pk,\n#     #                                           self.emissary.pk)\n#     # @cached_property\n#     # def __keyset(self):\n#     #     \"\"\"\n#     #     Returns the KeySet used to access the API.\n#     #     \"\"\"\n#     #     return self.emissary.keyset\n\n#     # @property\n#     # def keyset(self):\n#     #     \"\"\"\n#     #     Returns the Condenser used to store data from the API in the\n#     #     Distillery's Bottle.\n#     #     \"\"\"\n#     #     return self.__keyset\n\n#     @cached_property\n#     def __bottle(self):\n#         \"\"\"\n#         Returns the Bottle used to store distilled data from the API.\n#         \"\"\"\n#         return self.distillery.get_bottle()\n\n#     @cached_property\n#     def __distillery_warehouse(self):\n#         \"\"\"\n#         Returns the Warehouse used to store distlled data from the API.\n#         \"\"\"\n#         return self.distillery.warehouse\n\n#     @cached_property\n#     def __raw_data_warehouse(self):\n#         \"\"\"\n#         Returns the Warehouse used to store raw data from the API.\n#         \"\"\"\n#         # if fields with the same name can potentially store different\n#         # data types, just store raw data in the same warehouse\n#         # as distilled data\n#         if self.__allow_multiple_mappings():\n#             return self.__distillery_warehouse\n\n#         # otherwise, raw data needs to be saved in a separate warehouse,\n#         # to avoid potential mapping conflicts between raw data fields\n#         # and distilled data fields\n#         else:\n#             kwargs = {\n#                 'backend': self.__get_backend(),\n#                 'name': self.data_source_label\n#             }\n#             try:\n#                 warehouse = Warehouse.objects.get(**kwargs)\n#             except Warehouse.DoesNotExist:\n#                 warehouse = Warehouse(**kwargs)\n#                 warehouse.save()\n#             return warehouse\n\n#     def __get_backend(self):\n#         \"\"\"\n#         Returns the platform used to store data from the API. This could\n#         be a database platform (such as MongoDB) or a search engine\n#         (such as Elasticsearch).\n#         \"\"\"\n#         return self.__distillery_warehouse.backend\n\n#     def __allow_multiple_mappings(self):\n#         \"\"\"\n#         Returns a Boolean indicating whether the Warehouse used to store\n#         data can accomodate fields that have the same field name but a\n#         different field type.\n#         \"\"\"\n#         warehouse = self.__distillery_warehouse\n#         engine_module = warehouse.get_module()\n#         return engine_module.MULTIPLE_FIELD_NAME_MAPPINGS\n\n#     @cached_property\n#     def __condenser(self):\n#         \"\"\"\n#         Returns the Condenser used to store data from the API in the\n#         Distillery's Bottle.\n#         \"\"\"\n#         pipe_natural_key = self.pipe_natural_key\n#         bottle = self.__bottle\n#         condenser = Funnel.objects.get_condenser(\n#             bottle_id=bottle,\n#             pipe_natural_key=pipe_natural_key\n#         )\n#         return condenser\n\n#     @property\n#     def condenser(self):\n#         \"\"\"\n#         Returns the Condenser used to store data from the API in the\n#         Distillery's Bottle.\n#         \"\"\"\n#         return self.__condenser\n\n#     def __get_emissary_name(self):\n#         \"\"\"\n#         Returns the name of the Plumber used to access the API.\n#         \"\"\"\n#         return self.emissary.name\n\n#     @property\n#     def pipe_natural_key(self):\n#         \"\"\"\n#         Returns a tuple representing the natural key for a Pipe.\n\n#         The key is assembled from the name of the class handling the API\n#         request and the name of the module in which the class resides.\n#         \"\"\"\n#         module_name = self.__module__\n#         names = module_name.split('.')\n#         package_name = names[-2]\n#         class_name = type(self).__name__\n\n#         return (package_name, class_name)\n\n#     @property\n#     def data_source_label(self):\n#         \"\"\"\n#         Returns a string representing the platform package and class used\n#         to access the API, formatted for use as the name of a database,\n#         index, collection, or doctype.\n#         \"\"\"\n#         keys = [self.pipe_natural_key[0], self.pipe_natural_key[1]]\n#         name = '_'.join(keys)\n#         return name.lower()\n\n#     @property\n#     def raw_data_collection(self):\n#         \"\"\"\n#         Returns a Collection in which to save raw data from the API.\n#         \"\"\"\n#         return Collection(\n#             warehouse=self.__raw_data_warehouse,\n#             name=self.data_source_label\n#         )\n\n#     def _format_query(self, query):\n#         \"\"\"\n#         Takes a ReservoirQuery object and constructs a dictionary of\n#         Twitter keyword arguments to use with the Twitter API.\n#         \"\"\"\n#         return self._raise_method_not_implemented()\n\n#     def __save_distilled_data(self, data, doc_id):\n#         \"\"\"\n#         Takes a dictionary of data, the primary key of the Condenser\n#         that should be used to distill the data, and the document id for\n#         the document that contains the data, and a string representing\n#         the Collection in which the raw data is stored. Adds the\n#         document id and the name of the platform from which the data are\n#         derived to the data dictionary. Saves the new dictiomary to a\n#         database collection in a distilled form. The database collection\n#         and the distilled form are determined by the ApiHandler's\n#         Distillery.\n#         \"\"\"\n#         return self.distillery.save_data(data, self.__condenser, doc_id,\n#                                          str(self.raw_data_collection))\n\n#     def __save_raw_data(self, data):\n#         \"\"\"\n#         Takes a dictionary of data and saves it to the database collection\n#         assigned to the API platform.\n#         \"\"\"\n#         return self.raw_data_collection.insert(data)\n\n#     def save_data(self, data):\n#         \"\"\"\n#         Takes a dictionary and saves it in its raw form in the database\n#         collection for the platform, and saves it in its distilled form\n#         in the database collection used by the ApiHandler's Distillery.\n#         Returns the document id of the saved distilled document.\n#         \"\"\"\n#         # get DataChutes\n\n#         doc_id = self.__save_raw_data(data)\n#         return self.__save_distilled_data(data, doc_id)\n\n#     def bulk_save_data(self, results):\n#         \"\"\"\n#         Takes a list of dictionaries and saves them to database collections\n#         in raw and distilled forms. Returns a list of document ids for the\n#         distilled documents.\n#         \"\"\"\n#         doc_ids = []\n\n#         for data in results:\n#             doc_id = self.save_data(data)\n#             doc_ids.append(doc_id)\n\n#         return doc_ids\n\n#     def process_query(self, query):\n#         \"\"\"\n#         Takes a ReservoirQuery and submits it to the API. If the handler is for\n#         a non-streaming API, returns an ApiResponse object. This method needs to\n#         be implemented in derived classes so it can be customized for specific\n#         APIs.\n#         \"\"\"\n#         return self.raise_method_not_implemented()\n\n#     def process_response(self, results):\n#         \"\"\"\n\n#         \"\"\"\n#         pass\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "platforms/jira/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, 1, null, 1, null, null, 1, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, null, 1, 1, 1, 1, 1, 1, null, 1, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, null, null, 1, 1, 1, 1, 1, null, 1, null, null, null, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, 1, null, 0, null, 1, null, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, null, 1, null, 1, null, null, null, 1, 1, null, 1, null, null, null, null, 1, 1, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, 1, 1, 1, 1, null, 1], "name": "platforms/jira/handlers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines classes for JIRA actions.\n\"\"\"\n\n# standard library\nimport urllib\n\n# third party\nfrom django.conf import settings\nimport jira\n\n# local\nfrom ambassador.transport import Cargo\nfrom responder.carrier import Carrier\n\n_JIRA_SETTINGS = settings.JIRA\n\n\nclass JiraHandler(Carrier):\n    \"\"\"\n    Base class for interacting with JIRA APIs.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super(JiraHandler, self).__init__(*args, **kwargs)\n        self.server = _JIRA_SETTINGS['SERVER']\n        self.authed_jira = self._authenticate()\n\n    def _get_oauth_dict(self):\n        \"\"\"\n        Returns a dictionary of credentials for JIRA authentication.\n        \"\"\"\n        consumer_key = self.get_key()\n        key_cert_data = self.get_key_cert()\n        access_token = self.get_access_token()\n        access_token_secret = self.get_access_token_secret()\n\n        return {\n            'access_token': access_token,\n            'access_token_secret': access_token_secret,\n            'consumer_key': consumer_key,\n            'key_cert': key_cert_data\n        }\n\n    def _authenticate(self):\n        \"\"\"\n        Method for authenticating with a Twitter API.\n        \"\"\"\n        oauth_dict = self._get_oauth_dict()\n        return jira.JIRA(server=self.server, oauth=oauth_dict)\n\n\nclass IssueAPI(JiraHandler):\n    \"\"\"\n    Class for accessing the JIRA Isssue API.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super(IssueAPI, self).__init__(*args, **kwargs)\n        self._issue_type = _JIRA_SETTINGS['ISSUE_TYPE']\n        self._project_key = _JIRA_SETTINGS['PROJECT_KEY']\n        self._custom_fields = _JIRA_SETTINGS['CUSTOM_FIELDS']\n        self._jira_user = self._get_jira_user()\n\n    def _get_jira_user(self):\n        \"\"\"\n        Attempts to return a JIRA user Resource associated with the\n        current user. Returns None if unsuccessful.\n        \"\"\"\n        if self.user is not None:\n            users = self.authed_jira.search_users(self.user.email)\n            if len(users) == 1:\n                return users[0]\n\n    @staticmethod\n    def _format_code_block(text):\n        \"\"\"\n        Takes a string and returns it with a styled code block that can\n        be read by JIRA. Style rules are defined by the STYLE_PARAMS\n        setting of Cyphon's JIRA configuration.\n        \"\"\"\n        param_dict = _JIRA_SETTINGS['STYLE_PARAMS']\n        sorted_params = sorted(param_dict.items())  # makes testing easier\n        param_list = ['='.join([key, val]) for (key, val) in sorted_params]\n        param_str = '|'.join(param_list)\n        return '\\n'.join(['{code:' + param_str + '}', text, '{code' + '}'])\n\n    def _format_full_descr(self, alert):\n        \"\"\"\n        Takes an Alert and formats it for the description field of a\n        JIRA issue.\n        \"\"\"\n        include_empty = _JIRA_SETTINGS['INCLUDE_EMPTY_FIELDS']\n        include_comments = _JIRA_SETTINGS['INCLUDE_ALERT_COMMENTS']\n        summary = alert.summary(include_empty=include_empty,\n                                include_comments=include_comments)\n        return self._format_code_block(summary)\n\n    def _format_description(self, alert):\n        \"\"\"\n        Takes an Alert and formats it for the description field of a\n        JIRA issue.\n        \"\"\"\n        full_descr = _JIRA_SETTINGS['INCLUDE_FULL_DESCRIPTION']\n        if full_descr:\n            return self._format_full_descr(alert)\n        elif alert.notes:\n            return alert.notes\n        else:\n            return ''\n\n    @staticmethod\n    def _format_summary(alert):\n        \"\"\"\n        Takes an Alert and formats its title for the summary field of a\n        JIRA issue.\n        \"\"\"\n        if alert.title:\n            return alert.title.replace('\\n', ' ').strip()\n        else:\n            return 'Cyphon alert'\n\n    @staticmethod\n    def _get_priority_name(alert):\n        \"\"\"\n        Takes an Alert and returns the name to use for the priority\n        field of the JIRA issue.\n        \"\"\"\n        priorities = _JIRA_SETTINGS['PRIORITIES']\n        default_level = _JIRA_SETTINGS['DEFAULT_PRIORITY']\n        return priorities.get(alert.level, default_level)\n\n    def _format_issue(self, alert):\n        \"\"\"\n        Takes an Alert and returns a dictionary of fields to create a\n        JIRA issue.\n        \"\"\"\n        issue_description = self._format_description(alert)\n        summary = self._format_summary(alert)\n        priority_name = self._get_priority_name(alert)\n\n        fields = {\n            'project': {\n                'key': _JIRA_SETTINGS['PROJECT_KEY']\n            },\n            'summary': summary,\n            'description': issue_description,\n            'issuetype': {\n                'name': _JIRA_SETTINGS['ISSUE_TYPE']\n            },\n            'priority': {'name': priority_name},\n        }\n\n        fields.update(_JIRA_SETTINGS['CUSTOM_FIELDS'])\n\n        if self._jira_user is not None:\n            fields['reporter'] = {'name': self._jira_user.name}\n\n        return fields\n\n    def _get_issue_url(self, issue):\n        \"\"\"\n        Takes a JIRA issue Resource and returns a URL for the issue.\n        \"\"\"\n        base_url = urllib.parse.urljoin(self.server, 'browse/')\n        return urllib.parse.urljoin(base_url, issue.raw['key'])\n\n    def _format_results(self, issue):\n        \"\"\"\n        Takes a JIRA issue Resource and returns a dictionary of fields\n        for referencing the issue.\n        \"\"\"\n        data = issue.raw\n        return {\n            'key': data['key'],\n            'issue_id': data['id'],\n            'created': data['fields']['created'],\n            'url': self._get_issue_url(issue),\n        }\n\n    def _add_comment(self, issue, body):\n        \"\"\"\n        Takes an Alert, creates a JIRA issue, and returns the JIRA issue\n        Resource.\n        \"\"\"\n        kwargs = {\n            'issue': issue,\n            'body': body,\n        }\n\n        visibility = _JIRA_SETTINGS.get('COMMENT_VISIBILITY')\n        if visibility:\n            kwargs.update({'visibility': visibility})\n\n        self.authed_jira.add_comment(**kwargs)\n\n    def _create_issue(self, alert):\n        \"\"\"\n        Takes an Alert, creates a JIRA issue, and returns the JIRA issue\n        Resource.\n        \"\"\"\n        issue_dict = self._format_issue(alert)\n        issue = self.authed_jira.create_issue(fields=issue_dict)\n\n        if _JIRA_SETTINGS['INCLUDE_ALERT_LINK']:\n            self._add_comment(issue=issue, body=alert.link)\n\n        return issue\n\n    def process_request(self, alert):\n        \"\"\"Create a JIRA issue for an Alert.\n\n        Parameters\n        ----------\n        alert : |Alert|\n            The |Alert| used to create the JIRA Issue.\n\n        Returns\n        -------\n        |Cargo|\n            The results of the API call to JIRA.\n\n        \"\"\"\n        try:\n            issue = self._create_issue(alert)\n            status_code = '200'\n            data = self._format_results(issue)\n            notes = None\n        except jira.exceptions.JIRAError as error:\n            status_code = str(error.status_code)\n            data = None\n            notes = error.text\n\n        return Cargo(status_code=status_code, data=data, notes=notes)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, 1, null, null, null, null, 1, null, null, 1, 1, null, null, null, null, 1, null], "name": "platforms/registry.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nProvides platform choices that can be used to limit choices for\nReservoirs and Destinations. Constructs choices from the names of\nsubpackages in the platforms package.\n\nAlso establishes constants for certain package and module names. These\nare used to import modules needed to handle queries to specific APIs.\n\"\"\"\n\n# standard library\nimport os\n\n# local\nfrom utils.choices import choices\n\n\ndef get_this_package():\n    \"\"\"\n    Returns the name of the package in which this module resides.\n    \"\"\"\n    current_path = os.path.dirname(__file__)\n    return os.path.basename(current_path)\n\n\n# The name of this package, which contains subpackages for specific social media\n# platforms.\nPLATFORMS_PACKAGE = get_this_package()\n\n# Packages for social media platforms that can be chosen as a Reservoir.\nABSOLUTE_PATH = os.path.dirname(os.path.abspath(__file__))\nPLATFORM_CHOICES = choices.get_package_choices(ABSOLUTE_PATH)\n\n# Standard name for a module in a platform package that handles\n# queries to APIs. These modules contain the classes associated with\n# Endpoints.\nHANDLERS_MODULE = 'handlers'\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "platforms/twitter/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, 1, 1, 1, 1, null, 1, null, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, 0, 0, 0, 0, null, 0, 0, 0, null, 0, null, null, 1, null, null, null, null, 1, null, null, null, null, null, 1, null, 1, 1, null, 1, 1, null, 1, null, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, 1, null, 1, null, null, null, null, null, 1, 1, 1, null, 1, 1, 1, null, 1, 1, null, 1, null, 1, 1, 1, null, 1, 1, 1, null, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, null, 1, 1, null, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, null, 1, 1, 1, null, 1, 1, 1, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, 1, null, 1, null, 1, null, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, 0, 0, 0, 0, null, 1, null, null, null, null, 0, null, 0, 0, 0, 0, 0, 0, null, 0, null, null, 1, null, null, null, null, 1, null, null, null, null, null, null, 1, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, null, 1, null, 1, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, 1, null, 1, 1, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, 0, 0, 0, 0, 0, null, 0, null, null, 0, null], "name": "platforms/twitter/handlers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines classes for Twitter searches.\n\"\"\"\n\n# standard library\nimport datetime\nimport logging\n\n# third party\nfrom django.conf import settings\nimport tweepy\n\n# local\nfrom platforms.twitter.listener import CustomStreamListener\nfrom aggregator.pumproom.faucet import Faucet\nfrom ambassador.transport import Cargo\nfrom utils.dateutils import dateutils as dt\nfrom .streaming import Stream\n\nLOGGER = logging.getLogger(__name__)\n\n# start the stream asynchronously, except when running test suite\nASYNC_STREAM = not settings.TEST\n\n\nclass TwitterHandler(Faucet):\n    \"\"\"\n    Base class for interacting with Twitter APIs.\n    \"\"\"\n\n    def authenticate(self):\n        \"\"\"\n        Method for authenticating with a Twitter API.\n        \"\"\"\n        consumer_key = self.get_key()\n        consumer_secret = self.get_secret()\n        access_token = self.get_access_token()\n        access_token_secret = self.get_access_token_secret()\n\n        auth = tweepy.OAuthHandler(consumer_key, consumer_secret)\n        auth.secure = True\n        auth.set_access_token(access_token, access_token_secret)\n\n        return auth\n\n\nclass SearchAPI(TwitterHandler):\n    \"\"\"\n    Class for accessing the Twitter Search API.\n    \"\"\"\n\n    @staticmethod\n    def _format_timeframe(timeframe):\n        \"\"\"\n        Takes a TimeFrame object and returns a string that formats the\n        start and end of the TimeFrame for a Twitter Search API request.\n        \"\"\"\n        dates = []\n\n        start = timeframe.start\n        end = timeframe.end\n\n        if start:\n            dates.append('since:' + dt.get_year_month_day(start))\n\n        if end:\n\n            # round up to the next day so we include the end date\n            delta = datetime.timedelta(days=1)\n            end += delta\n            dates.append('until:' + dt.get_year_month_day(end))\n\n        return u' '.join(dates)\n\n    @staticmethod\n    def _join_terms(terms):\n        \"\"\"\n        Takes a list of strings (terms). If there are multiple strings,\n        joins them with an \"OR\" operator for use with the Twitter Search\n        API, and returns them as a single string. Otherwise, returns the\n        single term as a string.\n        \"\"\"\n        if len(terms) > 1:\n            operator_str = ' OR '\n            joined_terms = operator_str.join(terms)\n            terms_str = '(' + joined_terms + ')'\n        else:\n            terms_str = terms[0]\n\n        return terms_str\n\n    def _format_searchterms(self, searchterms):\n        \"\"\"\n        Takes a list of SearchTerm objects and returns a string of\n        comma-separated values that format the SearchTerms for a Twitter\n        Search API request.\n        \"\"\"\n        included_terms = []\n        excluded_terms = []\n        all_terms = []\n\n        for searchterm in searchterms:\n            if searchterm.is_phrase():\n                searchterm.wrap_in_quotes()\n\n            if searchterm.negate:\n                excluded_terms.append('-' + searchterm.term)\n            else:\n                included_terms.append(searchterm.term)\n\n        if len(included_terms) > 0:\n            included_terms_str = self._join_terms(included_terms)\n            all_terms.append(included_terms_str)\n\n        if len(excluded_terms) > 0:\n            excluded_terms_str = (' ').join(excluded_terms)\n            all_terms.append(excluded_terms_str)\n\n        if len(all_terms) > 1:\n            return u' '.join(all_terms)\n        else:\n            return u''.join(all_terms)\n\n    def _format_accounts(self, accounts):\n        \"\"\"\n        Takes a list of Account objects and returns a string of\n        comma-separated values that format the Accounts for a Twitter\n        Search API request.\n        \"\"\"\n        accts = []\n\n        for accounts in accounts:\n            accts.append('@' + accounts.username)\n\n        if len(accts) > 1:\n            return self._join_terms(accts)\n        else:\n            return u''.join(accts)\n\n    def _format_q_param(self, query):\n        \"\"\"\n        Takes a list of SearchTerms and Accounts and returns a query\n        string of terms for the q parameter of a Twitter Search API\n        request.\n        \"\"\"\n        query_str = []\n\n        if query.searchterms:\n            terms = self._format_searchterms(query.searchterms)\n            query_str.append(terms)\n\n        if query.accounts:\n            accts = self._format_accounts(query.accounts)\n            query_str.append(accts)\n\n        if query.timeframe:\n            dates = self._format_timeframe(query.timeframe)\n            query_str.append(dates)\n\n        return u' '.join(query_str)\n\n    @staticmethod\n    def _format_geocode_param(location):\n        \"\"\"\n        Takes a circular Location object and returns a query string for\n        the location parameter of a Twitter Search API request.\n\n        The parameter value is specified by \"latitide,longitude,radius\",\n        where radius units must be specified as either \"mi\" (miles) or\n        \"km\" (kilometers), e.g., \"37.781157,-122.398720,1mi\".\n        \"\"\"\n        coords = location.geom.tuple\n\n        assert len(coords) == 2, 'Location must be a point'\n\n        return '%s,%s,%skm' % (location.geom.tuple[1],\n                               location.geom.tuple[0],\n                               location.radius_km)\n\n    def _format_query(self, query):\n        \"\"\"\n        Takes a ReservoirQuery object and constructs a dictionary of\n        keyword arguments to use with the Twitter API.\n        \"\"\"\n        kwargs = {\n            'q': self._format_q_param(query),\n            'result_type': 'recent'\n        }\n\n        if query.locations:\n            location = query.locations[0]\n            kwargs['geocode_param'] = self._format_geocode_param(location)\n\n        return kwargs\n\n    def _get_statuses(self, query):\n        \"\"\"\n        Takes a ReservoirQuery object and returns a tweepy Cursor of search\n        results.\n        \"\"\"\n        formatted_query = self._format_query(query)\n        auth = self.authenticate()\n        api = tweepy.API(auth)\n        return tweepy.Cursor(api.search, **formatted_query)\n\n    def process_request(self, query):\n        \"\"\"\n        Takes a ReservoirQuery, formats and submits it to the API, and\n        returns a Cargo object.\n        \"\"\"\n        try:\n            # TODO(LH): handle rate limit\n            cursor = self._get_statuses(query)\n            data = [status._json for status in cursor.items()]\n            status_code = 200\n        except tweepy.TweepError as error:\n            data = []\n            status_code = error.api_code\n\n        return Cargo(status_code=status_code, data=data)\n\n\nclass PublicStreamsAPI(TwitterHandler):\n    \"\"\"\n    Class for accessing the Twitter Streaming API.\n    \"\"\"\n\n    @staticmethod\n    def _format_followees_param(accounts):\n        \"\"\"\n        Takes a list of Account objects and returns a list of user IDs,\n        indicating the users whose Tweets should be delivered on the\n        stream.\n        \"\"\"\n        accts = []\n\n        for account in accounts:\n            accts.append(str(account.user_id))\n\n        return accts\n\n    @staticmethod\n    def _format_locations_param(locations):\n        \"\"\"\n        Takes a list of Location objects and returns a list of\n        longitude,latitude pairs specifying a set of bounding boxes to\n        filter tweets, e.g., [-122.75,36.8,-121.75,37.8,-74,40,-73,41].\n        Only geolocated tweets falling within the requested bounding\n        boxes will be included; unlike the Search API, the user's\n        location field is not used to filter tweets.\n        \"\"\"\n        locs = []\n\n        for location in locations:\n            polygon = location.bbox\n            extent = list(polygon.extent)\n            locs.extend(extent)\n\n        return locs\n\n    @staticmethod\n    def _format_searchterms_param(searchterms):\n        \"\"\"\n        Takes a list of SearchTerm objects and returns a list of phrases\n        which will be used to determine what Tweets will be delivered on\n        the stream.\n        \"\"\"\n        terms = []\n\n        for searchterm in searchterms:\n            if searchterm.is_phrase():\n                searchterm.wrap_in_quotes()\n            if not searchterm.negate:\n                terms.append(searchterm.term)\n\n        return terms\n\n    def _format_query(self, query):\n        \"\"\"\n        Takes a ReservoirQuery object and constructs a dictionary of\n        Twitter keyword arguments to use with the Twitter API.\n        \"\"\"\n        kwargs = {}\n\n        if query.accounts:\n            kwargs['follow'] = self._format_followees_param(query.accounts)\n        if query.locations:\n            kwargs['locations'] = self._format_locations_param(query.locations)\n        if query.searchterms:\n            kwargs['track'] = self._format_searchterms_param(query.searchterms)\n\n        return kwargs\n\n    def process_request(self, query):\n        \"\"\"\n        Method for processing a query with the Twitter Public Streams\n        API.\n        \"\"\"\n        auth = self.authenticate()\n        listener = CustomStreamListener(faucet=self)\n        stream = Stream(auth, listener)\n        kwargs = self._format_query(query)\n        stream.filter(**kwargs)\n\n        LOGGER.info('Received %s objects from Twitter and saved %s of them',\n                    stream.listener.data_count, stream.listener.saved_data_count)\n\n        return Cargo(status_code=listener.status_code, notes=listener.notes)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, null, 1, null, 1, 1, null, null, 1, 1, null, 0, null, null, 1, null, null, null, null, 1, 0, 0, 0, 0, 0, 0, null, 1, null, null, null, null, null, null, 0, 0, 0, 0, null, null, 0, 0, null, null, 0, null, 1, null, null, null, null, null, 0, 0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, null, 0, null, 0, 0, null, 1, null, 0, null, 1, null, 0, null, 1, null, 0, 0, 0, 0, null, 1, null, null, null, 0, 0, null, 1, null, 0, null, 1, null, 0, null, 1, null, null, null, null, 0, null, 1, null, 0, 0, null, 1, null, 0, 0, 0, 0, 0, null, 1, null, 0, 0, 0, 0, null, 1, null, null, null, null, null, 0, 0, 0, 0, null, 1, null, 0, 0, null], "name": "platforms/twitter/listener.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a custom listener for a Twitter Stream.\n\"\"\"\n\n# standard\nimport json\nimport logging\n\n# third party\nfrom django.conf import settings\nfrom tweepy.streaming import StreamListener\n\nLOGGER = logging.getLogger(__name__)\n\nDATA_LIMIT = float('inf')\nTEST_LIMIT = 10     # number of tweets to save while running tests\n\n# if running tests, use test limit\nif settings.TEST:\n    LIMIT = TEST_LIMIT\nelse:\n    LIMIT = DATA_LIMIT\n\n\nclass CustomStreamListener(StreamListener):\n    \"\"\"\n    A listener handles tweets as they are received from the stream.\n    This is a basic listener that just prints received tweets to stdout.\n    \"\"\"\n    def __init__(self, faucet):\n        super(CustomStreamListener, self).__init__()\n        self.faucet = faucet\n        self.status_code = None\n        self.notes = None\n        self.data_count = 0\n        self.saved_data_count = 0\n\n    def _process_response(self, data):\n        \"\"\"\n        Takes data received from a Twitter Stream and saves it using the\n        CustomStreamListener's api_handler. If the DATA_LIMIT has been reached,\n        return False to stop the stream. Otherwise returns the doc_id of the\n        distilled data.\n        \"\"\"\n        self.status_code = '200'\n        self.faucet.load_cargo([data])\n        self.faucet.process_results()\n        self.saved_data_count += 1\n\n        # disconnect the stream if another stream has been started\n        if self.faucet.is_obsolete():\n            return False\n        else:\n            # disconnect the stream if enough data has been gathered\n            return self.saved_data_count < LIMIT\n\n    def on_data(self, raw_data):\n        \"\"\"Called when raw data is received from connection.\n\n        Override this method if you wish to manually handle\n        the stream data. Return False to stop stream and close connection.\n        \"\"\"\n        try:\n            data = json.loads(raw_data)\n            self.data_count += 1\n\n            if 'in_reply_to_status_id' in data:\n                return self.on_status(data)\n            elif 'delete' in data:\n                delete = data['delete']['status']\n                return self.on_delete(delete['id'], delete['user_id'])\n            elif 'event' in data:\n                return self.on_event(data)\n            elif 'direct_message' in data:\n                return self.on_direct_message(data)\n            elif 'friends' in data:\n                return self.on_friends(data['friends'])\n            elif 'limit' in data:\n                return self.on_limit(data['limit']['track'])\n            elif 'disconnect' in data:\n                return self.on_disconnect(data['disconnect'])\n            elif 'warning' in data:\n                return self.on_warning(data['warning'])\n            else:\n                LOGGER.error(\"Unknown message type: \" + str(raw_data))\n\n        except TypeError as error:\n            LOGGER.error('The message could not be loaded: %s', error)\n\n    def keep_alive(self):\n        \"\"\"Called when a keep-alive arrived\"\"\"\n        return True\n\n    def on_status(self, status):\n        \"\"\"Called when a new status arrives\"\"\"\n        return self._process_response(status)\n\n    def on_exception(self, exception):\n        \"\"\"Called when an unhandled exception occurs.\"\"\"\n        msg = 'An error occurred with the Twitter stream: %s' % exception\n        self.notes = msg\n        LOGGER.error(msg)\n        return False\n\n    def on_delete(self, status_id, user_id):\n        \"\"\"Called when a delete notice arrives for a status\"\"\"\n\n        #TODO(LH): handle deleted tweets\n        LOGGER.warning('User %s has deleted the tweet %s', user_id, status_id)\n        return True\n\n    def on_event(self, status):\n        \"\"\"Called when a new event arrives\"\"\"\n        return self._process_response(status)\n\n    def on_direct_message(self, status):\n        \"\"\"Called when a new direct message arrives\"\"\"\n        return self._process_response(status)\n\n    def on_friends(self, friends):\n        \"\"\"Called when a friends list arrives.\n\n        friends is a list that contains user_id\n        \"\"\"\n        return True\n\n    def on_limit(self, track):\n        \"\"\"Called when a limitation notice arrives\"\"\"\n        LOGGER.warning('Twitter limitation notice: %s', track)\n        return True\n\n    def on_error(self, status_code):\n        \"\"\"Called when a non-200 status code is returned\"\"\"\n        msg = 'An error occurred with the Twitter stream'\n        self.notes = msg\n        self.status_code = status_code\n        LOGGER.error('%s: %s', msg, status_code)\n        return False\n\n    def on_timeout(self):\n        \"\"\"Called when stream connection times out\"\"\"\n        msg = 'The Twitter stream has timed out.'\n        self.notes = msg\n        LOGGER.error(msg)\n        return False\n\n    def on_disconnect(self, notice):\n        \"\"\"Called when twitter sends a disconnect notice\n\n        Disconnect codes are listed here:\n        https://dev.twitter.com/docs/streaming-apis/messages#Disconnect_messages_disconnect\n        \"\"\"\n        msg = 'The Twitter stream has been disconnected: %s' % notice\n        self.notes = msg\n        LOGGER.error(msg)\n        return False\n\n    def on_warning(self, notice):\n        \"\"\"Called when a disconnection warning message arrives\"\"\"\n        LOGGER.warning('Twitter disconnection warning: %s', notice)\n        return True\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, 1, 1, null, 1, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, 0, 0, 0, 0, null, 1, 0, 0, 0, 0, 0, null, null, 0, null, 1, null, null, null, null, null, 0, 0, 0, 0, 0, null, 0, 0, null, null, 0, null, 1, 0, 0, 0, null, null, 1, null, 1, null, 1, 0, 0, 0, 0, 0, null, null, 0, 0, 0, 0, 0, null, null, null, null, null, null, 0, null, 0, null, 0, 0, 0, 0, 0, 0, null, 1, 0, 0, 0, null, 1, null, 0, null, null, 0, 0, 0, 0, 0, 0, null, 0, 0, 0, 0, null, null, null, null, null, null, 0, 0, 0, 0, 0, 0, null, 0, 0, null, null, 0, 0, 0, 0, 0, 0, null, null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, null, 0, 0, null, 0, null, null, 0, 0, 0, null, 0, null, 0, null, 0, 0, null, 1, 0, 0, null, 1, 0, 0, 0, 0, null, 0, null, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, null, 0, null, 0, 0, 0, 0, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, null, 1, 0, 0, 0, 0, null, 0, null, 1, null, 0, null, 1, null, null, null, null, null, null, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, null, 0, 0, 0, null, 0, null, 1, 0, 0, 0, 0, 0, 0, 0, null, 1, 0, 0, 0, 0, 0, null, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, null, 1, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, null, 1, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, null, 1, 0, 0, 0, null], "name": "platforms/twitter/streaming.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nStream class with tweepy bug fixes.\n\"\"\"\n\n# Tweepy\n# Copyright 2009-2010 Joshua Roesslein\n# See LICENSE for details.\n\n# Appengine users: https://developers.google.com/appengine/docs/python/sockets/#making_httplib_use_sockets\n\nfrom __future__ import absolute_import, print_function\n\nimport re\nimport ssl\nfrom threading import Thread\nfrom time import sleep\n\nimport requests\nimport six\nfrom requests.exceptions import Timeout\nfrom tweepy.api import API\nfrom tweepy.error import TweepError\n\nSTREAM_VERSION = '1.1'\n\n\nclass ReadBuffer(object):\n    \"\"\"Buffer data from the response in a smarter way than httplib/requests can.\n    Tweets are roughly in the 2-12kb range, averaging around 3kb.\n    Requests/urllib3/httplib/socket all use socket.read, which blocks\n    until enough data is returned. On some systems (eg google appengine), socket\n    reads are quite slow. To combat this latency we can read big chunks,\n    but the blocking part means we won't get results until enough tweets\n    have arrived. That may not be a big deal for high throughput systems.\n    For low throughput systems we don't want to sacrafice latency, so we\n    use small chunks so it can read the length and the tweet in 2 read calls.\n    \"\"\"\n\n    def __init__(self, stream, chunk_size, encoding='utf-8'):\n        self._stream = stream\n        self._buffer = six.b('')\n        self._chunk_size = chunk_size\n        self._encoding = encoding\n\n    def read_len(self, length):\n        while not self._stream.closed:\n            if len(self._buffer) >= length:\n                return self._pop(length)\n            read_len = max(self._chunk_size, length - len(self._buffer))\n            self._buffer += self._stream.read(read_len)\n            \n        # if stream was closed before enough characthers were received\n        return None\n\n    def read_line(self, sep=six.b('\\n')):\n        \"\"\"Read the data stream until a given separator is found (default \\n)\n        :param sep: Separator to read until. Must by of the bytes type (str in python 2,\n            bytes in python 3)\n        :return: The str of the data read until sep\n        \"\"\"\n        start = 0\n        while not self._stream.closed:\n            loc = self._buffer.find(sep, start)\n            if loc >= 0:\n                return self._pop(loc + len(sep))\n            else:\n                start = len(self._buffer)\n            self._buffer += self._stream.read(self._chunk_size)\n        \n        # if stream was closed before sep received\n        return None\n\n    def _pop(self, length):\n        r = self._buffer[:length]\n        self._buffer = self._buffer[length:]\n        return r.decode(self._encoding)\n\n\nclass Stream(object):\n\n    host = 'stream.twitter.com'\n\n    def __init__(self, auth, listener, **options):\n        self.auth = auth\n        self.listener = listener\n        self.running = False\n        self.timeout = options.get(\"timeout\", 300.0)\n        self.retry_count = options.get(\"retry_count\")\n        # values according to\n        # https://dev.twitter.com/docs/streaming-apis/connecting#Reconnecting\n        self.retry_time_start = options.get(\"retry_time\", 5.0)\n        self.retry_420_start = options.get(\"retry_420\", 60.0)\n        self.retry_time_cap = options.get(\"retry_time_cap\", 320.0)\n        self.snooze_time_step = options.get(\"snooze_time\", 0.25)\n        self.snooze_time_cap = options.get(\"snooze_time_cap\", 16)\n\n        # The default socket.read size. Default to less than half the size of\n        # a tweet so that it reads tweets with the minimal latency of 2 reads\n        # per tweet. Values higher than ~1kb will increase latency by waiting\n        # for more data to arrive but may also increase throughput by doing\n        # fewer socket read calls.\n        self.chunk_size = options.get(\"chunk_size\",  512)\n\n        self.verify = options.get(\"verify\", True)\n\n        self.api = API()\n        self.headers = options.get(\"headers\") or {}\n        self.new_session()\n        self.body = None\n        self.retry_time = self.retry_time_start\n        self.snooze_time = self.snooze_time_step\n\n    def new_session(self):\n        self.session = requests.Session()\n        self.session.headers = self.headers\n        self.session.params = None\n\n    def _run(self):\n        # Authenticate\n        url = \"https://%s%s\" % (self.host, self.url)\n\n        # Connect and process the stream\n        error_counter = 0\n        resp = None\n        exception = None\n        while self.running:\n            if self.retry_count is not None:\n                if error_counter > self.retry_count:\n                    # quit if error count greater than retry count\n                    break\n            try:\n                auth = self.auth.apply_auth()\n                resp = self.session.request('POST',\n                                            url,\n                                            data=self.body,\n                                            timeout=self.timeout,\n                                            stream=True,\n                                            auth=auth,\n                                            verify=self.verify)\n                if resp.status_code != 200:\n                    if self.listener.on_error(resp.status_code) is False:\n                        break\n                    error_counter += 1\n                    if resp.status_code == 420:\n                        self.retry_time = max(self.retry_420_start,\n                                              self.retry_time)\n                    sleep(self.retry_time)\n                    self.retry_time = min(self.retry_time * 2,\n                                          self.retry_time_cap)\n                else:\n                    error_counter = 0\n                    self.retry_time = self.retry_time_start\n                    self.snooze_time = self.snooze_time_step\n                    self.listener.on_connect()\n                    self._read_loop(resp)\n            except (Timeout, ssl.SSLError) as exc:\n                # This is still necessary, as a SSLError can actually be\n                # thrown when using Requests\n                # If it's not time out treat it like any other exception\n                if isinstance(exc, ssl.SSLError):\n                    if not (exc.args and 'timed out' in str(exc.args[0])):\n                        exception = exc\n                        break\n                if self.listener.on_timeout() is False:\n                    break\n                if self.running is False:\n                    break\n                sleep(self.snooze_time)\n                self.snooze_time = min(self.snooze_time + self.snooze_time_step,\n                                       self.snooze_time_cap)\n            except Exception as exc:\n                exception = exc\n                # any other exception is fatal, so kill loop\n                break\n\n        # cleanup\n        self.running = False\n        if resp:\n            resp.close()\n\n        self.new_session()\n\n        if exception:\n            # call a handler first so that the exception can be logged.\n            self.listener.on_exception(exception)\n            raise exception\n\n    def _data(self, data):\n        if self.listener.on_data(data) is False:\n            self.running = False\n\n    def _read_loop(self, resp):\n        charset = resp.headers.get('content-type', default='')\n        enc_search = re.search('charset=(?P<enc>\\S*)', charset)\n        if enc_search is not None:\n            encoding = enc_search.group('enc')\n        else:\n            encoding = 'utf-8'\n\n        buf = ReadBuffer(resp.raw, self.chunk_size, encoding=encoding)\n\n        while self.running and not resp.raw.closed:\n            length = 0\n            while not resp.raw.closed:\n                line = buf.read_line()\n                if line is None:  # the stream is closed\n                    break\n                line = line.strip()\n                if not line:\n                    self.listener.keep_alive()  # keep-alive new lines are expected\n                elif line.isdigit():\n                    length = int(line)\n                    break\n                else:\n                    raise TweepError('Expecting length, unexpected value found')\n\n            next_status_obj = buf.read_len(length)\n            if next_status_obj is None:  # the stream is closed\n                break\n            if self.running:\n                self._data(next_status_obj)\n\n            # # Note: keep-alive newlines might be inserted before each length value.\n            # # read until we get a digit...\n            # c = b'\\n'\n            # for c in resp.iter_content(decode_unicode=True):\n            #     if c == b'\\n':\n            #         continue\n            #     break\n            #\n            # delimited_string = c\n            #\n            # # read rest of delimiter length..\n            # d = b''\n            # for d in resp.iter_content(decode_unicode=True):\n            #     if d != b'\\n':\n            #         delimited_string += d\n            #         continue\n            #     break\n            #\n            # # read the next twitter status object\n            # if delimited_string.decode('utf-8').strip().isdigit():\n            #     status_id = int(delimited_string)\n            #     next_status_obj = resp.raw.read(status_id)\n            #     if self.running:\n            #         self._data(next_status_obj.decode('utf-8'))\n\n\n        if resp.raw.closed:\n            self.on_closed(resp)\n\n    def _start(self, async):\n        self.running = True\n        if async:\n            self._thread = Thread(target=self._run)\n            self._thread.start()\n        else:\n            self._run()\n\n    def on_closed(self, resp):\n        \"\"\" Called when the response has been closed by Twitter \"\"\"\n        pass\n\n    def userstream(self,\n                   stall_warnings=False,\n                   _with=None,\n                   replies=None,\n                   track=None,\n                   locations=None,\n                   async=False,\n                   encoding='utf8'):\n        self.session.params = {'delimited': 'length'}\n        if self.running:\n            raise TweepError('Stream object already connected!')\n        self.url = '/%s/user.json' % STREAM_VERSION\n        self.host = 'userstream.twitter.com'\n        if stall_warnings:\n            self.session.params['stall_warnings'] = stall_warnings\n        if _with:\n            self.session.params['with'] = _with\n        if replies:\n            self.session.params['replies'] = replies\n        if locations and len(locations) > 0:\n            if len(locations) % 4 != 0:\n                raise TweepError(\"Wrong number of locations points, \"\n                                 \"it has to be a multiple of 4\")\n            self.session.params['locations'] = ','.join(['%.2f' % l for l in locations])\n        if track:\n            self.session.params['track'] = u','.join(track).encode(encoding)\n\n        self._start(async)\n\n    def firehose(self, count=None, async=False):\n        self.session.params = {'delimited': 'length'}\n        if self.running:\n            raise TweepError('Stream object already connected!')\n        self.url = '/%s/statuses/firehose.json' % STREAM_VERSION\n        if count:\n            self.url += '&count=%s' % count\n        self._start(async)\n\n    def retweet(self, async=False):\n        self.session.params = {'delimited': 'length'}\n        if self.running:\n            raise TweepError('Stream object already connected!')\n        self.url = '/%s/statuses/retweet.json' % STREAM_VERSION\n        self._start(async)\n\n    def sample(self, async=False, languages=None, stall_warnings=False):\n        self.session.params = {'delimited': 'length'}\n        if self.running:\n            raise TweepError('Stream object already connected!')\n        self.url = '/%s/statuses/sample.json' % STREAM_VERSION\n        if languages:\n            self.session.params['language'] = ','.join(map(str, languages))\n        if stall_warnings:\n            self.session.params['stall_warnings'] = 'true'\n        self._start(async)\n\n    def filter(self, follow=None, track=None, async=False, locations=None,\n               stall_warnings=False, languages=None, encoding='utf8', filter_level=None):\n        self.body = {}\n        self.session.headers['Content-type'] = \"application/x-www-form-urlencoded\"\n        if self.running:\n            raise TweepError('Stream object already connected!')\n        self.url = '/%s/statuses/filter.json' % STREAM_VERSION\n        if follow:\n            self.body['follow'] = u','.join(follow).encode(encoding)\n        if track:\n            self.body['track'] = u','.join(track).encode(encoding)\n        if locations and len(locations) > 0:\n            if len(locations) % 4 != 0:\n                raise TweepError(\"Wrong number of locations points, \"\n                                 \"it has to be a multiple of 4\")\n            self.body['locations'] = u','.join(['%.4f' % l for l in locations])\n        if stall_warnings:\n            self.body['stall_warnings'] = stall_warnings\n        if languages:\n            self.body['language'] = u','.join(map(str, languages))\n        if filter_level:\n            self.body['filter_level'] = unicode(filter_level, encoding)\n        self.session.params = {'delimited': 'length'}\n        self.host = 'stream.twitter.com'\n        self._start(async)\n\n    def sitestream(self, follow, stall_warnings=False,\n                   with_='user', replies=False, async=False):\n        self.body = {}\n        if self.running:\n            raise TweepError('Stream object already connected!')\n        self.url = '/%s/site.json' % STREAM_VERSION\n        self.body['follow'] = u','.join(map(six.text_type, follow))\n        self.body['delimited'] = 'length'\n        if stall_warnings:\n            self.body['stall_warnings'] = stall_warnings\n        if with_:\n            self.body['with'] = with_\n        if replies:\n            self.body['replies'] = replies\n        self._start(async)\n\n    def disconnect(self):\n        if self.running is False:\n            return\n        self.running = False\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "query/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "query/collectionqueries/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, null, null, 0, 0, null, null, 0, null, null, null, null, 0, null, 0, 0, 0, null, null, null, 0, 0, null, 0, null, 0, null, null, 0, null, null, null, 0, 0, 0, null, 0, 0, 0, 0, 0, null, 0, null, null, null, 0, null, 0, 0, null, 0, null, null, null, null, null, null, null, 0, null, null, null, null, null, null, 0, null, null, null, null, null, null, 0, null, null, null, null, null, 0, 0, null, 0, 0, null, 0, null, 0, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, null, null, null, null, 0], "name": "query/collectionqueries/forms.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nForms for selecting a Warehouse and constructing a database query.\n\"\"\"\n\n# third party\nfrom django import forms\n\n# local\nfrom distilleries.models import Distillery\nfrom warehouses.models import Collection\n\n\nclass CollectionSelectForm(forms.Form):\n    \"\"\"\n    Form for selecting a Collection (database collection) on which to perform\n    a query.\n    \"\"\"\n    collection = forms.ModelChoiceField(queryset=None)\n\n    def __init__(self, *args, **kwargs):\n        collection = kwargs.pop('collection', None)\n        super(CollectionSelectForm, self).__init__(*args, **kwargs)\n\n        # provide an option to use a filtered queryset, if, for instance,\n        # we want to check a user's permissions to access specific collections\n        if collection:\n            queryset = kwargs['collections']\n        else:\n            queryset = Collection.objects.all()\n\n        self.fields['collection'].queryset = queryset\n\n\nclass CollectionQueryForm(forms.Form):\n    \"\"\"\n    Form for creating a query for a specific database collection.\n    \"\"\"\n    datafield = forms.ChoiceField()\n    operator = forms.ChoiceField()\n    value = forms.CharField()\n\n    def __init__(self, *args, **kwargs):\n        backend = kwargs.pop('backend', None)\n        database = kwargs.pop('database', None)\n        collection = kwargs.pop('collection', None)\n        super(CollectionQueryForm, self).__init__(*args, **kwargs)\n\n        if backend and database and collection:\n\n            # TODO(LH): provide contingency if no Distillery is associated with\n            # the warehouse\n            distillery = Distillery.objects.get_by_natural_key(backend, database,\n                                                               collection) \n            field_choices = self._get_field_choices(distillery.bottle)\n            operator_choices = self._get_operator_choices()\n\n            self.fields['datafield'] = forms.ChoiceField(\n                choices=field_choices,\n                label='Field name',\n                widget=forms.Select(\n                    attrs={'class': 'field'},\n                )\n            )\n\n            self.fields['operator'] = forms.ChoiceField(\n                choices=operator_choices,\n                widget=forms.Select(\n                    attrs={'class': 'operator'},\n                )\n            )\n\n            self.fields['value'] = forms.CharField(\n                required=False,\n                widget=forms.TextInput(\n                    attrs={'class': 'value'},\n                )\n            )\n\n    @staticmethod\n    def _get_field_choices(bottle):\n        \"\"\"\n        Takes a Bottle and adds choices to the datafield ChoiceField\n        based on the fields used in the Warehouse.\n        \"\"\"\n        default_choice = ('', '-- select a field --')\n        field_choices = bottle.get_field_choices()\n\n        choices = [default_choice]\n        choices.extend(field_choices)\n\n        return choices\n\n    @staticmethod\n    def _get_operator_choices():\n        \"\"\"\n        Returns a tuple of 2-tuples representing valid choices for the query\n        operator field.\n        \"\"\"\n        return (\n\n            # BooleanField choices\n            ('eq', 'is true'),\n            ('not:eq', 'is false'),\n\n            # DateTimeField choices\n            ('gte', 'occurred on or after'),\n            ('lte', 'occurred on or before'),\n\n            # default options\n            ('eq', 'equals'),\n            ('not:eq', 'does not equal'),\n\n            # ListField choices\n            ('in', 'contains'),\n            ('not:in', 'does not contain'),\n\n            # FloatField or IntegerField options\n            ('eq', 'equals'),\n            ('ne', 'does not equal'),\n            ('gt', 'greater than'),\n            ('gte', 'greater than or equal to'),\n            ('lt', 'less than'),\n            ('lte', 'less than or equal to'),\n\n            # CharField options\n            ('regex', 'contains'),\n            ('eq', 'equals'),\n            ('not:regex', 'does not contain'),\n\n            # just used in test cases for $not\n            ('not:eq', 'does not equal'),\n        )\n\n\nclass JoinOperatorForm(forms.Form):\n    \"\"\"\n    Defines a form for specifiying whether query terms should be joined with an\n    'AND' or 'OR' operator.\n    \"\"\"\n    JOIN_CHOICES = (\n        ('AND', 'satisfy all filter conditions'),\n        ('OR', 'satisfy at least one filter condition')\n    )\n\n    joiner = forms.ChoiceField(choices=JOIN_CHOICES, label='Query type')\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, 1, 1, 1, null, 1, 1, null, 1, 0, null, null, 1, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, 1, 1, null, 1, 0], "name": "query/collectionqueries/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.db import models\nfrom django.conf import settings\n\n# local\nfrom cyphon.choices import FIELD_TYPE_CHOICES, LOGIC_CHOICES, OPERATOR_CHOICES\nfrom warehouses.models import Collection\n\n\nclass CollectionQuery(models.Model):\n    \"\"\"\n\n    \"\"\"\n    created_by = models.ForeignKey(settings.AUTH_USER_MODEL, blank=True,\n                                   null=True)\n    created_date = models.DateTimeField(auto_now_add=True)\n    collections = models.ManyToManyField(Collection, related_name='+')\n    joiner = models.CharField(max_length=40, choices=LOGIC_CHOICES)\n\n    class meta:\n        verbose_name_plural = 'field queries'\n\n    def __str__(self):\n        return '%s %s' % (self.created_date, self.created_by)\n\n\nclass Fieldset(models.Model):\n    \"\"\"\n    Defines a fieldset.\n\n    Attributes:\n        field_name:\n        field_type:\n        operator:\n        value:\n\n    \"\"\"\n    query = models.ForeignKey(CollectionQuery, related_name='fieldsets',\n                              related_query_name='fieldset')\n    field_name = models.CharField(max_length=255)\n    field_type = models.CharField(max_length=255, choices=FIELD_TYPE_CHOICES)\n    operator = models.CharField(max_length=40, choices=OPERATOR_CHOICES)\n    value = models.TextField()  # this could be a string, number, etc.\n\n    def __str__(self):\n        return '%s %s %s' % (self.field, self.operator, self.value)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, 1, 1, 1, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, 1, 1, 1, null, null, 1, null, null, 1, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, 1, 1, null, null, 1, 1, null, 1, null], "name": "query/collectionqueries/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom query.collectionqueries.models import CollectionQuery, Fieldset\nfrom warehouses.models import Collection\n\n\nclass FieldsetSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Fieldset\n        fields = ['field_name', 'field_type', 'operator', 'value']\n\n\nclass CollectionQuerySerializer(serializers.ModelSerializer):\n\n    # we'll specify collections using PrimaryKeys\n    collections = serializers.PrimaryKeyRelatedField(\n        queryset=Collection.objects.all(),\n        many=True\n    )\n\n    # we'll define fieldsets using individual fields\n    fieldsets = FieldsetSerializer(many=True)\n\n    class Meta:\n        model = CollectionQuery\n        fields = ['collections', 'fieldsets', 'joiner']\n\n        # values for these fields will be added automatically\n        read_only_fields = ['created_by', 'created_date']\n        \n        # include fields for child objects like fieldsets\n        depth = 1\n\n    def create(self, validated_data):\n        \"\"\"\n        Takes validated JSON for a field-based query and returns a CollectionQuery\n        object.\n        \"\"\"\n        # remove all ForeignKey relationships before creating the CollectionQuery\n        fieldsets = validated_data.pop('fieldsets')\n        collections = validated_data.pop('collections')\n\n        # create a bare-bones CollectionQuery with the remaining fields\n        query = CollectionQuery.objects.create(**validated_data)\n\n        # add relationships to the chosen Collections\n        for collection in collections:\n            query.collections.add(collection)\n\n        # create Fieldsets that are related to the CollectionQuery\n        for fieldset in fieldsets:\n            Fieldset.objects.create(query=query, **fieldset)\n\n        return query\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, null, null, 0, null, null, null, null, null, null], "name": "query/collectionqueries/urls.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.conf.urls import url\n\n# local\nfrom . import views\n\n# urlpatterns = [\n#     url(r'^$', views.collectionselect),\n#     url(r'^(?P<backend>\\w+)/(?P<database>\\w+)/(?P<collection>\\w+)/query$',\n#         views.collectionquery),\n# ]\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, 1, 1, null, null, 1, null, null, null, 1, 1, null, 1, null, null, null, null, null, 0, null, 0, null, 0, 0, 0, 0, 0, null, 1, null, null, null, null, null, 0, 0, 0, 0, 0, 0, 0, null, 1, 1, null, 1, null, null, null, null, null, 0, 0, 0, 0, 0, null, null, 1, null, null, null, 1, 1, null, null], "name": "query/collectionqueries/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom rest_framework import viewsets\nfrom rest_framework.decorators import list_route\nfrom rest_framework.response import Response\n\n# local\nfrom cyphon.fieldsets import QueryFieldset\nfrom engines.queries import EngineQuery\nfrom query.collectionqueries.models import CollectionQuery, Fieldset\nfrom query.collectionqueries.serializers import CollectionQuerySerializer, FieldsetSerializer\n\n\nclass CollectionQueryViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    REST API views for CollectionQueries.\n    \"\"\"\n    queryset = CollectionQuery.objects.all()\n    serializer_class = CollectionQuerySerializer\n\n    @staticmethod\n    def _get_results(query):\n        \"\"\"\n        Takes a query dictionary and returns a list of documents that match the\n        query criteria.\n        \"\"\"\n        subqueries = [QueryFieldset(**fieldset) \\\n                      for fieldset in query['fieldsets']]\n        engine_query = EngineQuery(subqueries=subqueries,\n                                   joiner=query['joiner'])\n        docs = []\n        for collection in query['collections']:\n            results = collection.find(engine_query)\n            docs.extend(results['results'])\n        return docs\n\n    @staticmethod\n    def _get_teaser_results(query):\n        \"\"\"\n        Takes a query dictionary and returns a list of teasers for documents\n        that match the query criteria.\n        \"\"\"\n        results = []\n        for collection in query['collections']:\n            docs = collection.find(query)\n            for doc in docs:\n                teaser = collection.get_sample(doc)\n                results.append(teaser)\n        return results\n\n    def perform_create(self, serializer):\n        serializer.save(created_by=self.request.user)\n\n    @list_route(methods=['post'], url_path='query')\n    def query(self, request, *args, **kwargs):\n        \"\"\"\n        REST API endpoint for field-based queries. Takes a query request and\n        returns a list of matching documents.\n        \"\"\"\n        serializer = self.serializer_class(data=self.request.data)\n        serializer.is_valid(raise_exception=True)\n        query = serializer.validated_data\n        results = self._get_results(query)\n        return Response(results)\n\n\nclass QueryFieldsetViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    REST API views for QueryFieldsets.\n    \"\"\"\n    queryset = Fieldset.objects.all()\n    serializer_class = FieldsetSerializer\n    # permission_classes = (IsAuthenticated, )\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "query/reservoirqueries/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, 0, null, null, 0, null, null, 0, null, null, null, 0, null, null, 0, 0, 0, 0, null, null, null, null, 0, null, 0, 0, null, null, null, null, null, null, null, 0], "name": "query/reservoirqueries/forms.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django import forms\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom .models import ReservoirQueryParameters\n\n\nclass ReservoirQueryParametersForm(forms.ModelForm):\n    \"\"\"\n    Form used for constructing a ReservoirQuery object.\n    \"\"\"\n    locations = forms.CharField()\n\n\n    class Meta:\n        model = ReservoirQueryParameters\n        exclude = ['created_by', 'locations']\n        labels = {\n            'start_time': _('After'),\n            'end_time': _('Before')\n        }\n\n    def save(self, commit=True):\n        # locations = self.cleaned_data.pop('locations')\n        parameters = ReservoirQueryParameters(**self.cleaned_data)\n        parameters.save()\n\n        # for location in locations:\n        #     parameters.locations.add(location)\n\n        # if commit:\n        #     parameters.save()\n\n        return parameters\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, 1, 1, 1, 1, 1, null, null, 1, null, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, null, null, null, 1, 1, 1, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, 1, 1, null, 1, 1, 1, 1, null, 1, 1, null, 1, null, null, null, null, null, 1, null, 1, 1, 1, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, 1, 1, 1, 1, null, 1, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, 0, 0, 0, null, 1, null, null, null, 0, null, null, 0, null, 0, null, null, null, null, 0, null], "name": "query/reservoirqueries/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# standard library\nimport re\n\n# third party\nfrom django.db import models\nfrom django.conf import settings\n\n# local\nfrom aggregator.pumproom.pumproom import PumpRoom\nfrom aggregator.reservoirs.models import Reservoir\nfrom query.reservoirqueries.reservoirquery import ReservoirQuery\nfrom target.locations.models import Location\nfrom target.searchterms.models import SearchTerm\nfrom target.timeframes.models import TimeFrame\n\n\nclass ReservoirQueryParameters(models.Model):\n    \"\"\"\n    Model used for constructing a ReservoirQuery object from form input.\n    \"\"\"\n    JOIN_CHOICES = (\n        ('AND', 'satisfy both keyword and location conditions'),\n        ('OR', 'satisfy either keyword or location conditions')\n    )\n\n    created_by = models.ForeignKey(\n        settings.AUTH_USER_MODEL,\n        blank=True,\n        null=True\n    )\n    reservoirs = models.ManyToManyField(\n        Reservoir,\n        limit_choices_to={'enabled': True}\n    )\n    start_time = models.DateTimeField(blank=True, null=True)\n    end_time = models.DateTimeField(blank=True, null=True)\n    included_keywords = models.CharField(\n        blank=True,\n        max_length=255,\n        verbose_name=\"Contains at least one of the keywords\"\n    )\n    excluded_keywords = models.CharField(\n        blank=True,\n        max_length=255,\n        verbose_name=\"Does not contain the keywords\"\n    )\n    locations = models.ManyToManyField(Location, blank=True)\n    trm_loc_logic = models.CharField(\n        max_length=5,\n        choices=JOIN_CHOICES,\n        default='AND',\n        verbose_name='Query type'\n    )\n\n    @staticmethod\n    def _parse_keywords(keywords):\n        \"\"\"\n        Takes a string of comma-separated or space-separated keywords/phrases\n        and returns a list of keywords/phrases.\n        \"\"\"\n        keyword_array = [keywords]\n\n        phrases = re.findall('\".*?\"', keywords)\n        words = re.sub('\".*?\"', ' ', keywords)\n\n        if re.search(',', words):\n            keyword_array = words.split(',')\n        elif re.search(' ', words):\n            keyword_array = words.split(' ')\n\n        keyword_array.extend(phrases)\n        return keyword_array\n\n    def _create_terms_by_type(self, keywords, negate=False):\n        \"\"\"\n        Takes a string of comma-separated or space-separated keywords/phrases\n        and a Boolean indicating whether they should be negated in a text\n        search. Returns a list of SearchTerm objects.\n        \"\"\"\n        keyword_array = self._parse_keywords(keywords)\n\n        searchterms = []\n        for keyword in keyword_array:\n            cleaned_keyword = keyword.strip()\n            cleaned_keyword = cleaned_keyword.replace('\"', '')\n            if cleaned_keyword != '':\n                term = SearchTerm(term=cleaned_keyword, negate=negate)\n                searchterms.append(term)\n\n        return searchterms\n\n    def _create_searchterms(self):\n        \"\"\"\n        Takes a string of comma-separated or space-separated keywords/phrases\n        and returns a list of SearchTerm objects.\n        \"\"\"\n        included_terms = self._create_terms_by_type(self.included_keywords, False)\n        excluded_terms = self._create_terms_by_type(self.excluded_keywords, True)\n\n        searchterms = []\n        searchterms.extend(included_terms)\n        searchterms.extend(excluded_terms)\n\n        return searchterms\n\n    def _create_timeframe(self):\n        \"\"\"\n        Returns a TimeFrame object representing the start and end times\n        specified in the query parameters.\n        \"\"\"\n        timeframe = TimeFrame()\n        if self.start_time:\n            timeframe.start = self.start_time\n        if self.end_time:\n            timeframe.end = self.end_time\n        return timeframe\n\n    def _create_reservoir_query(self):\n        \"\"\"\n        Returns a ReservoirQuery based on the ReservoirQueryParameters.\n        \"\"\"\n        return ReservoirQuery(\n            locations=self.locations.all(),\n            searchterms=self._create_searchterms(),\n            timeframe=self._create_timeframe(),\n            trm_loc_logic=self.trm_loc_logic\n        )\n\n    def _get_reservoirs(self):\n        \"\"\"\n        If Reservoirs were specified in the query paramters, returns a QuerySet\n        of those Reservoirs. Otherwise, returns a QuerySet of all enabled\n        Reservoirs.\n        \"\"\"\n        if self.reservoirs:\n            return self.reservoirs\n        return Reservoir.objects.find_enabled()\n\n    def execute_ad_hoc_search(self):\n        \"\"\"\n        Performs an ad hoc search using the ReservoirQueryParameters.\n        \"\"\"\n        reservoirs = self._get_reservoirs()\n\n        # ReservoirQuery object created from ReservoirQueryParameters\n        query = self._create_reservoir_query()\n\n        pumproom = PumpRoom(\n            reservoirs=reservoirs,\n            task='ADHOC_SRCH',\n            user=self.created_by\n        )\n        return pumproom.get_results(query)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, null, 1, null, 1, 1, null, 1, null, 1, 1, null, 1, null, 1, 1, null, 1, 0, null, null, 1, null, null, null, null, 1, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, 1, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, 1, null, null, null, 1, 1, null, 1, null, null, null, null, 1, null, 1, 1, 1, null, 1, null, 1, null, 1, null, null, null, 1, 1, null, 1, null, null, null, 1, 1, null, 1, null, null, null, null, 1, null, 1, 1, 1, 1, 1, null, 1, null, 1, null, 1, null, 1, null, null, null, null, null, 1, null, 1, 1, 1, 1, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, 1, null, 1, 1, null, 1, null, 1, null, 1, null, null, null, 1, 1, null, 1, 1, 1, 1, null, 1, null, null], "name": "query/reservoirqueries/reservoirquery.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ReservoirQuery class for passing media queries to Pipes.\n\"\"\"\n\n# standard library\nimport json\n\n# third party\nfrom django.core import serializers\n\n\nclass ReservoirQuery(object):\n    \"\"\"\n    Specifies search criteria for searching social media posts from a particular\n    platform.\n\n    Attributes:\n        accounts: a list of Account objects associated with a particular\n            social media platform (Reservoir)\n        locations: a list of Location objects\n        searchterms: a list of SearchTerm objects\n        timeframe: a TimeFrame object\n        trm_loc_logic: a logical \"AND\" or \"OR\" operator indicating how terms and\n            locations are evaluated in a query (i.e., with an intersection vs.\n            a union of results)\n    \"\"\"\n\n    def __init__(self, accounts=None, locations=None, searchterms=None,\n                 timeframe=None, trm_loc_logic='OR'):\n        if accounts == None:\n            self.accounts = []\n        else:\n            self.accounts = accounts\n\n        if locations == None:\n            self.locations = []\n        else:\n            self.locations = locations\n\n        if searchterms == None:\n            self.searchterms = []\n        else:\n            self.searchterms = searchterms\n\n        self.timeframe = timeframe\n        self.trm_loc_logic = trm_loc_logic\n\n    def __str__(self):\n        return '%s Accounts, %s Locations, %s Search SearchTerms ' % \\\n            (len(self.accounts), len(self.locations), len(self.searchterms))\n\n    @property\n    def included_terms(self):\n        \"\"\"\n        Returns SearchTerms that searched text should contain.\n        \"\"\"\n        included_terms = []\n\n        for term in self.searchterms:\n            if not term.negate:\n                included_terms.append(term)\n\n        return included_terms\n\n    @property\n    def excluded_terms(self):\n        \"\"\"\n        Returns SearchTerms that searched text should not contain.\n        \"\"\"\n        excluded_terms = []\n\n        for term in self.searchterms:\n            if term.negate:\n                excluded_terms.append(term)\n\n        return excluded_terms\n\n    @staticmethod\n    def _model_obj_to_dict(model_instance):\n        \"\"\"\n        Takes an instance of a Django model and returns a dictionary in which\n        the keys are the fields of the model instance and the values are the\n        model instance's values for those fields.\n        \"\"\"\n        if model_instance:\n            json_data = serializers.serialize('json', [model_instance])\n            data = json.loads(json_data)\n            return data[0]['fields']\n        else:\n            return {}\n\n    def _model_objs_to_dict(self, model_instances):\n        \"\"\"\n        Takes a list of Django model instances and returns list of dictionaries\n        representing each model instance. In each dictionary, the keys are the\n        fields of the model instance and the values are the model instance's\n        values for those fields.\n        \"\"\"\n        dict_list = []\n        for model_instance in model_instances:\n            dict_list.append(self._model_obj_to_dict(model_instance))\n        return dict_list\n\n    def to_dict(self):\n        \"\"\"\n        Returns a dictionary representation of the ReservoirQuery.\n        \"\"\"\n        return {\n            'accounts': self._model_objs_to_dict(self.accounts),\n            'locations': self._model_objs_to_dict(self.locations),\n            'searchterms': self._model_objs_to_dict(self.searchterms),\n            'timeframe': self._model_obj_to_dict(self.timeframe),\n            'trm_loc_logic': self.trm_loc_logic\n        }\n\n    def to_json(self):\n        \"\"\"\n        Returns a pretty-printed JSON string of the ReservoirQuery,\n        sorted by key.\n        \"\"\"\n        return json.dumps(self.to_dict(), sort_keys=True, indent=4)\n\n    def remove_negated_terms(self):\n        \"\"\"\n        Removes any negated terms from the list of SearchTerms.\n        \"\"\"\n        self.searchterms = self.included_terms\n        return self\n\n    def filter_accounts(self, reservoir):\n        \"\"\"\n        Takes the primary key of a Reservoir and filters the list of Accounts\n        to only include Accounts associated with the given Reservoir.\n        \"\"\"\n        accounts = []\n\n        for account in self.accounts:\n            if str(account.platform) == reservoir:\n                accounts.append(account)\n\n        self.accounts = accounts\n\n        return self\n\n    def convert_all_shapes_to_boxes(self):\n        \"\"\"\n        Transforms Locations into their bounding boxes.\n        \"\"\"\n        self.locations = [loc.get_bbox() for loc in self.locations]\n        return self\n\n    def convert_all_shapes_to_radiuses(self):\n        \"\"\"\n        Transforms Locations into radiuses.\n        \"\"\"\n        self.locations = [loc.get_radius() for loc in self.locations]\n        return self\n\n    def factor_locations_by_radius(self, radius_km):\n        \"\"\"\n        Transforms Locations into Locations with radiuses not exceeding the\n        given radius, which together cover the same total area.\n        \"\"\"\n        all_locations = []\n\n        for location in self.locations:\n            radiuses = radius_km is not None and location.radius_km is not None\n            if radiuses and location.radius_km > radius_km:\n                new_locations = location.factor_by_radius_km(radius_km)\n                all_locations.extend(new_locations)\n            else:\n                all_locations.append(location)\n\n        self.locations = all_locations\n\n        return self\n\n    def add_searchterm(self, new_term):\n        \"\"\"\n        Takes a SearchTerm object and adds the SearchTerm to the\n        ReservoirQuery's searchterms if the value for the SearchTerm.term\n        property is not a duplicate.\n        \"\"\"\n        dup = False\n\n        for searchterm in self.searchterms:\n            if new_term.term == searchterm.term:\n                dup = True\n                break\n\n        if dup == False:\n            self.searchterms.append(new_term)\n\n        return self\n\n    def transform_phrases(self):\n        \"\"\"\n        Transforms SearchTerms that are phrases so that they can be processed by\n        Pipes that cannot handle phrases. Each SearchTerm that is a phrase is\n        tranformed into new SearchTerms in which each word of the phrase is\n        queried individually as well as combined as a single tag (i.e., no\n        spaces between the words).\n        \"\"\"\n        old_searchterms = self.searchterms\n        self.searchterms = []\n\n        for searchterm in old_searchterms:\n\n            if searchterm.is_phrase():\n                new_searchterms = searchterm.create_terms_from_phrase()\n\n                for new_searchterm in new_searchterms:\n                    self.add_searchterm(new_searchterm)\n            else:\n                self.add_searchterm(searchterm)\n\n        return self\n\n    def wrap_phrases_in_quotes(self):\n        \"\"\"\n        For SearchTerms that are phrases, wraps phrases in quotation marks.\n        \"\"\"\n        old_searchterms = self.searchterms\n        self.searchterms = []\n\n        for searchterm in old_searchterms:\n            if searchterm.is_phrase():\n                searchterm.wrap_in_quotes()\n            self.add_searchterm(searchterm)\n\n        return self\n\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, null, null, 0, null, null, 0, null, null, null, null, null], "name": "query/reservoirqueries/urls.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.conf.urls import url\n\n# local\nfrom . import views\n\n\nurlpatterns = [\n    url(r'^$', views.reservoirquery, name='reservoir_search'),\n    url(r'^query/', views.reservoirquery_search),\n    # url(r'^api/social_search/', 'query.reservoirqueries.views.social_search')\n]\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, 0, 0, 0, null, null, null, null, null, 0, null, null, null, 0, null, null, null, 0, null, 0, null, null, null, null, 0, null, null, null, null, null, 0, null, 0, 0, null, 0, 0, null, 0, 0, 0, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "query/reservoirqueries/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom bson import json_util\nfrom django.contrib.auth.models import AnonymousUser\nfrom django.shortcuts import render_to_response\nfrom django.template import RequestContext\n# from rest_framework import status\n# from rest_framework.decorators import api_view\n# from rest_framework.response import Response\n\n# local\nfrom . import forms\n# from . import serializers\n\n\ndef reservoirquery(request):\n    \"\"\"\n    View for displaying and handling the form for building a ReservoirQuery.\n    \"\"\"\n    form = forms.ReservoirQueryParametersForm(None)\n\n    return render_to_response('reservoirqueries/reservoirquery.html',\n                              {'form': form},\n                              context_instance=RequestContext(request))\n\n\ndef reservoirquery_search(request):\n    \"\"\"\n    View that takes get parameters from a ReservoirQueryParameters form and\n    returns the search results.\n    \"\"\"\n\n    form = forms.ReservoirQueryParametersForm(request.GET or None)\n\n    if form.is_valid():\n        parameters = form.save(commit=False)\n\n        if not isinstance(request.user, AnonymousUser):\n            parameters.created_by = request.user\n\n        results = parameters.execute_ad_hoc_search()\n        json_data = json_util.dumps(list(results))\n        return render_to_response('query/results.html',\n                                  {'data': json_data},\n                                  context_instance=RequestContext(request))\n\n    return render_to_response('query/results.html',\n                              {'data': json_util.dumps({})},\n                              context_instance=RequestContext(request))\n\n# @api_view(['GET'])\n# def social_search(request):\n#     \"\"\"\n#     API Endpoint for submitting form data that will be used to find\n#     relevant information\n#     \"\"\"\n#     if request.method == 'GET':\n#         serializer = serializers.SocialSerializer(data=request.data)\n#         if serializer.is_valid():\n#             instance = serializer.save()\n#             search_data = instance.execute_ad_hoc_search()\n#             return Response(search_data, status=status.HTTP_200_OK)\n#         return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, 1, null, null, 1, 1, 1, null, null, 1, null, null, 1, 1, null, null, 1, 1, null, null, 1, 1, null, null, 1, 1, 1, null, 1, null, 1, 1, null, null, 1, null, null, null, 0, 0, null, null, 0, null, null, null, null, null, 0, null, 0, 0, 0, 0, 0, 0, null, 0, null, null, null, 0, null, 0, null, null, null, 0, null, null, 0, null, null, null, 0, null, 0, 0, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, 1, 1, 1, 1, 1, null, 1, null, 1, 1, 1, 1, null, 1, 1, 1, 1, null, 1, 1, null, null, null, 1, null, null, null, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, 0, 0, 0, null, null, 1, 0, 0, 0, 0, null, 0], "name": "receiver.py", "source": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nProvides a queue consumer for RabbitMQ.\n\"\"\"\n\n# standard library\nimport json\nimport logging\nimport os\nimport sys\nfrom multiprocessing import Process\n\n# add path to the Cyphon project folder so Cyphon packages can be found\nCYPHON_PATH = os.path.dirname(os.path.abspath(__file__))\nsys.path.append(CYPHON_PATH)\nsys.path.append(os.path.dirname(os.path.dirname(CYPHON_PATH)))\n\n# set the default Django settings module\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'cyphon.settings.prod')\n\n# add path to virtualenv site packages so required packages can be found\nfrom django.conf import settings\nsys.path.append(settings.REQUIREMENTS)\n\n# load models so this module can be called from the command line\nimport django\ndjango.setup()\n\n# third party\nfrom django.core.exceptions import ObjectDoesNotExist\nimport pika\n\n# local\nfrom cyphon.transaction import close_connection, close_old_connections\nfrom sifter.logsifter.logchutes.models import LogChute\nfrom sifter.logsifter.logmungers.models import LogMunger\n\nLOGGER = logging.getLogger('receiver')\n\nLOGSIFTER = settings.LOGSIFTER\nBROKER = settings.RABBITMQ\n\n\ndef consume_logs():\n    \"\"\"\n    Creates a queue consumer for RabbitMQ.\n    \"\"\"\n    try:\n        credentials = pika.PlainCredentials(username=BROKER['USERNAME'],\n                                            password=BROKER['PASSWORD'])\n\n        parameters = pika.ConnectionParameters(host=BROKER['HOST'],\n                                               virtual_host=BROKER['VHOST'],\n                                               credentials=credentials,\n                                               connection_attempts=6,\n                                               retry_delay=10)\n\n        conn = pika.BlockingConnection(parameters)\n\n        channel = conn.channel()\n        exchange = BROKER['EXCHANGE']\n        exchange_type = BROKER['EXCHANGE_TYPE']\n        routing_key = BROKER['ROUTING_KEY']\n        durable = BROKER['DURABLE']\n        queue_name = BROKER['QUEUE_NAME']\n\n        channel.exchange_declare(exchange=exchange,\n                                 type=exchange_type,\n                                 durable=durable)\n\n        channel.queue_declare(queue=queue_name)\n\n        channel.queue_bind(exchange=exchange,\n                           queue=queue_name,\n                           routing_key=routing_key)\n\n        LOGGER.info('Waiting for logs')\n        # print(' [*] Waiting for logs. To exit press CTRL+C')\n\n        channel.basic_consume(process_msg,\n                              queue=queue_name,\n                              no_ack=True)\n\n        channel.start_consuming()\n\n    except Exception as error:\n        LOGGER.exception('An error occurred while consuming logs:\\n  %s', error)\n\n\n@close_connection\ndef process_msg(channel, method, properties, body):\n    \"\"\"\n    Callback function for a queue consumer.\n\n    Parameters:\n        channel: pika.Channel\n        method: pika.spec.Basic.Return\n        properties: pika.spec.BasicProperties\n        body: str, unicode, or bytes (python 3.x)\n\n    \"\"\"\n    try:\n        if not isinstance(body, str):\n            body = body.decode('utf-8')\n\n        doc = json.loads(body)\n        data = doc.get('message')\n        doc_id = doc.get('@uuid')\n        collection = doc.get('collection')\n        saved = False\n        enabled_chutes = LogChute.objects.find_enabled()\n\n        LOGGER.info('Processing message %s in %s', doc_id, collection)\n\n        for chute in enabled_chutes:\n            result = chute.process(data, doc_id, collection)\n            if result:\n                saved = True\n\n        if not saved and LOGSIFTER['DEFAULT_LOG_CHUTE_ENABLED']:\n            default_munger = get_default_munger()\n            if default_munger:\n                default_munger.process(data, doc_id, collection)\n\n    except Exception as error:\n        LOGGER.exception('An error occurred while processing the message:\\n  %s',\n                         body)\n\n\ndef get_default_munger():\n    \"\"\"\n    Returns the default LogMunger specified in the site configuration.\n    \"\"\"\n    munger_name = LOGSIFTER['DEFAULT_LOG_MUNGER']\n    try:\n        return LogMunger.objects.get(name=munger_name)\n    except ObjectDoesNotExist:\n        LOGGER.error('Default LogMunger \"%s\" is not configured.', munger_name)\n\n\n@close_old_connections\ndef create_consumers(num):\n    \"\"\"\n\n    \"\"\"\n    for dummy_num in range(num):\n        process = Process(target=consume_logs)\n        process.start()\n\n\nif __name__ == '__main__':\n    try:\n        NUM = int(sys.argv[1])\n    except (IndexError, ValueError):\n        NUM = 1\n\n    create_consumers(NUM)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "responder/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "responder/actions/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, null, null, null, null, 1], "name": "responder/actions/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a |ModelAdmin| subclass for |Actions| and registers it with\nthe `Django admin site`_.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom .models import Action\n\n\nclass ActionAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Actions.\n    \"\"\"\n    fields = [\n        'title',\n        'description',\n        'platform',\n        'api_module',\n        'api_class',\n        'visa_required',\n    ]\n\n\nadmin.site.register(Action, ActionAdmin)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, null, null, 0, null, null, 0, null, null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0], "name": "responder/actions/filters.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines filters for Actions.\n\"\"\"\n\n# third party\nfrom django_filters.rest_framework import DjangoFilterBackend\n\n# local\nfrom .models import Action\n\n\nclass ActionFilterBackend(DjangoFilterBackend):\n    \"\"\"\n    Provides a filter backend to only show |Actions| for which the\n    current user has an available |Courier|.\n\n    \"\"\"\n\n    def filter_queryset(self, request, queryset, view):\n        \"\"\"Return a filtered queryset.\n\n        Implements `custom filtering`_.\n\n        Parameters\n        ----------\n        request : Request\n             A |Request| for a resource.\n\n        queryset : QuerySet\n            A |QuerySet| to be filtered.\n\n        view : ModelViewSet\n            A |ModelViewSet|.\n\n        Returns\n        -------\n        QuerySet\n            A |QuerySet| filtered to only show |Actions| for which the\n            current user has an available |Courier|.\n\n        \"\"\"\n        return Action.objects.filter(emissary__passport__users=request.user)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, 1, null, 1, 1, null, 1, null, null, null, null, 0, 0, 0, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, 0, 0], "name": "responder/actions/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines an |Action| class for an API endpoint.\n\"\"\"\n\n# third party\nfrom django.db import models\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom ambassador.endpoints.models import Endpoint, EndpointManager\nfrom responder.destinations.models import Destination\n\n\nclass Action(Endpoint):\n    \"\"\"\n    Specifies the module and |Carrier| class that should be used to\n    access an API endpoint of a |Destination|, such as JIRA. An |Action|\n    can pass an |Alert| to the |Carrier|, which uses it to construct and\n    send a request to the API endpoint. The |Action| then retrieves a\n    |Dispatch| of the API response from the |Carrier|.\n\n    Attributes\n    ----------\n    api_module : str\n        The name of the module that will handle the API request\n        (i.e., the name of the Python file without the extension,\n        e.g., 'handlers').\n\n    api_class : str\n        The name of the class that will handle the API request\n        (e.g., 'SearchAPI').\n\n    visa_required : bool\n        Whether requests to the API endpoint are rate limited.\n        If |True|, an |Emissary| must have a |Visa| to access the\n        |Endpoint|. The |Visa| defines the rate limit that should\n        apply to the |Emissary|'s |Passport| (API key).\n\n    platform : Destination\n        The |Destination| representing the data platform which the API\n        endpoint accesses.\n\n    title : str\n        A short description of the |Action|'s result' (e.g. \"JIRA Issue\").\n\n    description : str\n        A short description of the |Action| (e.g. \"Create a JIRA Issue\").\n\n    \"\"\"\n    platform = models.ForeignKey(\n        Destination,\n        help_text=_('The package that will handle the API request.')\n    )\n    title = models.CharField(\n        max_length=40,\n        unique=True,\n        null=True,\n        help_text=_('A short description of the Action\\'s result '\n                    '(e.g., JIRA Issue). This is used to describe the '\n                    'Dispatch returned by a completed Action.')\n    )\n    description = models.CharField(\n        max_length=40,\n        unique=True,\n        null=True,\n        help_text=_('A short description of the Action in active tense '\n                    '(e.g., \"Create a JIRA Issue\"). This is used to '\n                    'describe the Action in a list of options.')\n    )\n\n    objects = EndpointManager()\n\n    class Meta:\n        unique_together = ('platform', 'api_class')\n\n    def save(self, *args, **kwargs):\n        \"\"\"\n        Overrides the save() method to assign a default description to\n        a new Action using its other attributes.\n        \"\"\"\n        if self.description is None:\n            self.description = str(self)\n        super(Action, self).save(*args, **kwargs)\n\n    def get_dispatch(self, user, alert):\n        \"\"\"Take action on an |Alert| and get a |Dispatch| of the API\n        response.\n\n        Parameters\n        ----------\n        user : |AppUser|\n            The user making the API request.\n\n        alert : |Alert|\n            The |Alert| on which the action is being taken and to which\n            the API request relates.\n\n        Returns\n        -------\n        |Dispatch|\n            A record of the API response.\n\n        \"\"\"\n        transport = self.create_request_handler(user=user)\n        transport.run(alert)\n        return transport.record\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, 1, 1, 1, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, 1, null, null, null, null], "name": "responder/actions/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nSerializers for Contexts.\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom .models import Action\nfrom alerts.models import Alert\n\n\nclass ActionSerializer(serializers.HyperlinkedModelSerializer):\n    \"\"\"\n    Serializer for Actions.\n    \"\"\"\n    name = serializers.CharField(source='description', read_only=True)\n\n    class Meta:\n        model = Action\n        fields = (\n            'url',\n            'name',\n            'id',\n            'api_module',\n            'api_class',\n            'visa_required',\n            'platform'\n        )\n\n\nclass ActionRunSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for the Action Run action.\n    \"\"\"\n    alert = serializers.PrimaryKeyRelatedField(\n        queryset=Alert.objects.all(),\n        required=True\n    )\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, 1, null, null, 1, 1, 1, 1, null, null, 1, null, null, null, 1, 1, 1, 1, null, null, null, null, 1, null, null, null, 0, null, 1, 1, null, null, null, 0, 0, 0, null, 0, 0, 0, 0, 0, 0, null, null, null, 0, null, 0, null, null, null], "name": "responder/actions/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines views for Actions.\n\"\"\"\n\n# third party\nfrom django_filters.rest_framework import DjangoFilterBackend\nfrom rest_framework import status\nfrom rest_framework.response import Response\nfrom rest_framework.decorators import detail_route\nfrom rest_framework.permissions import IsAuthenticated\n\n# local\nfrom cyphon.views import CustomModelViewSet\nfrom responder.dispatches.serializers import DispatchSerializer\nfrom .models import Action\nfrom .serializers import ActionSerializer, ActionRunSerializer\n\n\nclass ActionViewSet(CustomModelViewSet):\n    \"\"\"\n    REST API for Contexts.\n    \"\"\"\n    queryset = Action.objects.all()\n    custom_filter_backends = ['responder.actions.filters.ActionFilterBackend']\n    permission_classes = [IsAuthenticated, ]\n    serializers = {\n        'run': ActionRunSerializer,\n        'default': ActionSerializer\n    }\n\n    def get_serializer_class(self):\n        \"\"\"\n        Overrides the class method to get the serializer for the view.\n        \"\"\"\n        return self.serializers.get(self.action, self.serializers['default'])\n\n    @detail_route(methods=['post'], url_path='run')\n    def run(self, request, pk=None):\n        \"\"\"\n\n        \"\"\"\n        action = self.get_object()\n        serializer_class = self.get_serializer_class()\n        serializer = serializer_class(data=request.data)\n\n        if serializer.is_valid():\n            alert = serializer.validated_data['alert']\n            carrier = action.create_request_handler(user=request.user)\n            carrier.run(alert)\n            dispatch = carrier.record\n            result = DispatchSerializer(\n                dispatch,\n                context={'request': request}\n            ).data\n            return Response(result)\n        else:\n            return Response(\n                serializer.errors,\n                status=status.HTTP_400_BAD_REQUEST\n            )\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null], "name": "responder/carrier.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Carrier class.\n\"\"\"\n\n# local\nfrom ambassador.transport import Transport\nfrom responder.dispatches.models import Dispatch\n\n\nclass Carrier(Transport):\n    \"\"\"\n\n    Attributes\n    ----------\n    endpoint : Action\n\n    emissary : Courier\n\n    user : AppUser\n\n    cargo :  Cargo\n\n    record : Dispatch\n\n\n\n    \"\"\"\n\n    def create_record(self, stamp, obj):\n        \"\"\"\n        Create a record of the response\n\n        Parameters\n        ----------\n        stamp : |Stamp|\n\n        obj : |Alert|\n\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        return Dispatch.objects.create(stamp=stamp, alert=obj)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "responder/couriers/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null], "name": "responder/couriers/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a |ModelAdmin| subclass for Couriers and registers it with\nthe `Django admin site`_.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom .models import Courier\n\n\nclass CourierAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Couriers.\n    \"\"\"\n    exclude = []\n\n\nadmin.site.register(Courier, CourierAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, null, null, 1, null], "name": "responder/couriers/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines classes for handling API keys and API call counts.\n\"\"\"\n\n# third party\nfrom django.db import models\n\n# local\nfrom ambassador.emissaries.models import Emissary, EmissaryManager\nfrom responder.actions.models import Action\n\n\nclass Courier(Emissary):\n    \"\"\"\n    Handles an API key or token (KeySet) for a set of users of a Pipe.\n    Uses a Meter to keep track of the number of calls made using that API key.\n    \"\"\"\n    endpoints = models.ManyToManyField(\n        Action,\n        verbose_name='actions',\n        related_name='emissaries',\n        related_query_name='emissary'\n    )\n\n    objects = EmissaryManager()\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "responder/destinations/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null], "name": "responder/destinations/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclass for Destinations and registers them with\nDjango Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom .models import Destination\n\n\nclass DestinationAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Destinations.\n    \"\"\"\n    list_display = ['id', 'name']\n    exclude = []\n\n\nadmin.site.register(Destination, DestinationAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null], "name": "responder/destinations/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Destination class to determine platforms are enabled for responders.\n\"\"\"\n\n# local\nfrom ambassador.platforms.models import Platform, PlatformManager\n\n\nclass Destination(Platform):\n    \"\"\"\n    Determines whether a platform is enabled for use as a Destination.\n    The platform corresponds to a subpackage in the Platforms package.\n    A Destination's primary key is the name of the subpackage associated\n    with the Destination (e.g., 'twitter').\n    \"\"\"\n    objects = PlatformManager()\n\n    # def __str__(self):\n    #     return self.platform\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, null, 1, 1, 1, null], "name": "responder/destinations/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nSerializers for Destinations.\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom .models import Destination\n\n\nclass DestinationSerializer(serializers.HyperlinkedModelSerializer):\n    \"\"\"\n    Serializer for Destinations.\n    \"\"\"\n\n    class Meta:\n        model = Destination\n        fields = ('__all__')\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null], "name": "responder/destinations/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines views for Destinations.\n\"\"\"\n\n# third party\nfrom rest_framework import viewsets\n\n# local\nfrom .models import Destination\nfrom .serializers import DestinationSerializer\n\n\nclass DestinationViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    REST API for Destinations.\n    \"\"\"\n    queryset = Destination.objects.all()\n    serializer_class = DestinationSerializer\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "responder/dispatches/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, 1, null], "name": "responder/dispatches/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclass for Dispatches and registers them with\nDjango Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom cyphon.admin import JSONDataAdmin\nfrom .models import Dispatch\n\n\nclass DispatchAdmin(JSONDataAdmin):\n    \"\"\"\n    Customizes admin pages for Dispatches.\n    \"\"\"\n    exclude = ['data']\n    readonly_fields = [\n        'alert',\n        'stamp',\n        'data_prettified'\n    ]\n    list_display = [\n        'id',\n        'alert',\n        'get_title',\n        'get_status_code',\n        'get_user'\n    ]\n    search_fields = [\n        'alert__title',\n        'stamp__user__email'\n    ]\n    list_per_page = 25\n    list_select_related = True\n\n    fieldsets = (\n        (None, {\n            'fields': ['alert', 'stamp', 'data_prettified'],\n            'classes': ['pre'],\n        }),\n    )\n\n\nadmin.site.register(Dispatch, DispatchAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, null, null, 1, null, 1, null, 1, 1, null, 1, 0, null, 1, null, null, null, null, 0, null, 1, null, null, null, null, 0, null, 1, null, null, null, null, 0, null, 1, null, null, null, null, 0, null, 1, null, null, null, 0, null, 1, null, 1, null, null, null, 0, 0, null, 1, null, 1, null, null, null, 0, null, 1, null, 1, null, null, null, null, 0, null, null, 0, 0, null], "name": "responder/dispatches/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Dispatch class.\n\"\"\"\n\n# third party\nfrom django.db import models\nfrom django.contrib.postgres.fields.jsonb import JSONField\nfrom django.utils.functional import cached_property\n\n# local\nfrom alerts.models import Alert\nfrom ambassador.records.models import Record, RecordManager\n\n\nclass Dispatch(Record):\n    \"\"\"\n    A Record of an API call by a Courier.\n    \"\"\"\n    alert = models.ForeignKey(\n        Alert,\n        related_name='dispatches',\n        related_query_name='dispatch'\n    )\n    data = JSONField(blank=True, null=True)\n\n    objects = RecordManager()\n\n    class Meta:\n        verbose_name_plural = 'dispatches'\n\n    def __str__(self):\n        return 'Dispatch %s' % self.pk\n\n    @cached_property\n    def title(self):\n        \"\"\"\n\n        \"\"\"\n        return self.get_title()\n\n    @cached_property\n    def issued_by(self):\n        \"\"\"\n\n        \"\"\"\n        return self.get_user()\n\n    @cached_property\n    def status_code(self):\n        \"\"\"\n\n        \"\"\"\n        return self.get_status_code()\n\n    @cached_property\n    def response_msg(self):\n        \"\"\"\n\n        \"\"\"\n        return self.stamp.notes\n\n    def get_status_code(self):\n        \"\"\"\n\n        \"\"\"\n        return self.stamp.status_code\n\n    get_status_code.short_description = 'status code'\n\n    def get_title(self):\n        \"\"\"\n            \n        \"\"\"\n        action = self.get_endpoint()\n        return action.title\n\n    get_title.short_description = 'title'\n\n    def get_user(self):\n        \"\"\"\n        \n        \"\"\"\n        return self.stamp.user\n\n    get_user.short_description = 'user'\n\n    def finalize(self, cargo):\n        \"\"\"\n\n        \"\"\"\n        # copy cargo.notes to dispatch.stamp.notes\n        super(Dispatch, self).finalize(cargo)\n\n        # copy cargo.data to dispatch.data\n        self.data = cargo.data\n        self.save()\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, 1, 1, 1, null, null, null, null, null, null, null], "name": "responder/dispatches/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nSerializers for Dispatches.\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom appusers.serializers import AppUserSerializer\nfrom .models import Dispatch\n\n\nclass DispatchSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Dispatches.\n    \"\"\"\n    issued_by = AppUserSerializer()\n\n    class Meta:\n        model = Dispatch\n        fields = (\n            'id',\n            'title',\n            'issued_by',\n            'status_code',\n            'response_msg',\n            'data',\n        )\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, 1, null], "name": "responder/dispatches/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines views for Dispatches.\n\"\"\"\n\n# third party\nfrom rest_framework import viewsets\n\n# local\nfrom .models import Dispatch\nfrom .serializers import DispatchSerializer\n\n\nclass DispatchViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    REST API for Dispatches.\n    \"\"\"\n    queryset = Dispatch.objects.all()\n    serializer_class = DispatchSerializer\n    filter_fields = ('alert',)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/chutes/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, null], "name": "sifter/chutes/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n\nclass ChuteAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Chutes.\n    \"\"\"\n    list_display = ['sieve', 'munger', 'enabled']\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, 0, 0, 0, 0, null, null, null, 1, null, null, null, 1, null, 1, null, null, null, 1, 1, 1, null, 1, 0, 0, null, 0, null, 1, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, 0, 0, 0, null], "name": "sifter/chutes/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# standard library\nimport logging\n\n# third party\nfrom django.db import models\nfrom django.core.exceptions import ObjectDoesNotExist\n\n# local\nfrom cyphon.models import SelectRelatedManager, FindEnabledMixin\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass ChuteManager(SelectRelatedManager, FindEnabledMixin):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def get_by_natural_key(self, sieve, munger):\n        \"\"\"\n        Allow retrieval of a DataChute by its natural key instead of its\n        primary key.\n        \"\"\"\n        try:\n            return self.get(sieve=sieve, munger=munger)\n        except ObjectDoesNotExist:\n            LOGGER.error('%s for sieve %s and munger %s does not exist',\n                         self.model.__name__, sieve, munger)\n\n\nclass Chute(models.Model):\n    \"\"\"\n\n    \"\"\"\n    enabled = models.BooleanField(default=True)\n\n    class Meta:\n        \"\"\"\n        Metadata options for a Django Model.\n        \"\"\"\n        abstract = True\n        unique_together = ('sieve', 'munger')\n        ordering = ['sieve', 'munger']\n\n    def __str__(self):\n        if self.sieve:\n            return '%s -> %s' % (self.sieve, self.munger)\n        else:\n            return '-> %s' % self.munger\n\n    def _is_match(self, data):\n        \"\"\"\n        Takes a data dictionary and returns True if the dictionary\n        matches the rules defined by the Chute's sieve. Otherwise,\n        returns False.\n        \"\"\"\n        if self.sieve:\n            return self.sieve.is_match(data)\n        else:\n            return True\n\n    def _munge(self, data, doc_id=None, collection=None, platform=None):\n        \"\"\"\n        Takes a data dictionary, a document id, and a string indicating the\n        source of the data. Processes the data with the Chute's munger,\n        and returns the document id of the distilled document.\n        \"\"\"\n        return self.munger.process(data, doc_id, collection, platform)\n\n    def process(self, data, doc_id=None, collection=None, platform=None):\n        \"\"\"\n        Takes a data dictionary, a document id, and a string indicating\n        the source of the data. Determines if the data is a match for the\n        Chute's sieve. If it is, processes the data with the Chute's\n        munger and returns the document id of the distilled document.\n        Otherwise, returns None.\n        \"\"\"\n        if self.enabled and self._is_match(data):\n            return self._munge(data, doc_id, collection, platform)\n\n    def thread_process(self, queue, **kwargs):\n        \"\"\"\n        Takes a Queue, a data dictionary, a document id, and a string\n        indicating the source of the data. Determines if the data is a\n        match for the Chute's sieve. If it is, processes the data with\n        the Chute's munger and returns the document id of the distilled\n        document. Otherwise, returns None.\n        \"\"\"\n        result = self.process(**kwargs)\n        if result is not None:\n            queue.put(True)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/condensers/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, null, 1, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, null, 1, 1, null, null, null], "name": "sifter/condensers/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclasses for Fittings and Condensers.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.admin import ConfigToolAdmin, CONFIG_TOOL_CLASSES\nfrom cyphon.forms import CONFIG_TOOL_INPUTS\n\n\nclass CondenserAdmin(ConfigToolAdmin):\n    \"\"\"\n    Customizes admin pages for DataCondensers.\n    \"\"\"\n    list_display = [\n        'name',\n        'bottle',\n    ]\n    list_display_links = ['name', ]\n    save_as = True\n    fieldsets = (\n        ('Test this condenser', {\n            'classes': CONFIG_TOOL_CLASSES,\n            'description': _('Enter a test string and click \"Run test\" '\n                             'to check how the data will be parsed.'),\n            'fields': CONFIG_TOOL_INPUTS,\n        }),\n        (None, {\n            'fields': [\n                'name',\n                'bottle',\n            ]\n        }),\n    )\n\n\nclass FittingInLineAdmin(admin.TabularInline):\n    \"\"\"\n    Customizes admin inline tables for Fittings.\n    \"\"\"\n    related_lookup_fields = {\n        'generic': [['content_type', 'object_id'], ],\n    }\n    extra = 1\n\n\nclass FittingAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for DataFittings.\n    \"\"\"\n    list_display = [\n        'id',\n        'condenser',\n        'target_field_name',\n        'target_field_type',\n        'fitting_type',\n    ]\n    list_display_links = ['id', ]\n    related_lookup_fields = {\n        'generic': [['content_type', 'object_id'], ],\n    }\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, 0, null, 0, null, null, 0, 0, null, 0, null, null, 1, null, null, null, 1, null, null, null, null, 1, null, null, null, null, 0, null, null, 0, null, null, 0, null, null, 0, null, 0, null, 0, null, 0, 0, 0, null, 0, 0, null, 0, null, null, 1, null, null, null, 1, null, 1, null, null, null, null, 1, null, null, null, null, 0, 0, null, 0, null, 1, null, null, null, null, 0, null, null, 0, null, null, 0, null, null, 0, null, 0, null, 0, 0, null, null, 0, 0, 0, null, 0, 0, null, 0, null], "name": "sifter/condensers/autocomplete.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines Autocomplete models for use in admin pages for the DataCondensers app.\n\"\"\"\n\n# standard library\nimport json\n\n# third party\nimport autocomplete_light.shortcuts as autocomplete_light\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom bottler.bottles.models import BottleField\nfrom sifter.condensers.models import Condenser, Fitting\n\n\nclass FilterTargetFieldsAutocomplete(autocomplete_light.AutocompleteModelBase):\n    \"\"\"\n    Defines autocomplete rules for target_fields on the DataFitting and\n    DataCondenser admin pages.\n    \"\"\"\n    model = BottleField\n    search_fields = ('field_name', )\n\n    def autocomplete_html(self):\n        \"\"\"\n        Overrides rendering of the autocomplete.\n        \"\"\"\n        no_matches_msg = 'no unmapped fields found'\n\n        html = ''.join(\n            [self.choice_html(c) for c in self.choices_for_request()])\n\n        if not html:\n            html = self.empty_html_format % _(no_matches_msg).capitalize()\n\n        return self.autocomplete_html_format % html\n\n\nclass FilterTargetFieldsByBottle(FilterTargetFieldsAutocomplete):\n    \"\"\"\n    Defines autocomplete rules for target_field on the DataCondenser admin page.\n    \"\"\"\n    attrs = {\n        'data-autocomplete-minimum-characters': 0,\n        'placeholder': 'select a bottle and click to see options...'\n    }\n\n    def choices_for_request(self):\n        \"\"\"\n        Filters target_field options based on a selected Bottle/DataCondenser\n        and previously selected target_fields.\n        \"\"\"\n        choices = ()\n\n        # text typed in autocomplete input\n        query = self.request.GET.get('q', '').lower().strip()\n\n        # selected bottle on DataCondenser admin page\n        bottle_id = self.request.GET.get('bottle', None)\n\n        # list of target_fields already selected on DataCondenser admin page\n        target_field_list = self.request.GET.get('target_field_list', None)\n\n        if bottle_id:\n\n            choices = BottleField.objects.filter(bottle=bottle_id)\n\n            if target_field_list:\n                target_fields = json.loads(target_field_list)\n                choices = choices.exclude(pk__in=target_fields)\n\n            if query:\n                choices = choices.filter(field_name__icontains=query)\n\n        return self.order_choices(choices)[0:self.limit_choices]\n\n\nclass FilterTargetFieldsByCondenser(FilterTargetFieldsAutocomplete):\n    \"\"\"\n    Defines autocomplete rules for target_field on the DataFitting admin page.\n    \"\"\"\n    model = None\n\n    attrs = {\n        'data-autocomplete-minimum-characters': 0,\n        'placeholder': 'select a condenser and click to see options...'\n    }\n\n    @property\n    def fitting(self):\n        \"\"\"\n        Returns the model_name of the Conderser's Fitting.\n        \"\"\"\n        for field in self.model._meta.get_fields():\n            if hasattr(field, 'related_model') \\\n                    and issubclass(field.related_model, Fitting):\n                return field.related_model._meta.model_name\n\n    def choices_for_request(self):\n        \"\"\"\n        Filters target_field options based on a selected Bottle/DataCondenser\n        and previously selected target_fields.\n        \"\"\"\n        assert issubclass(self.model, Condenser), \\\n            'model must be a type of condenser'\n\n        choices = ()\n\n        # text typed in autocomplete input\n        query = self.request.GET.get('q', '').lower().strip()\n\n        # selected condenser on DataFitting admin page\n        condenser_id = self.request.GET.get('condenser', None)\n\n        if condenser_id:\n\n            condenser = self.model.objects.get(pk=condenser_id)\n            choices = BottleField.objects.filter(bottle=condenser.bottle)\n\n            # exclude BottleFields that are already fitted to this condenser\n            if self.fitting:\n                kwargs = {self.fitting + '__condenser': condenser}\n                choices = choices.exclude(**kwargs)\n\n            if query:\n                choices = choices.filter(field_name__icontains=query)\n\n        return self.order_choices(choices)[0:self.limit_choices]\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, 1, null, null, null, null, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, 1, 1, null, null, null, null, 1, 1, 1, 1, 1, null], "name": "sifter/condensers/forms.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines forms for Fittings and Condensers.\n\"\"\"\n\n# third party\nfrom autocomplete_light import forms as auto_forms\n\n# local\nfrom cyphon.forms import ConfigToolForm\n\n\nclass ParserForm(ConfigToolForm):\n    \"\"\"\n    Defines a form for adding or updating a Parser.\n    \"\"\"\n    pass\n\n\nclass CondenserForm(auto_forms.ModelForm, ConfigToolForm):\n    \"\"\"\n    Defines a form for adding or updating a Condenser using autocomplete\n    fields.\n    \"\"\"\n    pass\n\n\nclass FittingForm(auto_forms.ModelForm):\n    \"\"\"\n    Defines a form for adding or updating a Fitting using autocomplete\n    fields.\n    \"\"\"\n\n    class Media:\n        js = [\n            'js/dependent_autocomplete.js',\n            'js/fitting_autocomplete.js',\n        ]\n\n    class Meta:\n        exclude = []\n        fields = ['condenser', 'target_field', 'content_type', 'object_id']\n        autocomplete_fields = ['target_field']\n        autocomplete_names = {'target_field': 'FilterTargetFieldsByCondenser'}\n\n\nclass FittingInlineForm(auto_forms.ModelForm):\n    \"\"\"\n    Defines an inline form for adding or updating a Fitting using\n    autocomplete fields.\n    \"\"\"\n\n    class Media:\n        js = [\n            'js/dependent_autocomplete.js',\n            'js/fitting_inline_autocomplete.js',\n        ]\n\n    class Meta:\n        exclude = []\n        fields = ['condenser', 'target_field', 'content_type', 'object_id']\n        autocomplete_fields = ['target_field']\n        autocomplete_names = {'target_field': 'FilterTargetFieldsByBottle'}\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, 1, null, null, 1, 1, 1, 1, null, null, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, 1, 1, null, 1, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, 1, null, 1, 1, 1, null, null, null, 1, 1, null, null, 1, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, 0, null, null, 1, 0, 0, null, null, 0, null, 1, 1, null, 1, 1, null, 1, 1, null, 1, null, null, null, 1, 1, null, null, null, 1, 1, null, null, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, null, null, 0, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 0, null, 1, null, null, null, null, 1, null, 1, null, null, null, 1, null, 1, null, null, null, 1, null, 1, null, null, null, null, null, null, 1, null], "name": "sifter/condensers/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nProvides abstract classes for defining a crosswalk between a custom data model and\na model used by an external data platform, such as Twitter.\n\nThe crosswalk allows data from a Pipe to be saved in a user-defined format\n(i.e., a Bottle).\n\"\"\"\n\n# standard library\nimport logging\n\n# third party\nfrom django.db import models\nfrom django.contrib.contenttypes.fields import GenericForeignKey\nfrom django.core.exceptions import ValidationError\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom bottler.bottles.models import Bottle, BottleField\nfrom parsers.models import Parser\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass Condenser(models.Model):\n    \"\"\"\n    Defines a crosswalk for transforming data into a user-defined format defined\n    by a custom Bottle.\n\n    A Condenser is composed of Fittings between the fields in a Bottle object\n    and the fields in an object returned by a Pipe or a Chute.\n    \"\"\"\n    name = models.CharField(\n        max_length=40,\n        unique=True,\n        help_text=_('It\\'s a good idea to name condensers after the type of '\n                    'data they are condensing, e.g., \"email,\" \"tweet,\" etc.')\n    )\n    bottle = models.ForeignKey(\n        Bottle,\n        help_text=_('The bottle (custom data  model) into which the raw data '\n                    'will be distilled and stored.')\n    )\n\n    class Meta:\n        abstract = True\n\n    def __str__(self):\n        return self.name\n\n    def field_is_in_bottle(self, bottlefield):\n        \"\"\"\n        Takes a BottleField and returns a Boolean indicating whether the\n        field is present in the Bottle associated with the chosen Condenser.\n        \"\"\"\n        return self.bottle.field_exists(bottlefield)\n\n    # def process(self, data):\n    #     \"\"\"\n    #     Takes a dictionary of data and returns a dictionary that distills the\n    #     data using the crosswalk defined by the Condenser.\n    #     \"\"\"\n    #     custom_doc = {}\n    #     for fitting in self.fittings.all():\n    #         custom_doc[fitting.target_field_name] = fitting.process(data)\n\n    #     return custom_doc\n\n    def _condense(self, data, condenser, **kwargs):\n        \"\"\"\n        Takes a dictionary of data (e.g., of a social media post) and a\n        Condenser. Returns a dictionary that distills the data\n        using the crosswalk defined by the Condenser.\n        \"\"\"\n        custom_doc = {}\n\n        for fitting in condenser.fittings.all():\n\n            if fitting.is_parser():\n                value = fitting.process(data=data, **kwargs)\n                custom_doc[fitting.target_field_name] = value\n\n            # if the field represents another Bottle, use recursion\n            else:\n                condenser = fitting.field_parser\n                custom_doc[fitting.target_field_name] = self._condense(\n                    data=data, condenser=condenser, **kwargs)\n\n        return custom_doc\n\n    def process(self, data, **kwargs):\n        \"\"\"\n        Takes a dictionary of data (e.g., of a social media post) and a\n        Condenser. Returns a dictionary that distills the data\n        using the crosswalk defined by the Condenser.\n        \"\"\"\n        return self._condense(data=data, condenser=self, **kwargs)\n\n\nclass Fitting(models.Model):\n    \"\"\"\n    Defines a mapping between a BottleField and a field in an object returned by\n    a Pipe or a Chute.\n\n    Attributes:\n        target_field: the BottleField into which the value will be saved\n        object_id: the primary key of the Parser or Condenser\n        field_parser: a Parser or Condenser associated with the Fitting\n\n    Implement in subclasses:\n        content_type: the ContentType associated with the Fitting, which can\n            either be a Parser or a Condenser (for an EmbeddedDocument)\n\n\n    Derived classes should also implement a condenser attribute, which specifies\n    the Condenser to which the Fitting belongs.\n\n    \"\"\"\n    CONTENT_TYPES = None\n\n    object_id = models.PositiveIntegerField(\n        verbose_name=_('parser id'),\n        help_text=_('The id of the object that will parse the data.')\n    )\n    field_parser = GenericForeignKey()\n\n    target_field = models.ForeignKey(\n        BottleField,\n        help_text=_('The name of the field in the condenser\\'s bottle, '\n                    'where the parsed data will be stored.')\n    )\n\n    def __init__(self, *args, **kwargs):\n        super(Fitting, self).__init__(*args, **kwargs)\n\n        if self.CONTENT_TYPES is None:\n            raise NotImplementedError('CONTENT_TYPES need to be defined '\n                                      'for this model.')\n\n    def __str__(self):\n        if self.pk:\n            return \"%s <- %s (%s)\" % (self.target_field, self.field_parser,\n                                      self.fitting_type)\n        else:\n            return super(Fitting, self).__str__()\n\n    class Meta:\n        abstract = True\n\n    def clean(self):\n        super(Fitting, self).clean()\n\n        if hasattr(self, 'condenser') and hasattr(self, 'target_field'):\n            if hasattr(self.condenser, 'bottle') \\\n                    and not self._field_is_in_bottle():\n                raise ValidationError(\n                    _('The selected target field is not compatible with '\n                      'the condenser\\'s bottle.'))\n\n            elif self._target_is_embedded_doc() and not self.is_condenser():\n                raise ValidationError(\n                    _('If the target field is an EmbeddedDocument, '\n                      'the content type must be a condenser.'))\n\n            elif not self._target_is_embedded_doc() and self.is_condenser():\n                raise ValidationError(\n                    _('Unless the target field is an EmbeddedDocument, '\n                      'the content type must be a parser.'))\n\n    @property\n    def _content_class(self):\n        \"\"\"\n        Returns the class for the type of fitting, which can be either a Parser\n        or another Condenser.\n        \"\"\"\n        return self.content_type.model_class()\n\n    @property\n    def fitting_type(self):\n        \"\"\"\n        Returns the name of the class for the type of fitting, which can be\n        either a Parser or another Condenser.\n        \"\"\"\n        return self.content_type.model\n\n    @property\n    def target_field_name(self):\n        \"\"\"\n        Returns the name of the field used to store the value extracted from the\n        raw data.\n        \"\"\"\n        return self.target_field.field_name\n\n    @property\n    def target_field_type(self):\n        \"\"\"\n        Returns a string indicating the type of field used to store the value\n        extracted from the raw data (e.g., \"CharField\").\n        \"\"\"\n        return self.target_field.field_type\n\n    def _target_is_embedded_doc(self):\n        \"\"\"\n        Returns a Boolean indicating whether the target_field is an\n        EmbeddedDocument.\n        \"\"\"\n        return self.target_field_type == 'EmbeddedDocument'\n\n    def _get_condenser_fields(self):\n        \"\"\"\n        Returns a QuerySet of BottleFields associated with the Fitting's\n        Condenser.\n        \"\"\"\n        return self.condenser.get_fields()\n\n    def _field_is_in_bottle(self):\n        \"\"\"\n        Returns a Boolean indicating whether the target_field is present in the\n        Bottle associated with the chosen Condenser.\n        \"\"\"\n        return self.condenser.field_is_in_bottle(self.target_field)\n\n    def is_parser(self):\n        \"\"\"\n        Returns a Boolean indicating whether the Fitting is a Parser.\n        \"\"\"\n        return issubclass(self._content_class, Parser)\n\n    def is_condenser(self):\n        \"\"\"\n        Returns a Boolean indicating whether the Fitting is a Condenser.\n        \"\"\"\n        return issubclass(self._content_class, Condenser)\n\n    def process(self, data, *args, **kwargs):\n        \"\"\"\n        Takes a dictionary of data and returns the condensed result.\n        \"\"\"\n        # NOTE: for this to work, both Condensers and Parsers need a process()\n        # method to handle data, since the field_parser can be either a\n        # Condenser or a Parser\n        return self.field_parser.process(data, *args, **kwargs)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/datasifter/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/datasifter/datachutes/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null], "name": "sifter/datasifter/datachutes/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclass for DataChutes and registers them with\nDjango Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom sifter.chutes.admin import ChuteAdmin\nfrom sifter.datasifter.datachutes.models import DataChute\n\n\nclass DataChuteAdmin(ChuteAdmin):\n    \"\"\"\n    Customizes admin pages for DataChutes.\n    \"\"\"\n    pass\n\n\nadmin.site.register(DataChute, DataChuteAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, 1, null, 1, null, null, null, 0, 0, null, 1, null, null, null, 1, 1, null], "name": "sifter/datasifter/datachutes/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# standard library\nimport logging\n\n# third party\nfrom django.db import models\n\n# local\nfrom aggregator.pipes.models import Pipe\nfrom sifter.chutes.models import Chute, ChuteManager\nfrom sifter.datasifter.datasieves.models import DataSieve\nfrom sifter.datasifter.datamungers.models import DataMunger\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass DataChuteManager(ChuteManager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def find_by_endpoint(self, endpoint):\n        \"\"\"\n        Returns a QuerySet object containing only enabled Chutes\n        for the gievn endpoint.\n        \"\"\"\n        enabled_chutes = super(DataChuteManager, self).find_enabled()\n        return enabled_chutes.filter(endpoint=endpoint)\n\n\nclass DataChute(Chute):\n    \"\"\"\n\n    \"\"\"\n    sieve = models.ForeignKey(\n        DataSieve,\n        null=True,\n        blank=True,\n        default=None,\n        related_name='chutes',\n        related_query_name='chute'\n    )\n    munger = models.ForeignKey(DataMunger)\n    endpoint = models.ForeignKey(Pipe)\n\n    objects = DataChuteManager()\n\n    def _get_platform_name(self):\n        \"\"\"\n\n        \"\"\"\n        return self.endpoint.platform.name\n\n    def bulk_process(self, data):\n        \"\"\"\n\n        \"\"\"\n        for doc in data:\n            self.process(doc)\n\n    def process(self, data):\n        \"\"\"\n        Overrides the parent method to add platform info to the data.\n        \"\"\"\n        platform = self._get_platform_name()\n        return super(DataChute, self).process(data, platform=platform)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/datasifter/datacondensers/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, 1, null, null, null, null, 1, 1, null, null, null, null, null, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, null, null, 1, 1, 1, null], "name": "sifter/datasifter/datacondensers/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclasses for DataParsers, DataCondensers, and\nDataFittings, and registers them with Django Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom parsers.admin import FieldParserAdmin\nfrom sifter.condensers.admin import (\n    FittingInLineAdmin,\n    FittingAdmin,\n    CondenserAdmin\n)\nfrom .models import DataCondenser, DataParser, DataFitting\nfrom .forms import (\n    DataCondenserForm,\n    DataFittingForm,\n    DataFittingInlineForm,\n    DataParserForm\n)\n\n\nclass DataParserAdmin(FieldParserAdmin):\n    \"\"\"\n    Customizes admin pages for DataParsers.\n    \"\"\"\n    model = DataParser\n    form = DataParserForm\n\n\nclass DataFittingInLineAdmin(FittingInLineAdmin):\n    \"\"\"\n    Customizes admin inline tables for DataFittings.\n    \"\"\"\n    model = DataFitting\n    form = DataFittingInlineForm\n\n\nclass DataFittingAdmin(FittingAdmin):\n    \"\"\"\n    Customizes admin pages for DataFittings.\n    \"\"\"\n    form = DataFittingForm\n\n\nclass DataCondenserAdmin(CondenserAdmin):\n    \"\"\"\n    Customizes admin pages for DataCondensers.\n    \"\"\"\n    data_format = 'json'\n    inlines = [DataFittingInLineAdmin, ]\n    form = DataCondenserForm\n\n\nadmin.site.register(DataParser, DataParserAdmin)\nadmin.site.register(DataCondenser, DataCondenserAdmin)\nadmin.site.register(DataFitting, DataFittingAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, 1, null], "name": "sifter/datasifter/datacondensers/autocomplete_light_registry.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines Autocomplete models for use in admin pages for the DataCondensers app.\n\"\"\"\n\n# third party\nimport autocomplete_light.shortcuts as autocomplete_light\n\n# local\nfrom sifter.condensers.autocomplete import (\n    FilterTargetFieldsByBottle,\n    FilterTargetFieldsByCondenser,\n)\nfrom .models import DataCondenser\n\n\nclass FilterTargetFieldsByDataCondenser(FilterTargetFieldsByCondenser):\n    \"\"\"\n    Defines autocomplete rules for target_field on the DataFitting admin page.\n    \"\"\"\n    model = DataCondenser\n\n\nautocomplete_light.register(FilterTargetFieldsByBottle)\nautocomplete_light.register(FilterTargetFieldsByDataCondenser)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, 1, 1, null, null, null, null, 1, null, null, null, null, null, 1, 1, null], "name": "sifter/datasifter/datacondensers/forms.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines forms for DataFittings and DataCondensers.\n\"\"\"\n\n# third party\nimport autocomplete_light\n\n# local\nfrom sifter.condensers.forms import (\n    CondenserForm,\n    FittingForm,\n    FittingInlineForm,\n    ParserForm\n)\nfrom .models import DataCondenser, DataFitting, DataParser\n\n\nclass DataParserForm(ParserForm):\n    \"\"\"\n    Defines a form for adding or updating a LogParser using autocomplete\n    fields.\n    \"\"\"\n\n    class Meta(ParserForm.Meta):\n        model = DataParser\n\n\nclass DataCondenserForm(CondenserForm):\n    \"\"\"\n    Defines a form for adding or updating a DataCondenser using autocomplete\n    fields.\n    \"\"\"\n\n    class Meta(CondenserForm.Meta):\n        model = DataCondenser\n\n\nclass DataFittingForm(FittingForm):\n    \"\"\"\n    Defines a form for adding or updating a DataFitting using autocomplete\n    fields.\n    \"\"\"\n\n    class Meta(FittingForm.Meta):\n        model = DataFitting\n        autocomplete_names = {\n            'target_field': 'FilterTargetFieldsByDataCondenser'\n        }\n\n\nclass DataFittingInlineForm(FittingInlineForm):\n    \"\"\"\n    Defines an inline form for adding or updating a DataFitting using\n    autocomplete fields.\n    \"\"\"\n\n    class Meta(FittingInlineForm.Meta):\n        model = DataFitting\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, 1, 1, null, null, 1, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, null, 1, null, 1, null, null, null], "name": "sifter/datasifter/datacondensers/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines DataParser, DataCondenser, and DataFittings classes for distilling\ndata from an external data model into a custom data model (Container).\nA DataCondenser defines a crosswalk between the two data models.\n\"\"\"\n\n# third party\nfrom django.db import models\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.models import GetByNameManager\nfrom parsers.models import FieldParser\nfrom sifter.condensers.models import Condenser, Fitting\n\n\nclass DataParser(FieldParser):\n    \"\"\"\n    A class for parsing data from API responses.\n    \"\"\"\n    objects = GetByNameManager()\n\n\nclass DataCondenser(Condenser):\n    \"\"\"\n    A Condenser for distilling data from API responses.\n    \"\"\"\n    objects = GetByNameManager()\n\n\nclass DataFitting(Fitting):\n    \"\"\"\n    A Fitting used for distilling data from API responses.\n    \"\"\"\n    CONDENSER = models.Q(app_label='datacondensers', model='datacondenser')\n    PARSER = models.Q(app_label='datacondensers', model='dataparser')\n    CONTENT_TYPES = PARSER | CONDENSER\n\n    condenser = models.ForeignKey(DataCondenser, related_name='fittings',\n                                  related_query_name='fitting')\n    content_type = models.ForeignKey(ContentType,\n                                     limit_choices_to=CONTENT_TYPES,\n                                     verbose_name=_('parser type'))\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/datasifter/datamungers/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null], "name": "sifter/datasifter/datamungers/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclass for DataMungers and registers them with\nDjango Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom sifter.mungers.admin import MungerAdmin\nfrom sifter.datasifter.datamungers.models import DataMunger\n\n\nclass DataMungerAdmin(MungerAdmin):\n    \"\"\"\n    Customizes admin pages for DataMungers.\n    \"\"\"\n    pass\n\n\nadmin.site.register(DataMunger, DataMungerAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, 1, null, 1, null], "name": "sifter/datasifter/datamungers/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.db import models\n\n# local\nfrom cyphon.models import GetByNameManager\nfrom sifter.mungers.models import Munger\nfrom sifter.datasifter.datacondensers.models import DataCondenser\n\n\nclass DataMunger(Munger):\n    \"\"\"\n\n    Attributes:\n        condenser: a DataCondenser used to distill the message into the chosen\n                   Bottle\n\n    \"\"\"\n    condenser = models.ForeignKey(DataCondenser)\n\n    objects = GetByNameManager()\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/datasifter/datasieves/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, 1, 1, null], "name": "sifter/datasifter/datasieves/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom sifter.sieves.admin import (\n    FieldRuleAdmin,\n    SieveNodeInLineAdmin,\n    SieveNodeAdmin,\n    SieveAdmin\n)\nfrom .models import DataRule, DataSieve, DataSieveNode\n\n\nclass DataRuleAdmin(FieldRuleAdmin):\n    \"\"\"\n    Customizes admin inline tables for LogSieveNodes.\n    \"\"\"\n    pass\n\n\nclass DataSieveNodeInLineAdmin(SieveNodeInLineAdmin):\n    \"\"\"\n    Customizes admin inline tables for DataSieveNodes.\n    \"\"\"\n    model = DataSieveNode\n\n\nclass DataSieveAdmin(SieveAdmin):\n    \"\"\"\n    Customizes admin pages for DataSieves.\n    \"\"\"\n    inlines = [DataSieveNodeInLineAdmin, ]\n\n\nadmin.site.register(DataRule, DataRuleAdmin)\nadmin.site.register(DataSieve, DataSieveAdmin)\nadmin.site.register(DataSieveNode, SieveNodeAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, null, 1, null, null, null, null, null, 1, null, null, null], "name": "sifter/datasifter/datasieves/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.db import models\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.models import GetByNameManager\nfrom sifter.sieves.models import FieldRule, Sieve, SieveManager, SieveNode\n\n\nclass DataRule(FieldRule):\n    \"\"\"\n\n    \"\"\"\n    objects = GetByNameManager()\n\n\nclass DataSieve(Sieve):\n    \"\"\"\n    A RuleSet subclass for examining bottled data.\n    \"\"\"\n    objects = SieveManager()\n\n\nclass DataSieveNode(SieveNode):\n    \"\"\"\n    A RuleSetNode subclass for examining data dictionaries.\n    \"\"\"\n    RULE = models.Q(app_label='datasieves', model='datarule')\n    RULESET = models.Q(app_label='datasieves', model='datasieve')\n    CONTENT_TYPES = RULE | RULESET\n\n    sieve = models.ForeignKey(\n        DataSieve,\n        related_name='nodes',\n        related_query_name='node',\n        help_text=_('A rule or rule set to assign to the node.')\n    )\n    content_type = models.ForeignKey(ContentType,\n                                     limit_choices_to=CONTENT_TYPES,\n                                     verbose_name=_('node type'))\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/logsifter/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/logsifter/logchutes/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null], "name": "sifter/logsifter/logchutes/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclass for LogChutes and registers them with\nDjango Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom sifter.chutes.admin import ChuteAdmin\nfrom sifter.logsifter.logchutes.models import LogChute\n\n\nclass LogChuteAdmin(ChuteAdmin):\n    \"\"\"\n    Customizes admin pages for LogChutes.\n    \"\"\"\n    pass\n\n\nadmin.site.register(LogChute, LogChuteAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, 1, null, null, 1, null, null, null, 1, null, 1, null, 1, null], "name": "sifter/logsifter/logchutes/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.db import models\n\n# local\nfrom sifter.chutes.models import Chute, ChuteManager\nfrom sifter.logsifter.logsieves.models import LogSieve\nfrom sifter.logsifter.logmungers.models import LogMunger\n\n\nclass LogChute(Chute):\n    \"\"\"\n\n    \"\"\"\n    sieve = models.ForeignKey(LogSieve, null=True, blank=True, default=None,\n                              related_name='chutes', related_query_name='chute')\n    munger = models.ForeignKey(LogMunger)\n\n    objects = ChuteManager()\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/logsifter/logcondensers/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, 1, null, null, null, null, 1, 1, null, null, null, null, null, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, 1, 1, null], "name": "sifter/logsifter/logcondensers/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclasses for LogParsers, LogCondensers, and\nLogFittings, and registers them with Django Admin.\n\"\"\"\n\n# third party\nimport autocomplete_light\nfrom django.contrib import admin\n\n# local\nfrom parsers.admin import ParserAdmin\nfrom sifter.condensers.admin import (\n    FittingInLineAdmin,\n    FittingAdmin,\n    CondenserAdmin\n)\nfrom .models import LogParser, LogCondenser, LogFitting\nfrom .forms import (\n    LogFittingInlineForm,\n    LogFittingForm,\n    LogCondenserForm,\n    LogParserForm\n)\n\n\nclass LogParserAdmin(ParserAdmin):\n    \"\"\"\n    Customizes admin pages for LogParsers.\n    \"\"\"\n    model = LogParser\n    form = LogParserForm\n\n\nclass LogFittingInLineAdmin(FittingInLineAdmin):\n    \"\"\"\n    Customizes admin inline tables for DataFittings.\n    \"\"\"\n    model = LogFitting\n    form = LogFittingInlineForm\n\n\nclass LogFittingAdmin(FittingAdmin):\n    \"\"\"\n    Customizes admin pages for DataFittings.\n    \"\"\"\n    form = LogFittingForm\n\n\nclass LogCondenserAdmin(CondenserAdmin):\n    \"\"\"\n    Customizes admin pages for DataCondensers.\n    \"\"\"\n    inlines = [LogFittingInLineAdmin, ]\n    form = LogCondenserForm\n\n\nadmin.site.register(LogParser, LogParserAdmin)\nadmin.site.register(LogCondenser, LogCondenserAdmin)\nadmin.site.register(LogFitting, LogFittingAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, 1, null], "name": "sifter/logsifter/logcondensers/autocomplete_light_registry.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines Autocomplete models for use in admin pages for the LogCondensers app.\n\"\"\"\n\n# third party\nimport autocomplete_light.shortcuts as autocomplete_light\n\n# local\nfrom sifter.condensers.autocomplete import (\n    FilterTargetFieldsByBottle,\n    FilterTargetFieldsByCondenser,\n)\nfrom .models import LogCondenser\n\n\nclass FilterTargetFieldsByLogCondenser(FilterTargetFieldsByCondenser):\n    \"\"\"\n    Defines autocomplete rules for target_field on the DataFitting admin page.\n    \"\"\"\n    model = LogCondenser\n\n\nautocomplete_light.register(FilterTargetFieldsByBottle)\nautocomplete_light.register(FilterTargetFieldsByLogCondenser)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, 1, 1, null, null, null, null, 1, null, null, null, null, null, 1, 1, null], "name": "sifter/logsifter/logcondensers/forms.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines forms for LogFittings and LogCondensers.\n\"\"\"\n\n# third party\nimport autocomplete_light\n\n# local\nfrom sifter.condensers.forms import (\n    CondenserForm,\n    FittingForm,\n    FittingInlineForm,\n    ParserForm\n)\nfrom .models import LogCondenser, LogFitting, LogParser\n\n\nclass LogParserForm(ParserForm):\n    \"\"\"\n    Defines a form for adding or updating a LogParser using autocomplete\n    fields.\n    \"\"\"\n\n    class Meta(ParserForm.Meta):\n        model = LogParser\n\n\nclass LogCondenserForm(CondenserForm):\n    \"\"\"\n    Defines a form for adding or updating a LogCondenser using autocomplete\n    fields.\n    \"\"\"\n\n    class Meta(CondenserForm.Meta):\n        model = LogCondenser\n\n\nclass LogFittingForm(FittingForm):\n    \"\"\"\n    Defines a form for adding or updating a LogaFitting using autocomplete\n    fields.\n    \"\"\"\n\n    class Meta(FittingForm.Meta):\n        model = LogFitting\n        autocomplete_names = {\n            'target_field': 'FilterTargetFieldsByLogCondenser'\n        }\n\n\nclass LogFittingInlineForm(FittingInlineForm):\n    \"\"\"\n    Defines an inline form for adding or updating a LogFitting using\n    autocomplete fields.\n    \"\"\"\n\n    class Meta(FittingInlineForm.Meta):\n        model = LogFitting\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, null, 1, null, 1, null, null, null], "name": "sifter/logsifter/logcondensers/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.db import models\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.models import GetByNameManager\nfrom parsers.models import StringParser\nfrom sifter.condensers.models import Condenser, Fitting\n\n\nclass LogParser(StringParser):\n    \"\"\"\n\n    \"\"\"\n    objects = GetByNameManager()\n\n\nclass LogCondenser(Condenser):\n    \"\"\"\n\n    \"\"\"\n    objects = GetByNameManager()\n\n\nclass LogFitting(Fitting):\n    \"\"\"\n\n    \"\"\"\n    CONDENSER = models.Q(app_label='logcondensers', model='logcondenser')\n    PARSER = models.Q(app_label='logcondensers', model='logparser')\n    CONTENT_TYPES = PARSER | CONDENSER\n\n    condenser = models.ForeignKey(LogCondenser, related_name='fittings',\n                                  related_query_name='fitting')\n    content_type = models.ForeignKey(ContentType,\n                                     limit_choices_to=CONTENT_TYPES,\n                                     verbose_name=_('parser type'))\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/logsifter/logmungers/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, 1, null, null, 1, null], "name": "sifter/logsifter/logmungers/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom sifter.mungers.admin import MungerAdmin\nfrom sifter.logsifter.logmungers.models import LogMunger\n\n\nclass LogMungerAdmin(MungerAdmin):\n    pass\n\n\nadmin.site.register(LogMunger, LogMungerAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, 1, null, null, 1, null, null, null, null, null, 1, null, 1, null], "name": "sifter/logsifter/logmungers/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.db import models\n\n# local\nfrom cyphon.models import GetByNameManager\nfrom sifter.mungers.models import Munger\nfrom sifter.logsifter.logcondensers.models import LogCondenser\n\n\nclass LogMunger(Munger):\n    \"\"\"\n    Attributes:\n        condenser: a LogCondenser used to distill the message into the chosen\n                   Bottle\n    \"\"\"\n    condenser = models.ForeignKey(LogCondenser)\n\n    objects = GetByNameManager()\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/logsifter/logsieves/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, 1, 1, null], "name": "sifter/logsifter/logsieves/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom sifter.sieves.admin import (\n    RuleAdmin,\n    SieveNodeInLineAdmin,\n    SieveNodeAdmin,\n    SieveAdmin\n)\nfrom .forms import LogRuleForm\nfrom .models import LogRule, LogSieve, LogSieveNode\n\n\nclass LogRuleAdmin(RuleAdmin):\n    \"\"\"\n    Customizes admin inline tables for LogSieveNodes.\n    \"\"\"\n    form = LogRuleForm\n\n\nclass LogSieveNodeInLineAdmin(SieveNodeInLineAdmin):\n    \"\"\"\n    Customizes admin inline tables for LogSieveNodes.\n    \"\"\"\n    model = LogSieveNode\n\n\nclass LogSieveAdmin(SieveAdmin):\n    \"\"\"\n    Customizes admin pages for DataSieves.\n    \"\"\"\n    inlines = [LogSieveNodeInLineAdmin, ]\n\n\nadmin.site.register(LogRule, LogRuleAdmin)\nadmin.site.register(LogSieve, LogSieveAdmin)\nadmin.site.register(LogSieveNode, SieveNodeAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, 1, 1, null], "name": "sifter/logsifter/logsieves/forms.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines forms for LogRules and LogSieves.\n\"\"\"\n\n# local\nfrom sifter.sieves.forms import RuleForm\nfrom .models import LogRule\n\n\nclass LogRuleForm(RuleForm):\n    \"\"\"\n    Defines a form for adding or updating a LogRule.\n    \"\"\"\n\n    class Meta(RuleForm.Meta):\n        model = LogRule\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, null, 1, null, null, null, null, null, 1, null, null, null], "name": "sifter/logsifter/logsieves/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines LogSieve class and related classes.\n\"\"\"\n\n# third party\nfrom django.db import models\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.models import GetByNameManager\nfrom sifter.sieves.models import StringRule, Sieve, SieveManager, SieveNode\n\n\nclass LogRule(StringRule):\n    \"\"\"\n    A Rule subclass for examining log messages.\n    \"\"\"\n    objects = GetByNameManager()\n\n\nclass LogSieve(Sieve):\n    \"\"\"\n    A RuleSet subclass for examining log messages.\n    \"\"\"\n    objects = SieveManager()\n\n\nclass LogSieveNode(SieveNode):\n    \"\"\"\n    A RuleSetNode subclass for examining log messages.\n    \"\"\"\n    RULE = models.Q(app_label='logsieves', model='logrule')\n    RULESET = models.Q(app_label='logsieves', model='logsieve')\n    CONTENT_TYPES = RULE | RULESET\n\n    sieve = models.ForeignKey(\n        LogSieve,\n        related_name='nodes',\n        related_query_name='node',\n        help_text=_('A rule or rule set to assign to the node.')\n    )\n    content_type = models.ForeignKey(ContentType,\n                                     limit_choices_to=CONTENT_TYPES,\n                                     verbose_name=_('node type'))\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/mailsifter/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, null, null, 1, null, 1, 1, null, 1, null, null, 1, null, null, null, null, null, 1, 1, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, null, 1, 1, 1, 1, 1, 1, null, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, null, null, 1, null, null, null, 0, 0, 0, null, null, 1, null, null, null, null, 1, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, 1, null, 1, 1, 1, null, 1, null, null, 1], "name": "sifter/mailsifter/accessors.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# standard library\nimport email.utils as email_utils\nfrom email.header import decode_header\nimport logging\n\n# third party\nimport bleach\nfrom django.conf import settings\n\n# local\nfrom utils.parserutils.parserutils import html_to_text\n\n_MAILSIFTER_SETTINGS = settings.MAILSIFTER\n_CONTENT_PREFERENCES = _MAILSIFTER_SETTINGS['EMAIL_CONTENT_PREFERENCES']\n\n_LOGGER = logging.getLogger(__name__)\n\n\ndef get_content(email, content_types=_CONTENT_PREFERENCES, remove_tags=True):\n    \"\"\"\n    Takes an email Message object and a Boolean indicating whether\n    HTML tags should be removed. Returns a string of the most\n    preferred content. If no matches are found, returns None.\n    \"\"\"\n    for content_type in content_types:\n        for part in email.walk():\n            if part.get_content_type() == content_type:\n                payload = part.get_payload(decode=True)\n                if remove_tags and content_type == 'text/html':\n                    return html_to_text(payload)\n                else:\n                    return payload\n\n\ndef get_date(email):\n    \"\"\"\n    Takes an email Message object and attempts to parse a date according\n    to the rules in RFC 2822. If successful, returns a string of the\n    datetime in UTC and in ISO 8601 format. Otherwise, returns None.\n    \"\"\"\n    date_str = email.get('Date', '')\n    try:\n        email_datetime = email_utils.parsedate_to_datetime(date_str)\n        return email_datetime.isoformat()\n    except TypeError:\n        _LOGGER.warning('Email date for %s could not be parsed.',\n                       email.get('Message-ID'))\n\n\ndef format_address(address):\n    \"\"\"\n\n    \"\"\"\n    return \"'%s' %s\" % (address[0], address[1])\n\n\ndef get_from(email):\n    \"\"\"\n    Takes an email Message object and returns the 'from' email address.\n    \"\"\"\n    address = email.get('From')\n    parsed_addr = email_utils.parseaddr(address)\n    return format_address(parsed_addr)\n\n\ndef get_to(email):\n    \"\"\"\n    Takes an email Message object and returns the 'to' email address(es).\n    \"\"\"\n    addresses = email.get_all('To', [])\n    parsed_addresses = email_utils.getaddresses(addresses)\n    return ', '.join([format_address(addr) for addr in parsed_addresses])\n\n\ndef get_subject(email):\n    \"\"\"\n    Takes an email Message object and returns the Subject as a string,\n    decoding base64-encoded subject lines as necessary.\n    \"\"\"\n    subject = email.get('Subject', '')\n    result = decode_header(subject)\n    subject = result[0][0]\n    if isinstance(subject, str):\n        return subject\n    else:\n        return subject.decode('unicode_escape')\n\n\ndef get_attachment(email_part):\n    \"\"\"Return the file path of an email attachment.\n\n    Parameters\n    ----------\n    email_part : Message\n        Part of a multipart email |Message| object.\n\n    Returns\n    -------\n    |str| or |None|\n        The file path to the attachment associated with the email part,\n        if one exists and is an allowed file type. Otherwise, returns\n        |None|.\n\n    \"\"\"\n    if not email_part.is_multipart() \\\n            and 'attachment' in email_part.get('Content-Disposition', ''):\n        content_type = email_part.get_content_type()\n        if content_type in _MAILSIFTER_SETTINGS['ALLOWED_EMAIL_ATTACHMENTS']:\n            return email_part\n\n\ndef get_attachments(email):\n    \"\"\"Return a list of file paths for attachments from an email.\n\n    Parameters\n    ----------\n    email : Message\n        An email |Message| object.\n\n    Returns\n    -------\n    |list| of |str|\n        A |list| of file paths to email attachments. If the email has no\n        attachments, returns an empty |list|.\n\n    \"\"\"\n    attachments = []\n    for part in email.walk():\n        attachment = get_attachment(part)\n        if attachment is not None:\n            attachments.append(attachment)\n    return attachments\n\n\ndef get_first_attachment(email):\n    \"\"\"Return the file path of the first attachment from an email.\n\n    Parameters\n    ----------\n    email : Message\n        An email |Message| object.\n\n    Returns\n    -------\n    |str| or |None|\n        The file path to the first attachment in the email, if one\n        exists and is an allowed file type. Otherwise, returns |None|.\n\n    \"\"\"\n    for part in email.walk():\n        attachment = get_attachment(part)\n        if attachment is not None:\n            return attachment\n\n\ndef get_email_value(field_name, email):\n    \"\"\"\n    Takes the name of an email field and an email Message object and\n    returns the value of the field from the Message object.\n    \"\"\"\n    field_functions = {\n        'Content': get_content,\n        'Date': get_date,\n        'From': get_from,\n        'To': get_to,\n        'Subject': get_subject,\n        'Attachment': get_first_attachment,\n        'Attachments': get_attachments\n    }\n\n    if field_name in field_functions:\n        value = field_functions[field_name](email)\n    else:\n        value = email.get(field_name, '')\n\n    if isinstance(value, (str, bytes)):\n        try:\n            # strip any tags that aren't on the whitelist\n            return bleach.clean(value, strip=True)\n        except UnicodeDecodeError:\n            _LOGGER.error('An error was encountered while parsing the %s '\n                         'field of an email.', field_name)\n            return 'The %s of this email could not be displayed due to an error.' \\\n                   % field_name\n    else:\n        return value\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, 1, 1, null, null, 1, 1, 1, 1, null, 1, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, 1, null, 1, 1, null, 0, 0, null, null, 1, null, null, null, 1, null, 1, 1, null, 1, null, null, 1, null, null, null, 1, 1, 1, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, 1, 1, 1, null, 1, 1, null, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, 1, 1, 1, 1], "name": "sifter/mailsifter/attachments.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# standard library\nfrom datetime import datetime\nimport logging\nimport mimetypes\nimport os\nimport urllib\nimport uuid\n\n# third party\nfrom django.conf import settings\nfrom django.core.files.storage import default_storage\nfrom django.core.files.base import ContentFile\nimport six\n\n_MAILSIFTER_SETTINGS = settings.MAILSIFTER\n\n_LOGGER = logging.getLogger(__name__)\n\n\ndef get_file_name():\n    \"\"\"\n\n    \"\"\"\n    return uuid.uuid4().hex\n\n\ndef get_extension(attachment):\n    \"\"\"\n\n    \"\"\"\n    try:\n        filename = attachment.get_filename()\n        if filename:\n            extension = os.path.splitext(filename)[1]\n        else:\n            extension = mimetypes.guess_extension(attachment.get_content_type())\n        return extension or '.bin'\n\n    except AttributeError:\n        return None\n\n\ndef get_raw_directory_path(company=None):\n    \"\"\"\n\n    \"\"\"\n    attachments_folder = _MAILSIFTER_SETTINGS['ATTACHMENTS_FOLDER']\n\n    if company is not None:\n        return os.path.join(company.uuid.hex, attachments_folder)\n    else:\n        return os.path.join(attachments_folder)\n\n\ndef get_directory_path(company=None):\n    \"\"\"\n\n    \"\"\"\n    path = get_raw_directory_path(company)\n    if '%' in path:\n        return datetime.utcnow().strftime(path)\n    else:\n        return path\n\n\ndef get_attachment_path(path):\n    \"\"\"\n\n    \"\"\"\n    return os.path.join(settings.MEDIA_ROOT, path)\n\n\ndef get_attachment_url(path):\n    \"\"\"\n\n    \"\"\"\n    base_url = urllib.parse.urljoin(settings.BASE_URL, settings.MEDIA_URL)\n    return urllib.parse.urljoin(base_url, path)\n\n\ndef get_file_path(attachment, company=None):\n    \"\"\"\n\n    \"\"\"\n    file_name = get_file_name()\n    extension = get_extension(attachment)\n    if extension in _MAILSIFTER_SETTINGS['ALLOWED_FILE_EXTENSIONS']:\n        dir_path = get_directory_path(company)\n        return os.path.join(dir_path, file_name + extension)\n    else:\n        orig_filename = attachment.get_filename()\n        _LOGGER.warning('The attachment %s is not an allowed file type',\n                        orig_filename)\n\n\ndef get_attachment_content(attachment):\n    \"\"\"\n\n    \"\"\"\n    payload = attachment.get_payload(decode=True)\n    return six.BytesIO(payload).getvalue()\n\n\ndef save_attachment(attachment, company=None):\n    \"\"\"\n\n    \"\"\"\n    file_path = get_file_path(attachment, company)\n    if file_path is not None:\n        full_path = get_attachment_path(file_path)\n        file_content = get_attachment_content(attachment)\n        default_storage.save(full_path, ContentFile(file_content))\n        return get_attachment_url(file_path)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1], "name": "sifter/mailsifter/mailchutes/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\ndefault_app_config = 'sifter.mailsifter.mailchutes.apps.MailChutesConfig'\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null], "name": "sifter/mailsifter/mailchutes/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a ModelAdmin subclass for MailChutes and registers them with\nDjango Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom sifter.chutes.admin import ChuteAdmin\nfrom sifter.mailsifter.mailchutes.models import MailChute\n\n\nclass MailChuteAdmin(ChuteAdmin):\n    \"\"\"\n    Customizes admin pages for MailChutes.\n    \"\"\"\n    pass\n\n\nadmin.site.register(MailChute, MailChuteAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, 1, null, 1, null, null, null, 1, null], "name": "sifter/mailsifter/mailchutes/apps.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.apps import AppConfig\n\n\nclass MailChutesConfig(AppConfig):\n    \"\"\"\n\n    \"\"\"\n    name = 'sifter.mailsifter.mailchutes'\n    verbose_name = 'MailChutes'\n\n    def ready(self):\n        \"\"\"\n\n        \"\"\"\n        import sifter.mailsifter.mailchutes.signals\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, null, null, 1, null, 1, null], "name": "sifter/mailsifter/mailchutes/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.db import models\n\n# local\nfrom sifter.chutes.models import Chute, ChuteManager\nfrom sifter.mailsifter.mailmungers.models import MailMunger\nfrom sifter.mailsifter.mailsieves.models import MailSieve\n\n\nclass MailChute(Chute):\n    \"\"\"\n\n    \"\"\"\n    sieve = models.ForeignKey(\n        MailSieve,\n        null=True,\n        blank=True,\n        default=None,\n        related_name='chutes',\n        related_query_name='chute'\n    )\n    munger = models.ForeignKey(MailMunger)\n\n    objects = ChuteManager()\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, 1, null, 1, null, 1, null, null, 1, null, null, null, null, null, 1, 1, null, 1, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, 1, null, 1, 1, 1, 1, 1, null, null], "name": "sifter/mailsifter/mailchutes/services.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nProvides services for handling email messages.\n\"\"\"\n\n# standard library\nimport logging\n\n# third party\nfrom django.conf import settings\nfrom django.core.exceptions import ObjectDoesNotExist\n\n# local\nfrom sifter.mailsifter.mailchutes.models import MailChute\nfrom sifter.mailsifter.mailmungers.models import MailMunger\n\n_MAILSIFTER_SETTINGS = settings.MAILSIFTER\n\n_LOGGER = logging.getLogger(__name__)\n\n\ndef process_email(email):\n    \"\"\"\n    Takes an email.message.Message object and processes it through\n    enabled MailChutes.\n\n    \"\"\"\n    enabled_chutes = MailChute.objects.find_enabled()\n    saved = False\n\n    for chute in enabled_chutes:\n        result = chute.process(data=email)\n        if result:\n            saved = True\n    if not saved and _MAILSIFTER_SETTINGS['DEFAULT_MAIL_CHUTE_ENABLED']:\n        catch_email(email)\n\n\ndef catch_email(email):\n    \"\"\"\n    Takes an email.message.Message object and saves it using the default\n    MailMunger.\n    \"\"\"\n    munger_name = _MAILSIFTER_SETTINGS['DEFAULT_MAIL_MUNGER']\n\n    try:\n        default_munger = MailMunger.objects.get(name=munger_name)\n        default_munger.process(email)\n    except ObjectDoesNotExist:\n        _LOGGER.error('Default MailMunger \"%s\" is not configured. '\n                      'Could not save message %s',\n                      munger_name, email['Message-ID'])\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, null, null, 1, null, null, null, null, null, null, 1, null, null, 1, null, 1, null], "name": "sifter/mailsifter/mailchutes/signals.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a signal reciever for incoming emails.\n\"\"\"\n\n# third party\nfrom django.db import close_old_connections\nfrom django.dispatch import receiver\nfrom django_mailbox.signals import message_received\n\n# local\nfrom .services import process_email\n\n\n@receiver(message_received)\ndef handle_message(sender, message, **args):\n    \"\"\"\n    Takes a signal sender and a Django Mailbox Message and processes\n    the message.\n    \"\"\"\n    # get the Python email.message.Message object\n    email = message.get_email_object()\n\n    # process the email through enabled MailChutes\n    process_email(email)\n\n    close_old_connections()\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/mailsifter/mailcondensers/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, 1, null, null, null, null, 1, 1, null, null, null, null, null, null, null, 1, null, null, null, 1, null, null, null, null, null, null, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, null, null, 1, 1, 1, null], "name": "sifter/mailsifter/mailcondensers/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nimport autocomplete_light\nfrom django.contrib import admin\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.admin import ConfigToolAdmin, CONFIG_TOOL_CLASSES\nfrom cyphon.forms import CONFIG_TOOL_INPUTS\nfrom sifter.condensers.admin import (\n    FittingInLineAdmin,\n    FittingAdmin,\n    CondenserAdmin\n)\nfrom .models import MailParser, MailCondenser, MailFitting\nfrom .forms import (\n    MailCondenserForm,\n    MailFittingForm,\n    MailFittingInlineForm,\n    MailParserForm\n)\n\n\nclass MailParserAdmin(ConfigToolAdmin):\n    \"\"\"\n    Customizes admin pages for MailParsers.\n    \"\"\"\n    list_display = [\n        'name',\n        'source_field',\n        'method',\n        'regex',\n        'formatter',\n    ]\n    list_display_links = ['name', ]\n    fieldsets = (\n        ('Test this parser', {\n            'classes': CONFIG_TOOL_CLASSES,\n            'description': _('Enter a test string and click \"Run test\" '\n                             'to check what the parser will return '\n                             'for the string.'),\n            'fields': CONFIG_TOOL_INPUTS,\n        }),\n        (None, {\n            'fields': [\n                'name',\n                'source_field',\n                'method',\n                'regex',\n                'formatter',\n            ]\n        }),\n    )\n    model = MailParser\n    form = MailParserForm\n    model_method = 'run_test'\n\n\nclass MailFittingInLineAdmin(FittingInLineAdmin):\n    \"\"\"\n    Customizes admin inline tables for MailFittings.\n    \"\"\"\n    model = MailFitting\n    form = MailFittingInlineForm\n\n\nclass MailFittingAdmin(FittingAdmin):\n    \"\"\"\n    Customizes admin pages for MailFittings.\n    \"\"\"\n    form = MailFittingForm\n\n\nclass MailCondenserAdmin(CondenserAdmin):\n    \"\"\"\n    Customizes admin pages for MailCondensers.\n    \"\"\"\n    data_format = 'email'\n    inlines = [MailFittingInLineAdmin, ]\n    form = MailCondenserForm\n\n\nadmin.site.register(MailParser, MailParserAdmin)\nadmin.site.register(MailCondenser, MailCondenserAdmin)\nadmin.site.register(MailFitting, MailFittingAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, 1, null], "name": "sifter/mailsifter/mailcondensers/autocomplete_light_registry.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines Autocomplete models for use in admin pages for the MailCondensers app.\n\"\"\"\n\n# third party\nimport autocomplete_light.shortcuts as autocomplete_light\n\n# local\nfrom sifter.condensers.autocomplete import (\n    FilterTargetFieldsByBottle,\n    FilterTargetFieldsByCondenser,\n)\nfrom .models import MailCondenser\n\n\nclass FilterTargetFieldsByMailCondenser(FilterTargetFieldsByCondenser):\n    \"\"\"\n    Defines autocomplete rules for target_field on the MailFitting admin page.\n    \"\"\"\n    model = MailCondenser\n\n\nautocomplete_light.register(FilterTargetFieldsByBottle)\nautocomplete_light.register(FilterTargetFieldsByMailCondenser)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, 1, 1, null, null, null, null, 1, null, null, null, null, null, 1, 1, null], "name": "sifter/mailsifter/mailcondensers/forms.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines forms for MailFittings and MailCondensers.\n\"\"\"\n\n# third party\nimport autocomplete_light\n\n# local\nfrom sifter.condensers.forms import (\n    CondenserForm,\n    FittingForm,\n    FittingInlineForm,\n    ParserForm\n)\nfrom .models import MailCondenser, MailFitting, MailParser\n\n\nclass MailParserForm(ParserForm):\n    \"\"\"\n    Defines a form for adding or updating a MailCondenser using autocomplete\n    fields.\n    \"\"\"\n\n    class Meta(ParserForm.Meta):\n        model = MailParser\n\n\nclass MailCondenserForm(CondenserForm):\n    \"\"\"\n    Defines a form for adding or updating a MailCondenser using autocomplete\n    fields.\n    \"\"\"\n\n    class Meta(CondenserForm.Meta):\n        model = MailCondenser\n\n\nclass MailFittingForm(FittingForm):\n    \"\"\"\n    Defines a form for adding or updating a MailFitting using autocomplete\n    fields.\n    \"\"\"\n\n    class Meta(FittingForm.Meta):\n        model = MailFitting\n        autocomplete_names = {\n            'target_field': 'FilterTargetFieldsByMailCondenser'\n        }\n\n\nclass MailFittingInlineForm(FittingInlineForm):\n    \"\"\"\n    Defines an inline form for adding or updating a MailFitting using\n    autocomplete fields.\n    \"\"\"\n\n    class Meta(FittingInlineForm.Meta):\n        model = MailFitting\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, 1, 1, null, null, 1, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 0, 0, 0, 0, null, 0, 0, null, null, null, 1, null, null, null, 1, null, 1, null, null, null, null, 0, 0, null, 0, null, 1, null, null, null, 0, 0, 0, null, 0, null, 1, null, null, null, 1, null, 1, 0, null, 1, null, 1, 0, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, null, 1, null, 1, null, null], "name": "sifter/mailsifter/mailcondensers/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# standard library\nfrom email import message_from_string\n\n# third party\nfrom django.db import models\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core.exceptions import ValidationError\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.models import GetByNameManager\nfrom cyphon.choices import EMAIL_FIELD_CHOICES\nfrom parsers.models import StringParser\nfrom sifter.condensers.models import Condenser, Fitting\nfrom sifter.mailsifter.attachments import save_attachment\nfrom sifter.mailsifter.accessors import get_email_value\n\n\nclass MailParser(StringParser):\n    \"\"\"\n    Parses an email Message object.\n\n    name : str\n\n    method : str\n\n    regex : str\n\n    formatter : str\n\n    source_field : str\n\n    \"\"\"\n    source_field = models.CharField(\n        max_length=255,\n        choices=EMAIL_FIELD_CHOICES,\n        help_text=_('The email field from which data will be extracted.')\n    )\n\n    def clean(self):\n        super(MailParser, self).clean()\n        choices = [item[0] for item in EMAIL_FIELD_CHOICES]\n        if self.source_field not in choices:\n            raise ValidationError(\n                _('The selected source field is not a valid email field.'))\n        if self._has_attachment() and self.method != 'COPY':\n            raise ValidationError(\n                _(\"If the source field refers to an attachment, \"\n                  \"the method must be 'COPY'.\"))\n\n    def _has_attachment(self):\n        \"\"\"\n\n        \"\"\"\n        return 'attachment' in self.source_field.lower()\n\n    @staticmethod\n    def _save_attachments(value, company):\n        \"\"\"\n\n        \"\"\"\n        if isinstance(value, list):\n            return [save_attachment(attachment, company) for attachment in value]\n        else:\n            return save_attachment(value, company)\n\n    def run_test(self, string):\n        \"\"\"\n\n        \"\"\"\n        email = message_from_string(string)\n        if not email:\n            return 'Sorry! The string you entered could not be converted to '\\\n                   'an email. Please enter the raw source of an email to test.'\n        return self.process(email)\n\n    def process(self, email, company=None):\n        \"\"\"\n        Takes a value and returns a parsed result.\n        \"\"\"\n        value = get_email_value(self.source_field, email)\n\n        if self._has_attachment() and value:\n            value = self._save_attachments(value, company)\n\n        result = self._parse(value)\n\n        if self.formatter:\n            return self._apply_template(result)\n        else:\n            return result\n\n\nclass MailCondenser(Condenser):\n    \"\"\"\n\n    \"\"\"\n    objects = GetByNameManager()\n\n\nclass MailFitting(Fitting):\n    \"\"\"\n\n    \"\"\"\n    CONDENSER = models.Q(app_label='mailcondensers', model='mailcondenser')\n    PARSER = models.Q(app_label='mailcondensers', model='mailparser')\n    CONTENT_TYPES = PARSER | CONDENSER\n\n    condenser = models.ForeignKey(MailCondenser, related_name='fittings',\n                                  related_query_name='fitting')\n    content_type = models.ForeignKey(ContentType,\n                                     limit_choices_to=CONTENT_TYPES,\n                                     verbose_name=_('parser type'))\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/mailsifter/mailmungers/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, 1, null, null, 1, null], "name": "sifter/mailsifter/mailmungers/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom sifter.mungers.admin import MungerAdmin\nfrom sifter.mailsifter.mailmungers.models import MailMunger\n\n\nclass MailMungerAdmin(MungerAdmin):\n    pass\n\n\nadmin.site.register(MailMunger, MailMungerAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, 1, null, null, null, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1], "name": "sifter/mailsifter/mailmungers/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.conf import settings\nfrom django.db import models\n\n# local\nfrom cyphon.models import GetByNameManager\nfrom sifter.mungers.models import Munger\nfrom sifter.mailsifter.mailcondensers.models import MailCondenser\n\n_MAILSIFTER_SETTINGS = settings.MAILSIFTER\n\n\nclass MailMunger(Munger):\n    \"\"\"\n    Attributes:\n        name : str\n\n        distillery : Distillery\n\n        condenser: MailCondenser\n            a MailCondenser used to distill the message into the chosen\n            Bottle\n\n    \"\"\"\n    condenser = models.ForeignKey(MailCondenser)\n\n    objects = GetByNameManager()\n\n    def _get_company(self):\n        \"\"\"\n\n        \"\"\"\n        return self.distillery.company\n\n    def _process_data(self, data):\n        \"\"\"\n        Takes a dictionary of data (e.g., of a social media post) and a\n        Condenser. Returns a dictionary that distills the data\n        using the crosswalk defined by the Condenser.\n        \"\"\"\n        company = self._get_company()\n        return self.condenser.process(data=data, company=company)\n\n    def process(self, data, doc_id=None, collection=None, platform=None):\n        \"\"\"\n        Condenses data into the Distillery's Bottle, adds the doc_id and\n        source to the data, saves it in the Distillery's Collection\n        (database collection), and sends a signal that the document has been\n        saved.\n\n        Parameters:\n            data: a dictionary of raw data\n            condenser: a Condenser that should be used to distill the data\n            doc_id: the id of the document that contains the data\n            collection: a string representing the Collection in which the raw\n                    data is stored (e.g., 'elasticsearch.cyphon.twitter')\n        \"\"\"\n        doc = self._process_data(data)\n        collection = _MAILSIFTER_SETTINGS['MAIL_COLLECTION']\n        doc_id = data['Message-ID']\n        return self._save_data(doc, doc_id, collection, platform)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/mailsifter/mailsieves/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, 1, 1, null], "name": "sifter/mailsifter/mailsieves/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom sifter.sieves.admin import (\n    FieldRuleAdmin,\n    SieveNodeInLineAdmin,\n    SieveNodeAdmin,\n    SieveAdmin\n)\nfrom . import models\n\n\nclass MailRuleAdmin(FieldRuleAdmin):\n    \"\"\"\n    Customizes admin inline tables for MailSieveNodes.\n    \"\"\"\n    pass\n\n\nclass MailSieveNodeInLineAdmin(SieveNodeInLineAdmin):\n    \"\"\"\n    Customizes admin inline tables for MailSieveNodes.\n    \"\"\"\n    model = models.MailSieveNode\n\n\nclass MailSieveAdmin(SieveAdmin):\n    \"\"\"\n    Customizes admin pages for MailSieves.\n    \"\"\"\n    inlines = [MailSieveNodeInLineAdmin, ]\n\n\nadmin.site.register(models.MailRule, MailRuleAdmin)\nadmin.site.register(models.MailSieve, MailSieveAdmin)\nadmin.site.register(models.MailSieveNode, SieveNodeAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, 1, 1, null, null, 1, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, null, 1, null, null, null, null, null, 1, null, null, null], "name": "sifter/mailsifter/mailsieves/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines Rule and RuleSet classes.\n\"\"\"\n\n# third party\nfrom django.db import models\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.choices import EMAIL_FIELD_CHOICES, REGEX_CHOICES\nfrom cyphon.models import GetByNameManager\nfrom sifter.mailsifter import accessors\nfrom sifter.sieves.models import Rule, Sieve, SieveManager, SieveNode\n\n\nclass MailRule(Rule):\n    \"\"\"\n    A Rule subclass for examining email messages.\n    \"\"\"\n    operator = models.CharField(\n        max_length=40,\n        choices=REGEX_CHOICES,\n        help_text=_('The type of comparison to make.')\n    )\n    field_name = models.CharField(max_length=40,\n                                  choices=EMAIL_FIELD_CHOICES)\n\n    objects = GetByNameManager()\n\n    def _get_string(self, email):\n        \"\"\"\n        Takes an email Message object and returns the Message component\n        indicated by the MailRule's field_name.\n        \"\"\"\n        value = accessors.get_email_value(self.field_name, email)\n        return str(value)\n\n\nclass MailSieve(Sieve):\n    \"\"\"\n    A RuleSet subclass for examining email messages.\n    \"\"\"\n    objects = SieveManager()\n\n\nclass MailSieveNode(SieveNode):\n    \"\"\"\n    A RuleSetNode subclass for examining email messages.\n    \"\"\"\n    _RULE = models.Q(app_label='mailsieves', model='mailrule')\n    _RULESET = models.Q(app_label='mailsieves', model='mailsieve')\n    _CONTENT_TYPES = _RULE | _RULESET\n\n    sieve = models.ForeignKey(\n        MailSieve,\n        related_name='nodes',\n        related_query_name='node',\n        help_text=_('A rule or rule set to assign to the node.')\n    )\n    content_type = models.ForeignKey(ContentType,\n                                     limit_choices_to=_CONTENT_TYPES,\n                                     verbose_name=_('node type'))\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/mungers/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, null, null, 1, null], "name": "sifter/mungers/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n\nclass MungerAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Mungers.\n    \"\"\"\n    list_display = [\n        'name',\n        'distillery',\n        'condenser',\n    ]\n    list_display_links = ['name', ]\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, 1, 1, 1, null, 1, 0, null, 1, null, null, null, 1, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null], "name": "sifter/mungers/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.db import models\n\n# local\nfrom distilleries.models import Distillery\n\n\nclass Munger(models.Model):\n    \"\"\"\n\n    Attributes:\n        name: a string representing the name of the DataReader\n        distillery: a Distillery used to save the distilled message to a Warehouse\n\n    Define in subclasses:\n        condenser: a Condenser used to distill the message into the chosen\n                   Bottle\n\n    \"\"\"\n    name = models.CharField(max_length=40, unique=True)\n    distillery = models.ForeignKey(Distillery)\n\n    class Meta:\n        \"\"\"\n        Metadata options for a Django Model.\n        \"\"\"\n        abstract = True\n        unique_together = ('condenser', 'distillery')\n        ordering = ['name']\n\n    def __str__(self):\n        return self.name\n\n    def _save_data(self, data, doc_id=None, collection=None, platform=None):\n        \"\"\"\n\n        \"\"\"\n        return self.distillery.save_data(data, doc_id, collection, platform)\n\n    def _process_data(self, data):\n        \"\"\"\n        Takes a dictionary of data (e.g., of a social media post) and a\n        Condenser. Returns a dictionary that distills the data\n        using the crosswalk defined by the Condenser.\n        \"\"\"\n        return self.condenser.process(data)\n\n    def process(self, data, doc_id=None, collection=None, platform=None):\n        \"\"\"\n        Condenses data into the Distillery's Bottle, adds the doc_id and\n        source to the data, saves it in the Distillery's Collection\n        (database collection), and sends a signal that the document has been\n        saved.\n\n        Parameters:\n            data: a dictionary of raw data\n            condenser: a Condenser that should be used to distill the data\n            doc_id: the id of the document that contains the data\n            collection: a string representing the Collection in which the raw\n                    data is stored (e.g., 'elasticsearch.cyphon.twitter')\n        \"\"\"\n        doc = self._process_data(data)\n        doc_id = self._save_data(doc, doc_id, collection, platform)\n        return doc_id\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "sifter/sieves/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, null, null, null, null, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, 1, 1, null, null, null, null, 1, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, 1, 1, null], "name": "sifter/sieves/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.admin import CONFIG_TOOL_CLASSES\nfrom cyphon.forms import CONFIG_TOOL_INPUTS \n\n\nclass RuleAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Rules.\n    \"\"\"\n    list_display = [\n        'id',\n        'name',\n        'operator',\n        'value',\n        'is_regex',\n        'case_sensitive',\n        'negate',\n        'protocol',\n    ]\n    list_display_links = ['name', ]\n    fieldsets = (\n        (None, {\n            'fields': [\n                'name',\n                'operator',\n                'value',\n                'is_regex',\n                'case_sensitive',\n                'negate',\n                'protocol',\n            ]\n        }),\n        ('Test this rule', {\n            'classes': CONFIG_TOOL_CLASSES,\n            'description': _('Enter a test string and click \"Run test\" '\n                             'to check whether the rule is True or False '\n                             'for the string.'),\n            'fields': CONFIG_TOOL_INPUTS,\n        })\n    )\n    save_as = True\n\n\nclass FieldRuleAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Rules.\n    \"\"\"\n    list_display = [\n        'id',\n        'name',\n        'field_name',\n        'operator',\n        'value',\n        'is_regex',\n        'case_sensitive',\n        'negate',\n        'protocol',\n    ]\n    list_display_links = ['name', ]\n    fields = [\n        'name',\n        'field_name',\n        'operator',\n        'value',\n        'is_regex',\n        'case_sensitive',\n        'negate',\n        'protocol',\n    ]\n    save_as = True\n\n\nclass SieveNodeAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for SievesNodes.\n    \"\"\"\n    list_display = [\n        'id',\n        'sieve',\n        'node_object',\n        'content_type'\n    ]\n    list_display_links = ['id', ]\n    related_lookup_fields = {\n        'generic': [['content_type', 'object_id'], ],\n    }\n\n\nclass SieveNodeInLineAdmin(admin.TabularInline):\n    \"\"\"\n    Customizes admin inline tables for SieveNodes.\n    \"\"\"\n    related_lookup_fields = {\n        'generic': [['content_type', 'object_id']],\n    }\n    show_change_link = True\n\n\nclass SieveAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Sieves.\n    \"\"\"\n    list_display = [\n        'name',\n        'logic',\n        'negate',\n        'get_node_number',\n    ]\n    list_display_links = ['name', ]\n    save_as = True\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, null], "name": "sifter/sieves/forms.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines forms for Rules and Sieves.\n\"\"\"\n\n# local\nfrom cyphon.forms import ConfigToolForm\n\n\nclass RuleForm(ConfigToolForm):\n    \"\"\"\n    Defines a form for adding or updating a Rule.\n    \"\"\"\n    pass\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, 1, 1, 1, 1, null, null, 1, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, 1, null, null, null, null, null, 1, 1, 1, null, 1, 0, null, 1, null, null, null, null, null, null, null, null, 1, 1, 0, null, 1, 1, null, 1, 0, null, 1, null, null, null, null, null, 1, 0, null, 1, null, 1, null, null, null, null, 1, 1, null, 0, 1, 1, null, 1, null, null, null, null, 0, null, 1, null, null, null, 1, null, 1, null, null, null, 1, null, 1, null, null, null, null, 1, 1, 1, null, 1, 1, null, 1, 1, 1, 0, 0, null, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, 0, null, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, 1, 1, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, 1, 1, null, 1, null, null, null, null, 1, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, 1, null, null, null, 0, 0, null, 1, null, null, null, 0, null, 1, null, null, null, 0, 0, null, 0, 0, 0, 0, 0, 0, null, 0, null, null, 1, null, null, null, null, 1, 1, null, null, null, null, null, 1, null, 1, 1, 1, null, 1, 1, null, 1, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, 1, null, 1, null, 1, null, null, null, null, 1, 1, 1, 1, null, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, 1, 1, null, 1, 0, null, 1, null, null, null, null, null, 0, null, 1, null, null, null, null, 1, null], "name": "sifter/sieves/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines Rule, Sieve, and SieveNode classes.\n\"\"\"\n\n# standard library\nimport logging\nimport re\nimport sre_constants\n\n# third party\nfrom django.db import models\nfrom django.contrib.contenttypes.fields import GenericForeignKey\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core.exceptions import ValidationError\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.models import GetByNameManager\nfrom cyphon.choices import LOGIC_CHOICES, REGEX_CHOICES\nfrom lab.procedures.models import Protocol\nfrom utils.parserutils.parserutils import get_dict_value\nfrom utils.validators.validators import regex_validator\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass Rule(models.Model):\n    \"\"\"\n    An abstract base class for models that define rules.\n\n    Attributes:\n        protocol: an optional Protocol that classifies the input data so the\n            result can be examined by the Rule. If no Protocol is specified,\n            the raw data is examined instead.\n        operator: a string representing a query operator or regex pattern\n        value: a string to be substituted for 'x' in the operator attribute\n        case_sensitive: a Boolean indicating whether a regex should ignore case\n        negate: a Boolean indicating whether the Rule should be evaluated as\n            True when data does NOT match the regex condition\n    \"\"\"\n    name = models.CharField(\n        max_length=40,\n        unique=True,\n        help_text=_('It\\'s a good idea to name rules after the data '\n                    'they examine and the comparison they make, e.g. '\n                    '\"log_contains_WARNING.\"')\n    )\n    protocol = models.ForeignKey(\n        Protocol,\n        blank=True,\n        null=True,\n        default=None,\n        help_text=_('An optional Protocol to apply to the data so the '\n                    'result can be examined by the Rule. If no Protocol '\n                    'is specified, the raw data is examined instead.')\n    )\n    value = models.CharField(\n        max_length=255,\n        blank=True,\n        null=True,\n        help_text=_('The value to compare the data against.')\n    )\n    is_regex = models.BooleanField(\n        default=False,\n        verbose_name=_('regular expression'),\n        help_text=_('Whether the value should be interpreted '\n                    'as a regular expression.')\n    )\n    case_sensitive = models.BooleanField(\n        default=False,\n        help_text=_('Whether the comparison should be case sensitive.')\n    )\n    negate = models.BooleanField(\n        default=False,\n        help_text=_('Whether the Rule should be evaluated as True '\n                    'if the data does NOT match the condition.')\n    )\n\n    class Meta:\n        abstract = True\n        ordering = ['name']\n\n    def __str__(self):\n        return self.name\n\n    def clean(self):\n        \"\"\"\n\n        See also\n        --------\n        Refer to Django's documentation on `cleaning and validating`_\n        fields that depend on each other.\n\n        \"\"\"\n        super(Rule, self).clean()\n        if self.operator != 'EmptyField' and self.value in ['', None]:\n            raise ValidationError(_('The value field is required.'))\n\n        if self.is_regex:\n            regex_validator(self.value)\n\n    def _preprocess(self, data):\n        self.protocol.process(data)\n\n    def _get_comparison_value(self, data):\n        \"\"\"\n        Takes a dictionary or a string of data. If a protocol is included in the\n        Rule, processes the data with the protocol and returns the result.\n        Otherwise, returns the original data value.\n        \"\"\"\n        if self.protocol is not None:\n            return self._preprocess(data)\n\n        return data\n\n    def _create_regex(self):\n        \"\"\"\n        Returna a regular expression pattern for Rule.value based on Rule.operator,\n        with special characters escaped for non-regex values.\n        \"\"\"\n        if not self.is_regex:\n            value = re.escape(self.value)\n        else:\n            value = self.value\n        operator_value = self._get_operator_value()\n        return operator_value.replace('x', value)\n\n    def _get_string(self, data):\n        \"\"\"\n        Takes a data object and returns it in the form of a string. This\n        method should be overridden in derived classes.\n        \"\"\"\n        raise NotImplementedError()\n\n    def _get_operator_type(self):\n        \"\"\"\n        Returns the type of field that is being examined by the rule.\n        \"\"\"\n        return self.operator.split(':')[0]\n\n    def _get_operator_value(self):\n        \"\"\"\n        Returns the type of field that is being examined by the rule.\n        \"\"\"\n        return self.operator.split(':')[1]\n\n    def _matches_regex(self, data):\n        \"\"\"\n        Takes a dictionary or a string of data and returns True if the data\n        matches the Rule's regex. Otherwise, returns False.\n        \"\"\"\n        regex = self._create_regex()\n        string = self._get_string(data)\n        args = [regex, string]\n\n        if not self.case_sensitive:\n            args.append(re.IGNORECASE)\n\n        try:\n            if re.search(*args):\n                return True\n        except sre_constants.error:\n            LOGGER.error('Cannot parse the regex \"%s\" for %s %s',\n                         regex, self.__class__.__name__, self.id)\n\n        return False\n\n    def _check_value(self, value):\n        \"\"\"\n        Takes a value and checks it against the Rule's logic. Returns\n        the result as a Boolean.\n        \"\"\"\n        return self._matches_regex(value)\n\n    def is_match(self, data):\n        \"\"\"\n        Takes a dictionary or a string of data and returns True if the data meets\n        the Rule's criterion. Otherwise, returns False.\n        \"\"\"\n        value = self._get_comparison_value(data)\n        match = self._check_value(value)\n\n        if self.negate:\n            return not match\n\n        return match\n\n\nclass StringRule(Rule):\n    \"\"\"\n    Defines a Rule subclass for use with a string.\n    \"\"\"\n    operator = models.CharField(\n        max_length=40,\n        choices=REGEX_CHOICES,\n        help_text=_('The type of comparison to make.')\n    )\n\n    class Meta:\n        abstract = True\n\n    def _get_string(self, data):\n        \"\"\"\n        Takes a data object and returns it in the form of a string.\n        \"\"\"\n        return str(data)\n\n\nclass FieldRule(Rule):\n    \"\"\"\n    Defines a Rule subclass for use with a dictionary.\n    \"\"\"\n    DATAFIELD_CHOICES = (\n        ('EmptyField', 'is null'),\n    )\n    operator = models.CharField(\n        max_length=40,\n        choices=list(REGEX_CHOICES) + list(DATAFIELD_CHOICES),\n        help_text=_('The type of comparison to make.')\n    )\n    field_name = models.CharField(\n        max_length=40,\n        help_text=_('The name of the data field that should be examined '\n                    'by the Rule.')\n    )\n\n    class Meta:\n        abstract = True\n\n    def _get_value(self, data):\n        \"\"\"\n        Takes a dictionary and returns the value for the key specified by the\n        field_name.\n        \"\"\"\n        return get_dict_value(self.field_name, data)\n\n    def _get_string(self, data):\n        \"\"\"\n        Takes a dictionary and returns the value for the key specified by the\n        field_name.\n        \"\"\"\n        value = self._get_value(data)\n        return str(value)\n\n    def _is_null(self, data):\n        \"\"\"\n\n        \"\"\"\n        value = self._get_value(data)\n        return value is None\n\n    def _check_value(self, value):\n        \"\"\"\n        Takes a value and checks it against the Rule's logic. Returns the result\n        as a Boolean.\n        \"\"\"\n        operator_type = self._get_operator_type()\n        methods = {\n            'CharField': self._matches_regex,\n            'EmptyField': self._is_null,\n        }\n        # TODO(LH): need other methods for other operator types, like IntegerField\n\n        func = methods[operator_type]\n        return func(value)\n\n\nclass SieveManager(GetByNameManager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def get_sieves_with_chutes(self):\n        \"\"\"\n        Returns a QuerySet of all Sieves associated with Chutes.\n        \"\"\"\n        default_queryset = self.get_queryset()\n        return default_queryset.filter(chute__isnull=False)\n\n    def _get_node_model(self):\n        \"\"\"\n        Returns the SieveNode subclass associated with the Sieve.\n        \"\"\"\n        return self.model._meta.get_field('node').related_model\n\n    def create_default_sieve(self):\n        \"\"\"\n\n        \"\"\"\n        node_model = self._get_node_model()\n        sieves = self.get_sieves_with_chutes()\n\n        default_sieve = self.model(name='default')\n        default_sieve.save()\n        default_sieve.nodes.all().delete()\n        for sieve in sieves:\n            content_type = ContentType.objects.get_for_model(node_model)\n            default_sieve.nodes.create(content_type=content_type,\n                                       object_id=sieve.pk)\n        return default_sieve\n\n\nclass Sieve(models.Model):\n    \"\"\"\n    An abstract base class for models that define rulesets. A Sieve is\n    associated with one or more SieveNodes.\n    \"\"\"\n    name = models.CharField(max_length=40, unique=True)\n    logic = models.CharField(\n        max_length=3,\n        choices=LOGIC_CHOICES,\n        default='AND',\n        help_text=_('Choose \"AND\" if all nodes should return True. '\n                    'Choose \"OR\" if one or more nodes should return True.'))\n    negate = models.BooleanField(default=False)\n\n    class Meta:\n        abstract = True\n        ordering = ['name']\n\n    def __str__(self):\n        return self.name\n\n    def _matches_all(self, data):\n        \"\"\"\n        Takes a dictionary of data and returns True if the data matches all\n        Rules in the RuleSet. Otherwise, returns False.\n        \"\"\"\n        for node in self.nodes.all():\n            if not node.is_match(data):\n                return False\n        return True\n\n    def _matches_any(self, data):\n        \"\"\"\n        Takes a dictionary of data and returns True if the data matches any Rule\n        in the RuleSet. Otherwise, returns False.\n        \"\"\"\n        for node in self.nodes.all():\n            if node.is_match(data):\n                return True\n        return False\n\n    def get_node_number(self):\n        \"\"\"\n        Returns the number of nodes associated with the Sieve.\n        \"\"\"\n        return self.nodes.count()\n\n    get_node_number.short_description = _('nodes')\n\n    def is_match(self, data):\n        \"\"\"\n        Takes a dictionary of data and returns True if the data meet the\n        criteria of the RuleSet. Otherwise, returns False.\n        \"\"\"\n        if self.logic == 'AND':\n            match = self._matches_all(data)\n        elif self.logic == 'OR':\n            match = self._matches_any(data)\n\n        if self.negate:\n            return not match\n        else:\n            return match\n\n\nclass SieveNode(models.Model):\n    \"\"\"\n    A SieveNode can reference either a Rule or a Sieve. Allows\n    construction of nested Sieves for complex rules.\n\n    The content_type choices should be limited to a derived class of Rules and\n    a derived class of Sieves specifically designed to handle that class of\n    Rules. This ensures that all Rules within a RuleSet handle the same type of\n    data (strings, dictionaries, etc.).\n\n    For example:\n\n        class MyRule(rules.DictionaryRule):\n            pass\n\n        class MyRuleSet(rules.RuleSet):\n            pass\n\n        class MyRuleNode(rules.RuleSetNode):\n            RULE = models.Q(app_label='myrules', model='myrule')\n            RULESET = models.Q(app_label='myrules', model='myruleset')\n            CONTENT_TYPES = RULE | RULESET\n\n            content_type = models.ForeignKey(ContentType, limit_choices_to=CONTENT_TYPES)\n            object_id = models.PositiveIntegerField()\n            node_object = GenericForeignKey()\n\n    \"\"\"\n    object_id = models.PositiveIntegerField()\n    node_object = GenericForeignKey()\n\n    class Meta:\n        abstract = True\n        unique_together = ('sieve', 'content_type', 'object_id')\n\n    def __str__(self):\n        return \"%s (%s)\" % (self.node_object, self.node_type)\n\n    @property\n    def node_type(self):\n        \"\"\"\n        Returns the name of the class for the type of node, which can be\n        either a DataRule or a DataSieve.\n        \"\"\"\n        return self.content_type.model\n\n    def is_match(self, data):\n        \"\"\"\n        Takes a data object and returns True if the data meets the Clause's\n        criterion. Otherwise, returns False.\n        \"\"\"\n        return self.node_object.is_match(data)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "tags/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1], "name": "tags/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom taxonomies.admin import TaxonomyAdmin\nfrom .models import Tag\n\n\nadmin.site.register(Tag, TaxonomyAdmin)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, 1, 1], "name": "tags/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines Tag class.\n\"\"\"\n\n# local\nfrom taxonomies.models import Taxonomy\n\n\nclass Tag(Taxonomy):\n    \"\"\"\n\n    \"\"\"\n\n    class Meta(object):\n        ordering = ['name']\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "target/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "target/followees/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, 1, null, null, 1, 1, null, null, 1, 1, null, null, 1, 1, 1, null], "name": "target/followees/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom target.followees.models import Followee, LegalName, Account\n\n\nclass FolloweeAdmin(admin.ModelAdmin):\n    pass\n\n\nclass LegalNameAdmin(admin.ModelAdmin):\n    pass\n\n\nclass AccountAdmin(admin.ModelAdmin):\n    pass\n\n\nadmin.site.register(Followee, FolloweeAdmin)\nadmin.site.register(LegalName, LegalNameAdmin)\nadmin.site.register(Account, AccountAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, 0, null, 1, null, null, null, null, 1, null, 1, null, null, null, 0, null, 1, null, null, null, 0, null, null, 1, null, null, null, 1, 1, 1, 1, null, 1, 0, null, 1, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, 1, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, 1], "name": "target/followees/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines classes used for following people across social media platforms.\n\"\"\"\n\n# third party\nfrom django.db import models\n\n# local\nfrom aggregator.reservoirs.models import Reservoir\n\n\nclass Followee(models.Model):\n    \"\"\"\n    A person being followed on social media. The person may be followed across\n    multiple social media platforms.\n\n    The followee's accounts are associated using a 'nickname', a general handle\n    by which the followee can be identified. A nickname is used because the\n    followee's legal name may not be known. However, a legal name can also be\n    associated with the followee to clarify his or her identity.\n\n    A followee can be linked to other followees through a symmetrical\n    'associates' relationship.\n    \"\"\"\n    nickname = models.CharField(max_length=255, unique=True, null=False)\n    associates = models.ManyToManyField('self', symmetrical=True)\n\n    def __str__(self):\n        return self.nickname\n\n    def find_accounts(self, reservoir):\n        \"\"\"\n        Returns the Followee's Accounts for a particular social media platform,\n        as defined by a Reservoir.\n        \"\"\"\n        return self.accounts.filter(platform__name=reservoir)\n\n    def add_associate(self, associate):\n        \"\"\"\n        Links the Followee to another Followee.\n        \"\"\"\n        self.associates.add(associate)\n\n    def get_associates(self):\n        \"\"\"\n        Gets Followees linked to this Followee.\n        \"\"\"\n        return self.associates\n\n\nclass LegalName(models.Model):\n    \"\"\"\n    The legal name associated with a person being followed (followee).\n    \"\"\"\n    followee = models.OneToOneField(Followee, primary_key=True)\n    first = models.CharField(max_length=255)\n    middle = models.CharField(max_length=255, default='')\n    last = models.CharField(max_length=255)\n\n    def __str__(self):\n        return self.get_full_name()\n\n    def get_full_name(self):\n        \"\"\"\n        If a middle name or initial exists, returns the first name, middle name,\n        and last name. Otherwise, returns the first and last name.\n        \"\"\"\n        if self.middle:\n            return '%s %s %s' % (self.first, self.middle, self.last)\n        else:\n            return '%s %s' % (self.first, self.last)\n\n    def get_last_name_first_name(self):\n        \"\"\"\n        Returns the last name followed by the first name and, if available,\n        a middle initial.\n        \"\"\"\n        if self.middle:\n            return '%s, %s %s' % (self.last, self.first, self.middle[0])\n        else:\n            return '%s, %s' % (self.last, self.first)\n\n\nclass Account(models.Model):\n    \"\"\"\n    A social media account associated with a person being followed (followee).\n    Consists of a social media platform, a followee's userid on that platform,\n    and the followee's username (screen name).\n\n    This is a many-to-one relationship; it is possible for a followee to be\n    associated with multiple accounts on the same platform, but only one\n    followee can be associated with a particular social media account account.\n    \"\"\"\n    followee = models.ForeignKey(Followee, related_name='accounts')\n    platform = models.ForeignKey(Reservoir)\n    user_id = models.CharField(max_length=255)\n    username = models.CharField(max_length=255)\n\n    class Meta:\n        \"\"\"\n        Metadata options.\n        \"\"\"\n        unique_together = ('platform', 'user_id')\n\n\nclass Alias(models.Model):\n    \"\"\"\n    Contains the record for a social media handle, such as a name or username\n    (screen name) associated with a social media account. This class serves to\n    keep track of the handles associated with an account over time (in case a\n    followee changes his or her screen name, for example).\n    \"\"\"\n    ROLE_CHOICES = (\n        ('name', 'Name'),\n        ('username', 'Username'),\n    )\n\n    account = models.ForeignKey(Account)\n    handle = models.CharField(max_length=255)\n    role = models.CharField(max_length=10, choices=ROLE_CHOICES)\n    date_added = models.DateTimeField(auto_now_add=True)\n\n    class Meta:\n        \"\"\"\n        Metadata options.\n        \"\"\"\n        unique_together = ('account', 'handle', 'role')\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, null, null, 0, null, null, 0, null, null, null, 0, 0, 0], "name": "target/followees/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nREST API serializer for followee.\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom .models import Followee\n\n\nclass ObjectSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Followees object.\n    \"\"\"\n    class Meta:\n        model = Followee\n        fields = ('id', 'nickname', 'associates')\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "target/locations/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, null, null, 1, null], "name": "target/locations/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib.gis import admin\n\n# local\nfrom target.locations.models import Location\n\n\nclass LocationAdmin(admin.OSMGeoAdmin):\n    \"\"\"\n\n    \"\"\"\n    default_lon = -10800000\n    default_lat = 4010000\n    default_zoom = 3\n\n\nadmin.site.register(Location, LocationAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, 1, 1, null, null, 1, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, 0, null, 1, null, null, null, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, 1, 1, null, 1, null, 1, 1, 1, null, 1, null, 1, 1, null, null, 1, null, 1, null, null, null, null, null, null, 1, 1, null, 1, 1, null, 1, 1, null, null, 1, null, 1, null, null, null, null, null, null, null, 1, 1, null, 1, 1, null, 1, 1, null, null, 1, null, 1, null, null, null, 1, null, null, null, null, null, 1, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, 1, 1, 1, 1, null], "name": "target/locations/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a class for a location (search area).\n\"\"\"\n\n# third party\nfrom django.db import models\nfrom django.contrib.gis.db import models\nfrom django.contrib.gis.geos import Point, Polygon, MultiPolygon\nfrom django.conf import settings\n\n# local\nfrom utils.geometry import shapes, units\n\n\nclass Location(models.Model):\n    \"\"\"\n    A geographic area that can be used in constructing a social media query.\n    \"\"\"\n    name = models.CharField(max_length=255, default='Untitled')\n    geom = models.GeometryField()\n    buffer_m = models.PositiveIntegerField(default=0)   # buffer in meters\n    created_by = models.ForeignKey(settings.AUTH_USER_MODEL)\n    editable = models.BooleanField(default=True)\n\n    # use GeoManager to allow geoqueries\n    objects = models.GeoManager()\n\n    def __str__(self):\n        \"\"\"\n        Returns a string providing the name of the location and the GeoJSON\n        feature type (Point, Polygon, etc.), as determined by its GEOSGeometry\n        class name.\n        \"\"\"\n        return '%s <%s>' % (self.name, type(self.geom).__name__)\n\n    def get_buffer(self):\n        \"\"\"\n        Returns the buffer zone in meters.\n        \"\"\"\n        return self.buffer_m\n\n    def has_buffer(self):\n        \"\"\"\n        Returns a Boolean indicating whether a Location has a buffer zone.\n        \"\"\"\n        return self.buffer_m > 0\n\n    @property\n    def centroid(self):\n        \"\"\"\n        Returns the centroid of the location.\n        \"\"\"\n        return self.geom.centroid\n\n    @property\n    def shape(self):\n        \"\"\"\n        Returns a string indicating the feature type. If the feature type is not\n        a Point, Polygon, or Multipolygon, returns 'Other'.\n        \"\"\"\n        if isinstance(self.geom, Point):\n            if self.has_buffer():\n                return 'Circle'\n            else:\n                return 'Point'\n\n        elif isinstance(self.geom, Polygon):\n            if shapes.is_rectangle(self.geom.exterior_ring):\n                return 'Rectangle'\n            else:\n                return 'Polygon'\n\n        elif isinstance(self.geom, MultiPolygon):\n            return 'MultiPolygon'\n\n        else:\n            return 'Other'\n\n    @property\n    def bbox(self):\n        \"\"\"\n        If the Location is a Circle, Rectangle, Polygon, or MultiPolygon,\n        returns the smallest rectangle that encompasses the Location's\n        geometry. Otherwise returns None.\n        \"\"\"\n        if self.shape is 'Circle':\n            return shapes.convert_circle_to_rectangle(self.geom, self.buffer_m)\n\n        elif self.shape is'Rectangle':\n            return self.geom\n\n        elif self.shape is 'Polygon' or self.shape is 'MultiPolygon':\n            return self.geom.envelope\n\n        else:\n            return None\n\n    @property\n    def radius_km(self):\n        \"\"\"\n        If the Location is a Circle, Rectangle, Polygon, or Multipolygon,\n        returns the distance in kilometers between the geometry's centroid and\n        the point on the geometry farthest from the centroid. Otherwise returns\n        None.\n        \"\"\"\n        if self.shape is 'Circle':\n            return units.meters_to_km(self.buffer_m)\n\n        elif self.shape is'Rectangle' or self.shape is 'Polygon':\n            return shapes.calculate_polygon_radius_km(self.geom)\n\n        elif self.shape is 'MultiPolygon':\n            return shapes.calculate_multipoly_radius_km(self.geom)\n\n        else:\n            return None\n\n    def get_bbox(self):\n        \"\"\"\n        Returns a Location based on the object's bounding box.\n        \"\"\"\n        return Location(\n            geom=self.bbox,\n            name=self.name + '-bbox',\n            created_by=self.created_by\n        )\n\n    def get_radius(self):\n        \"\"\"\n        Returns a Location based on the object's radius.\n        \"\"\"\n        return Location(\n            geom=self.centroid,\n            buffer_m=units.km_to_meters(self.radius_km),\n            name=self.name + '-radius',\n            created_by=self.created_by\n        )\n\n    def _create_radius(self, point, new_radius):\n        \"\"\"\n        Returns a Location based on the object's radius.\n        \"\"\"\n        return Location(\n            geom=Point(point),\n            buffer_m=new_radius,\n            name=self.name + '-factored',\n            created_by=self.created_by\n        )\n\n    def factor_by_radius_km(self, radius_km):\n        \"\"\"\n        Takes a Location and a radius in kilometers. Returns a list of Locations\n        representing circles of the specified radius that together cover the\n        area of the original Location.\n        \"\"\"\n        assert self.shape != 'Other', 'Shape must be Point, Polygon, or ' + \\\n                                      'Muiltpolygon'\n        polygon = self.bbox\n        points = shapes.factor_polygon_into_circles(polygon, radius_km)\n        radius = units.km_to_meters(radius_km)\n        return [self._create_radius(point, radius) for point in points]\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, null, null, 0, null, null, 0, null, null, null, 0, 0, 0, null], "name": "target/locations/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nREST API serializer for locations.\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom .models import Location\n\n\nclass LocationSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for locations object.\n    \"\"\"\n    class Meta:\n        model = Location\n        fields = ('id', 'name', 'geom', 'buffer_m', 'created_by', 'editable')\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, null, null, 0, 0, null, null, 0, null, null, null, 0, 0, 0], "name": "target/locations/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom rest_framework import generics\n\n# local\nfrom .models import Location\nfrom .serializers import LocationSerializer\n\n\nclass LocationsList(generics.ListAPIView):\n    \"\"\"\n    View for listing Locations.\n    \"\"\"\n    queryset = Location.objects.all()\n    serializer_class = LocationSerializer\n    filter_fields = ('name',)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "target/searchterms/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, 1, null, null, 1, null], "name": "target/searchterms/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom target.searchterms.models import SearchTerm\n\n\nclass SearchTermAdmin(admin.ModelAdmin):\n    pass\n\n\nadmin.site.register(SearchTerm, SearchTermAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, 1, null, null, null, 1, 1, null, 1, 0, 0, null, 0, 0, null, 1, null, null, null, null, 1, null, 1, null, null, null, 1, null, 1, null, null, null, 1, null, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, 1, 1, null, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, null, 1, 1, null, 1, 1, null, 1, null, null, 0, null, 1, null, null, null, 1, 1, null], "name": "target/searchterms/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a class for a search term, which can be a keyword or phrase.\n\"\"\"\n\n# standard library\nfrom copy import deepcopy\nimport re\n\n# third party\nfrom django.db import models\n\n\nclass SearchTerm(models.Model):\n    \"\"\"\n    A keyword or phrase to be used in a social media query.\n    \"\"\"\n    term = models.CharField(max_length=255, unique=True)\n    negate = models.BooleanField(default=False)\n\n    def __str__(self):\n        if self.negate:\n            prefix = 'NOT '\n        else:\n            prefix = ''\n        return '%s\"%s\"' % (prefix, self.term)\n\n    @property\n    def tag(self):\n        \"\"\"\n        Removes any spaces from a term and returns the result as a single string.\n        \"\"\"\n        return self.term.replace(' ', '')\n\n    def parse_term(self):\n        \"\"\"\n        Returns a list of words contained in the term.\n        \"\"\"\n        return re.split(' ', self.term)\n\n    def is_phrase(self):\n        \"\"\"\n        Returns True if the search term is a phrase.\n        \"\"\"\n        words = self.parse_term()\n\n        if len(words) > 1:\n            return True\n        else:\n            return False\n\n    def create_term_from_tag(self):\n        \"\"\"\n        Transforms a phrase into a tag and returns a new SearchTerm object\n        containing the tag.\n        \"\"\"\n        new_term = deepcopy(self)\n        new_term.term = self.tag\n        return new_term\n\n    def create_terms_from_words(self):\n        \"\"\"\n        Splits a phrase into its component words and returns a list of new\n        SearchTerm objects for each word.\n        \"\"\"\n        new_terms = []\n        words = self.parse_term()\n\n        for word in words:\n            new_term = deepcopy(self)\n            new_term.term = word\n            new_terms.append(new_term)\n\n        return new_terms\n\n    def create_terms_from_phrase(self):\n        \"\"\"\n        If the SearchTerm is a phrase, returns a list containing SearchTerms for\n        each individual word of the phrase, as well as a SearchTerm with the\n        phrase as a tag (i.e., without spaces between words). Otherwise, returns\n        a list containing only the original SearchTerm.\n        \"\"\"\n        # if the phrase is supposed to be negated, return an empty list,\n        # because we don't want a query that will negate the words individually\n        if self.negate:\n            return []\n\n        elif self.is_phrase():\n\n            new_terms = []\n\n            words = self.create_terms_from_words()\n            new_terms.extend(words)\n\n            tag = self.create_term_from_tag()\n            new_terms.append(tag)\n\n            return new_terms\n\n        else:\n            return [self]\n\n    def wrap_in_quotes(self):\n        \"\"\"\n        Returns the SearchTerm wrapped in double quotation marks.\n        \"\"\"\n        self.term = '\\\"%s\\\"' % (self.term)\n        return self\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, null, null, 0, null, null, 0, null, null, null, 0, 0, 0], "name": "target/searchterms/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nREST API serializer for searchterms.\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom .models import SearchTerm\n\n\nclass ObjectSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for searchterms object\n    \"\"\"\n    class Meta:\n        model = SearchTerm\n        fields = ('id', 'term', 'negate')\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, null, null, 0, null, null, null, null, null, 0, null, 0, 0, 0, 0, 0, null, 0, null, 0, null, null, 0, null, null, null, null, 0, null, 0, 0, 0, 0, null, 0, null, 0, null], "name": "target/services.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nA collection of methods to operate on all the different target packages.\n\"\"\"\n\n# standard library\nimport importlib\n\n\ndef create_targets(data):\n    \"\"\"\n    Takes a dictionary of data and creates target objects from it. Each \n    key in the dictionary must align to an attribute of the target object\n    it's trying to create.\n    \"\"\"\n    target_objects = {}\n\n    for key, value in data.iteritems():\n        try:\n            target = importlib.import_module(key)\n        except ImportError as error:\n            raise error\n        else:\n            target_objects[key] = create_target_object(target, value)\n\n    return target_objects\n    \n\ndef create_target_object(object_package, data_list):\n    \"\"\"\n    Creates a list of target objects given the target object package \n    and a list of dictionaries whose keys map to the objects attributes.\n    \"\"\"\n    targets = []\n\n    for data in data_list:\n        serializer = object_package.serializers.ObjectSerializer(data)\n        if serializer.is_valid():\n            targets.append(serializer.save())\n        else:\n            return \n    \n    return targets\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "target/timeframes/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, 1, null, null, 1, null], "name": "target/timeframes/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom target.timeframes.models import TimeFrame\n\n\nclass TimeFrameAdmin(admin.ModelAdmin):\n    pass\n\n\nadmin.site.register(TimeFrame, TimeFrameAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, 1, null, 1, null, null, null, 0, 0, null], "name": "target/timeframes/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a class for a time frame.\n\"\"\"\n\n# third party\nfrom django.db import models\n\n# local\nfrom utils.validators.validators import validate_timeframe\n\n\nclass TimeFrame(models.Model):\n    \"\"\"\n    A time frame.\n    \"\"\"\n    start = models.DateTimeField(blank=True, null=True)\n    end = models.DateTimeField(blank=True, null=True)\n\n    def clean(self):\n        \"\"\"\n        Adds custom validations to the model's clean() method.\n        \"\"\"\n        super(TimeFrame, self).clean()\n        validate_timeframe(self.start, self.end)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, null, null, 0, null, null, 0, null, null, null, 0, 0, 0, null], "name": "target/timeframes/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nREST API serializer for timeframe.\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom .models import TimeFrame\n\n\nclass ObjectSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for timeframes object\n    \"\"\"\n    class Meta:\n        model = TimeFrame\n        fields = ('id', 'start', 'end')\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "taxonomies/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, 1], "name": "taxonomies/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n\nclass TaxonomyAdmin(admin.ModelAdmin):\n    \"\"\"\n\n    \"\"\"\n    list_display = ['name', ]\n    link_display = ['name', ]\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, 1, null, 1, null, 1, 1, null, 1, 1], "name": "taxonomies/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Taxonomy base class.\n\"\"\"\n\n# third party\nfrom django.db import models\n\n# local\nfrom cyphon.models import GetByNameManager\n\n\nclass Taxonomy(models.Model):\n    \"\"\"\n\n    \"\"\"\n    name = models.CharField(max_length=255, unique=True)\n\n    objects = GetByNameManager()\n\n    class Meta:\n        abstract = True\n\n    def __str__(self):\n        return self.name\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "teasers/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, 1, null, null, 1, 1, 1, 1, 1, null, null, 1, 1, 1, 1, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, null, null, null, null, null, null, 1, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, 0, 0, 0, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, 1, 1, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, 1, 1, null, 1, 1, 1, 1, null, 0, null, 1, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, 1, 1, 1, 0, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, 1, 1, null, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, 1, 1, null, 1, null, null, 1, 1, null, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, 1, 1, null, 1, 1, 1, null, 1, 1], "name": "teasers/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Teaser base class used to display a teaser for a document.\nA Teaser provides basic information about the data, specifing \"Who,\"\n\"What,\" \"When,\" and \"Where.\"\n\"\"\"\n\n# standard library\nimport datetime\nimport json\n\n# third party\nfrom django.conf import settings\nfrom django.core import serializers\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.choices import GEOCOORDINATE_CHOICES\nfrom utils.geometry.shapes import convert_to_point\nfrom utils.parserutils.parserutils import get_dict_value\nfrom utils.dateutils.dateutils import date_from_str\n\n_DISTILLERY_SETTINGS = settings.DISTILLERIES\n_TEASER_SETTINGS = settings.TEASERS\n\n\nclass Teaser(models.Model):\n    \"\"\"\n    A Teaser maps the fields of a document to a standard set of fields\n    used to construct a preview of the document. This preview answers\n    basic questions about the nature of the data, such as Who?, What?,\n    When?, and Where?. Teasers can be used to display documents with\n    different schemas in a common format.\n\n    Attributes\n    ----------\n    author : str\n        The name of a CharField representing the person associated with\n        the document. (Answers the question, \"When?\")\n\n    title : str, optional\n        The name of a CharField summarizing the document. (Answers the\n        question, \"What?\")\n\n    content : str\n        The name of a CharField containing the main content of the\n        document. (Answers the question, \"What?\")\n\n    location : str\n        The name of a LocationField representing the location associated\n        with the document. (Answers the question, \"Where?\")\n\n    location_format : str\n        A |str| defining the order of geocoordinates. Choices are\n        limited to |GEOCOORDINATE_CHOICES|.\n\n    datetime : str\n        The name of a DateTimeField representing the date when the\n        document was generated or saved. (Answers the question, \"When?\")\n        This should refer to a field whose value is a |datetime| object.\n\n    date_string : str\n        The name of a CharField representing the date when the\n        document was generated or saved. This is an alternative to\n        :attr:`~Teaser.datetime`, which refers to a DateTimeField\n        (whose value is a |datetime| object).\n\n    date_format : str\n        A |str| containing |datetime| `format codes`_ for parsing\n        the value of the :attr:`~Teaser.date_string` field.\n\n    Notes\n    -----\n    Nested fields (i.e., fields in embedded documents) should be\n    indicated with dot notation (e.g. 'user.name').\n\n    Notes\n    -----\n    The date for a teaser will be taken from the :attr:`~Teaser.datetime`\n    field, if a value is provided. If not, the :attr:`~Teaser.date_string`\n    field will be used as a fallback.\n\n    Warning\n    -------\n    A teaser contains a `collection` field representing the |Collection|\n    in which the data is stored. This field is NOT redacted. Be\n    careful in using it if there is sensitive information in the\n    |Collection| or |Warehouse| name in which the data is stored.\n\n    _format codes: https://docs.python.org/3.4/library/datetime.html#strftime-and-strptime-behavior\n\n    \"\"\"\n    author = models.CharField(max_length=255, blank=True, null=True)\n    title = models.CharField(max_length=255)\n    content = models.CharField(max_length=255, blank=True, null=True)\n    location = models.CharField(max_length=255, blank=True, null=True)\n    location_format = models.CharField(\n        max_length=10,\n        blank=True,\n        null=True,\n        choices=GEOCOORDINATE_CHOICES,\n        default='LNG/LAT'\n    )\n    datetime = models.CharField(max_length=255, blank=True, null=True)\n    date_string = models.CharField(\n        max_length=255,\n        blank=True,\n        null=True,\n        help_text=_('An alternative to a datetime field. Use if the date is '\n                    'a string rather than a DateTime object.')\n    )\n    date_format = models.CharField(\n        max_length=255,\n        blank=True,\n        null=True,\n        help_text=_('If a date string is used, please enter its date format, '\n                    'if known (e.g., %Y-%m-%d %H:%M:%S %z).')\n    )\n\n    REDACTED_FIELDS = ('author', 'title', 'content')\n    \"\"\"`tuple`\n\n        Fields whose content should be redacted if the current |AppUser|\n        has :attr:`~appusers.models.AppUser.use_redaction` set to |True|.\n        Redaction is performed using |CodeBooks|.\n\n    \"\"\"\n\n    TEXT_FIELDS = ('author', 'title', 'content')\n    \"\"\"`tuple`\n\n        Fields whose values should be included in full-text searches of\n        teasers.\n\n    \"\"\"\n\n    class Meta:\n        abstract = True\n\n    def clean(self):\n        \"\"\"\n        Overrides the default clean() method.\n        \"\"\"\n        super(Teaser, self).clean()\n        if self.datetime and self.date_string:\n            raise ValidationError(\n                _('Please choose either a datetime field or a date '\n                  'string field, but not both.'))\n\n        # if self.date_string and not self.date_format:\n        #     raise ValidationError(\n        #         _('Please define a date format for the date string field '\n        #           '(e.g., %Y-%m-%d %H:%M:%S %z).'))\n\n    def _to_dict(self):\n        \"\"\"\n        Returns a dictionary in which the keys are the fields of the\n        Teaser model and the values are the object instance's values for\n        those fields. Location and date-related fields are not included.\n        \"\"\"\n        json_data = serializers.serialize('json', [self])\n        data = json.loads(json_data)\n        fields_dict = data[0]['fields']\n        return fields_dict\n\n    @staticmethod\n    def _get_collection_name(data):\n        \"\"\"\n        Takes a dictionary of distilled data and returns a string\n        representing the Collection where the data is stored.\n        \"\"\"\n        if data is not None:\n            raw_data = get_dict_value(_DISTILLERY_SETTINGS['RAW_DATA_KEY'],\n                                      data)\n            if raw_data:\n                try:\n                    return '.'.join([\n                        raw_data.get(_DISTILLERY_SETTINGS['BACKEND_KEY']),\n                        raw_data.get(_DISTILLERY_SETTINGS['WAREHOUSE_KEY']),\n                        raw_data.get(_DISTILLERY_SETTINGS['COLLECTION_KEY'])\n                    ])\n                except TypeError:\n                    return None\n            else:\n                return None\n\n    @staticmethod\n    def _trim_field_value(value):\n        \"\"\"\n        Takes a field value and trims it to TEASER_CHAR_LIMIT if\n        necessary.\n        \"\"\"\n        limit = _TEASER_SETTINGS['CHAR_LIMIT']\n        if isinstance(value, str) and len(value) > limit:\n            return value[:limit]\n        else:\n            return value\n\n    def _get_date_value(self, data):\n        \"\"\"\n        Takes a dictionary of data and attempts to return the date field.\n        If none exists, returns None.\n        \"\"\"\n        if self.datetime:\n            return get_dict_value(self.datetime, data)\n        elif self.date_string:\n            return get_dict_value(self.date_string, data)\n\n    def get_location(self, data):\n        \"\"\"Return the value of the location field.\n\n        Parameters\n        ----------\n        data : |dict|\n            A document from which to extract the date field.\n\n        Returns\n        -------\n        |Point| or |None|\n            The value of the location field.\n\n        \"\"\"\n        location = get_dict_value(self.location, data)\n        if location:\n            return convert_to_point(location, self.location_format)\n\n    def _get_teaser_data(self, data):\n        \"\"\"\n        Takes a dictionary of distilled data and returns a dictionary of\n        data that can be used to show a teaser (taste) of that data.\n        \"\"\"\n        sample = {}\n        field_dict = self._to_dict()\n\n        for key in self.TEXT_FIELDS:\n            field_name = field_dict[key]\n            if field_name:\n                sample[key] = get_dict_value(field_name, data)\n            else:\n                sample[key] = None\n\n        sample['date'] = self.get_date(data)\n        sample['location'] = self.get_location(data)\n        sample['collection'] = self._get_collection_name(data)\n\n        return sample\n\n    def get_date_field(self):\n        \"\"\"Get the name of the date field.\n\n        Returns\n        -------\n        str\n            The name of the field used for the |Teaser|'s date.\n\n        \"\"\"\n        if self.datetime:\n            return self.datetime\n        elif self.date_string and self.date_format:\n            return self.date_string\n\n    def get_date(self, data):\n        \"\"\"Return the value of the date field.\n\n        Parameters\n        ----------\n        data : |dict|\n            A document from which to extract the date field.\n\n        Returns\n        -------\n        |datetime| or |None|\n            The value of the date field.\n\n        \"\"\"\n        date = self._get_date_value(data)\n        if isinstance(date, datetime.datetime):\n            return date\n        elif date:\n            return date_from_str(str(date), self.date_format)\n\n    def get_sample(self, data):\n        \"\"\"Return a teaser for the data.\n\n        Parameters\n        ----------\n        data : |dict|\n            Data from which to create a teaser.\n\n        Returns\n        -------\n        |dict|\n            A teaser of the data.\n\n        \"\"\"\n        teaser_data = self._get_teaser_data(data)\n        sample = {}\n\n        for (key, val) in teaser_data.items():\n            if key in self.TEXT_FIELDS:\n                sample[key] = self._trim_field_value(val)\n            else:\n                sample[key] = val\n\n        return sample\n\n    def get_blind_sample(self, data, codebook):\n        \"\"\"Return a redacted teaser for the data.\n\n        Parameters\n        ----------\n        data : |dict|\n            Data from which to create a redacted teaser.\n\n        codebook : |CodeBook|\n            A |CodeBook| for redacting the teaser.\n\n        Returns\n        -------\n        |dict|\n            A redacted teaser of the data.\n\n        \"\"\"\n        teaser_data = self._get_teaser_data(data)\n        sample = {}\n\n        for (key, val) in teaser_data.items():\n\n            # redact fields before trimming them to avoid the risk of\n            # of regular expressions not catching truncated words\n            if isinstance(val, str) and key in self.REDACTED_FIELDS:\n                field_value = codebook.redact(val)\n            else:\n                field_value = val\n\n            # trim fields after redaction\n            if key in self.TEXT_FIELDS:\n                sample[key] = self._trim_field_value(field_value)\n            else:\n                sample[key] = field_value\n\n        return sample\n\n    def get_text_fields(self):\n        \"\"\"Return a list of names of searchable text fields.\n\n        Returns\n        -------\n        |list| of |str|\n            Names of searchable text fields associated with the Teaser.\n\n        \"\"\"\n        taste_dict = self._to_dict()\n        fields = []\n\n        for field in self.TEXT_FIELDS:\n            field_name = taste_dict[field]\n            fields.append(field_name)\n\n        fields.sort()\n        return fields\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "utils/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "utils/choices/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, null, null, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, 1, null, null, null, 1, null, 1, null, null, 1, null, null, 1, null, null, null, 1, 1, null, 1, 1, null, null, 1, null, null, null, 1, 1, null, 1, 0, null, 1, null, 1, null, null, 1, null, null, null, 0, 0, null, null, null, null, null, 0, 0, null, null, null, null, 0, 0, null, null, null, null, 0, 0, null, null, null, null, 0, 0, null, null, null, null, null, null, null, null, null, 0, null, null, null, null, 0, null, null, 1, null, null, null, 0, 0, 0], "name": "utils/choices/choices.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# standard library\nimport os\nimport re\nfrom operator import itemgetter\n\n# third party\nfrom django.conf import settings\n\n# local\nfrom bottler.bottles.models import BottleField\nfrom bottler.labels.models import LabelField\n\n_DISTILLERY_SETTINGS = settings.DISTILLERIES\n\n\ndef get_package_choices(path):\n    \"\"\"\n    (str) -> tuple(tuple)\n\n    Takes a path and returns a tuple of tuples representing the Python packages\n    it contains. Each inner tuple provides a (value, label) choice for a package.\n\n    Returns choices in a format suitable for use in a choices argument\n    for a CharField in a Django Model, e.g.:\n\n    >>> get_package_choices('platforms')\n    (('facebook', 'facebook'), ('twitter', 'twitter'))\n\n    \"\"\"\n    choices = []\n\n    # get a list of directories in the path\n    directories = next(os.walk(path))[1]\n\n    for directory in directories:\n\n        # skip the directory if it starts with '__' (e.g., '__pycache__')\n        # or if it's only used for tests\n        if not re.search('^(__|test)', directory):\n\n            this_path = os.path.join(path, directory)\n\n            # get the files in the directory\n            files = next(os.walk(this_path))[2]\n\n            # if the directory is a Python package...\n            if '__init__.py' in files:\n\n                # ...add the package name to the list of choices\n                # (let's just make the key and value the same)\n                choice = (directory, directory)\n                choices.append(choice)\n\n    choices.sort(key=itemgetter(0))\n    return tuple(choices)\n\n\ndef get_field_type(field_name):\n    \"\"\"\n\n    \"\"\"\n    field_segments = field_name.split('.')\n    is_label = field_segments[0] == _DISTILLERY_SETTINGS['LABEL_KEY']\n\n    if is_label:\n        field = LabelField.objects.get_by_natural_key(field_segments[-1])\n    else:\n        field = BottleField.objects.get_by_natural_key(field_segments[-1])\n\n    return field.field_type\n\n\ndef get_operator_choices(field_type):\n    \"\"\"\n\n    \"\"\"\n    if (field_type == 'CharField'):\n        options = [\n            ('regex', 'contains'),\n            ('eq', 'equals'),\n            ('not:regex', 'does not contain'),\n        ]\n\n    elif (field_type == 'BooleanField'):\n        options = [\n            ('eq', 'is true'),\n            ('not:eq', 'is false'),\n        ]\n\n    elif (field_type == 'DateTimeField'):\n        options = [\n            ('gte', 'occurred on or after'),\n            ('lte', 'occurred on or before'),\n        ]\n\n    elif (field_type == 'ListField'):\n        options = [\n            ('in', 'contains'),\n            ('not:in', 'does not contain'),\n        ]\n\n    elif (field_type in ['FloatField', 'IntegerField']):\n        options = [\n            ('eq', 'equals'),\n            ('ne', 'does not equal'),\n            ('gt', 'greater than'),\n            ('gte', 'greater than or equal to'),\n            ('lt', 'less than'),\n            ('lte', 'less than or equal to'),\n        ]\n\n    else:\n        options = [\n            ('eq', 'equals'),\n            ('not:eq', 'does not equal'),\n        ]\n\n    return options\n\n\ndef get_choice_by_value(choices, value):\n    \"\"\"\n\n    \"\"\"\n    for choice in choices:\n        if choice[0] == value:\n            return choice\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "utils/dateutils/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, 1, 1, null, null, 1, 1, null, null, 1, 1, 1, 1, null, 1, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, 1, 1, 1, 1, 1, 1, 1, 1, null, 1, 1, null, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, 1, 1, 1, null, null, 1, null, null, null, null, null, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, 1, null, 1, 1, null, 1, 1, 1, null, 1, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, 1, 1, 0, 0, 0, 0, null, 0, null, 1, 1, 1, null, 1, null], "name": "utils/dateutils/dateutils.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nUtility functions for dates and times. Provides a suite of functions\nfor manipulating dates and times. Defines a set of constants to be used for\ndefining time units.\n\"\"\"\n\n# standard library\nimport math\nimport datetime\nimport logging\n\n# third party\nimport dateutil.parser\nimport pytz\n\n# constants used for selectbox choices throughout the site\nSECONDS = 's'\nMINUTES = 'm'\nHOURS = 'h'\nDAYS = 'd'\n\nLOGGER = logging.getLogger(__name__)\n\nUTC_TZ = pytz.timezone('UTC')\n\n\ndef convert_hours_to_days(hours):\n    \"\"\"\n    (int or float) -> float\n\n    Takes time in hours and returns time in days.\n    \"\"\"\n    return hours / 24.0\n\n\ndef convert_hours_to_minutes(hours):\n    \"\"\"\n    (int or float) -> float\n\n    Takes time in hours and returns time in minutes.\n    \"\"\"\n    return hours * 60.0\n\n\ndef convert_hours_to_seconds(hours):\n    \"\"\"\n    (int or float) -> float\n\n    Takes time in hours and returns time in seconds.\n    \"\"\"\n    return convert_hours_to_minutes(hours) * 60.0\n\n\ndef convert_days_to_minutes(days):\n    \"\"\"\n    (int or float) -> float\n\n    Takes time in hours and returns time in minutes.\n    \"\"\"\n    hours = days * 24.0\n    return convert_hours_to_minutes(hours)\n\n\ndef convert_days_to_seconds(days):\n    \"\"\"\n    (int or float) -> float\n\n    Takes time in hours and returns time in seconds.\n    \"\"\"\n    return convert_days_to_minutes(days) * 60.0\n\n\ndef convert_minutes_to_seconds(seconds):\n    \"\"\"\n    (int or float) -> float\n\n    Takes time in seconds and returns time in minutes.\n    \"\"\"\n    return seconds * 60.0\n\n\ndef convert_minutes_to_hours(minutes):\n    \"\"\"\n    (int or float) -> float\n\n    Takes time in minutes and returns time in hours.\n    \"\"\"\n    return minutes / 60.0\n\n\ndef convert_minutes_to_days(minutes):\n    \"\"\"\n    (int or float) -> float\n\n    Takes time in minutes and returns time in days.\n    \"\"\"\n    return convert_minutes_to_hours(minutes) / 24.0\n\n\ndef convert_seconds_to_minutes(seconds):\n    \"\"\"\n    (int or float) -> float\n\n    Takes time in seconds and returns time in minutes.\n    \"\"\"\n    return seconds / 60.0\n\n\ndef convert_seconds_to_hours(seconds):\n    \"\"\"\n    (int or float) -> float\n\n    Takes time in seconds and returns time in hours.\n    \"\"\"\n    minutes = convert_seconds_to_minutes(seconds)\n    return convert_minutes_to_hours(minutes)\n\n\ndef convert_seconds_to_days(seconds):\n    \"\"\"\n    (int or float) -> float\n\n    Takes time in hours and returns time in seconds.\n    \"\"\"\n    hours = convert_seconds_to_hours(seconds)\n    return convert_hours_to_days(hours)\n\n\ndef convert_time_to_whole_minutes(time, unit):\n    \"\"\"\n    (int or float, str) -> int\n\n    Takes a time in hours, minutes, or seconds, and the time unit. The unit must\n    match a string defined by a constant (SECONDS, MINUTES, HOURS, or DAYS).\n    The function returns the ceiling of the time in minutes.\n    \"\"\"\n    conversions = {\n        SECONDS: convert_seconds_to_minutes(time),\n        MINUTES: time,\n        HOURS: convert_hours_to_minutes(time),\n        DAYS: convert_days_to_minutes(time)\n    }\n\n    minutes = conversions[unit]\n\n    return math.ceil(minutes)\n\n\ndef convert_time_to_seconds(time, unit):\n    \"\"\"\n    (int or float, str) -> int\n\n    Takes a time in hours, minutes, or seconds, and the time unit. The unit must\n    match a string defined by a constant (SECONDS, MINUTES, HOURS, or DAYS).\n    The function returns the ceiling of the time in seconds.\n    \"\"\"\n    conversions = {\n        SECONDS: time,\n        MINUTES: convert_minutes_to_seconds(time),\n        HOURS: convert_hours_to_seconds(time),\n        DAYS: convert_days_to_seconds(time)\n    }\n\n    return conversions[unit]\n\n\ndef convert_seconds(seconds):\n    \"\"\"\n    (int or float) -> str\n\n    Takes a time in seconds and returns a string that rounds the time\n    down to the most appropriate time unit.\n    \"\"\"\n    if seconds < 60:\n        return str(math.floor(seconds)) + ' s'\n    elif 60 <= seconds < 3600:\n        minutes = math.floor(convert_seconds_to_minutes(seconds))\n        return str(minutes) + ' m'\n    elif 3600 <= seconds < 86400:\n        hours = math.floor(convert_seconds_to_hours(seconds))\n        return str(hours) + ' h'\n    else:\n        days = math.floor(convert_seconds_to_days(seconds))\n        return str(days) + ' d'\n\n\ndef get_year_month_day(date):\n    \"\"\"\n    Takes a Date or a Datetime and returns a string in the form year-month-day\n    (e.g., \"2010-12-27\").\n    \"\"\"\n    new_date = datetime.date(date.year, date.month, date.day)\n    return new_date.isoformat()\n\n\ndef ensure_tz_aware(date):\n    \"\"\"\n\n    \"\"\"\n    if not date.tzinfo:\n        date = date.replace(tzinfo=UTC_TZ)\n    return date\n\n\ndef parse_date(date):\n    \"\"\"\n    Takes a string and attempts to parse it as a date. If successful,\n    returns a datetime object based on the string. Otherwise,\n    returns None.\n    \"\"\"\n    if isinstance(date, datetime.datetime):  # just in case...\n        return date\n    elif isinstance(date, str):\n        try:\n            parsed_date = dateutil.parser.parse(date)\n            return ensure_tz_aware(parsed_date)\n        except ValueError:\n            try:\n                return datetime.datetime.fromtimestamp(float(date), tz=UTC_TZ)\n            except ValueError:\n                return None\n    else:\n        return None\n\n\ndef format_date(date_string, date_format):\n    \"\"\"\n\n    \"\"\"\n    formatted_date = datetime.datetime.strptime(date_string, date_format)\n\n    year_directives = ['%y', '%Y', '%c', '%x']\n    contains_year = any(directive in date_format for directive in year_directives)\n\n    if not contains_year:\n        utc_now = datetime.datetime.now(tz=UTC_TZ)\n        formatted_date = formatted_date.replace(year=utc_now.year)\n\n    return ensure_tz_aware(formatted_date)\n\n\ndef date_from_str(date_string, date_format=None):\n    \"\"\"\n\n    \"\"\"\n    fail_msg = ('Could not parse the date string. '\n                'Please check the date format')\n\n    success_msg = ('Could not parse the date string using the given format, '\n                   'so a different parser was used. Please check the date '\n                   'format')\n\n    if date_format:\n        try:\n            date = format_date(date_string, date_format)\n        except ValueError as error:\n            date = parse_date(date_string)\n            if date:\n                LOGGER.warning('%s: %s', success_msg, error)\n            else:\n                LOGGER.error('%s: %s', fail_msg, error)\n    else:\n        date = parse_date(date_string)\n        if not date:\n            LOGGER.error(fail_msg)\n\n    return date\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "utils/dbutils/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, 1, null, null, 1, null, null, 1, null, null, null, null, 1, null, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, 1, null, 1, null, 1, 1, 1, null, 0, 0, 0, null, 1, null], "name": "utils/dbutils/dbutils.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n# standard library\nimport json\n\n# third party\nfrom django.core.serializers.json import DjangoJSONEncoder\n\n\ndef count_by_group(queryset, column, options):\n    \"\"\"\n    Takes a QuerySet, a column name, and an options list (tuple of 2-tuples).\n    Returns a dictionary containing the number of records for each option. \n    \"\"\"\n    counts = {}\n\n    for option in options:\n        value = option[0]\n        kwargs = {column: value}\n        counts[value] = queryset.filter(**kwargs).count()\n\n    return {column: counts}\n\n\ndef json_encodeable(data):\n    \"\"\"\n\n    \"\"\"\n    serialized_data = json.dumps(data, cls=DjangoJSONEncoder)\n    return json.loads(serialized_data)\n\n\ndef join_query(queries, logic):\n    \"\"\"\n\n    \"\"\"\n    assert logic in ['AND', 'OR']\n\n    joined_query = queries.pop()\n\n    if logic == 'OR':\n        for query in queries:\n            joined_query |= query\n\n    elif logic == 'AND':\n        for query in queries:\n            joined_query &= query\n\n    return joined_query\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "utils/geometry/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, null, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, 1, 1, null, 1, null, null, null, null, 1, 1, 1, null, 1, null, null, null, 1, 1, 1, null, 1, null, null, null, null, null, null, 1, null, 1, 1, null, 1, 1, 1, 1, null, 1], "name": "utils/geometry/bounds.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Bounds class to help with calculating dimensions of geographic\nbounds\n\"\"\"\n\n# third party\nfrom django.contrib.gis.geos import Polygon\nfrom geopy.distance import vincenty\n\n\nclass Bounds(object):\n    \"\"\"\n    Defines a northernmost latitude, southernmost latitude, easternmost\n    longitude, and westernmost longitude. Allows calculation of bounds\n    dimmensions in meters, as well as creation of a bounding box.\n    \"\"\"\n\n    def __init__(self, w_lng=180.0, s_lat=90.0, e_lng=-180.0, n_lat=-90.0):\n        \"\"\"\n        IMPORTANT: Initialization arguments are ordered w, s, e, n in order\n        to accept arguments from a GEOSGeometry extent, which is a 4-tuple\n        consisting of (xmin, ymin, xmax, ymax). This makes it easy to\n        initialize bounds directly, e.g.:\n\n        >>> from django.contrib.gis.geos import Polygon\n        >>> polygon = Polygon(((0, 0), (0, 1), (1, 1), (1, 0), (0, 0)))\n        >>> bounds = Bounds(*polygon.extent)\n\n        \"\"\"\n        self._n_lat = n_lat\n        self._s_lat = s_lat\n        self._e_lng = e_lng\n        self._w_lng = w_lng\n\n    # TODO(LH): add validations for lat/lng values\n\n    @property\n    def n_lat(self):\n        return self._n_lat\n\n    @n_lat.setter\n    def n_lat(self, value):\n        self._n_lat = value\n\n    @property\n    def s_lat(self):\n        return self._s_lat\n\n    @s_lat.setter\n    def s_lat(self, value):\n        self._s_lat = value\n\n    @property\n    def e_lng(self):\n        return self._e_lng\n\n    @e_lng.setter\n    def e_lng(self, value):\n        self._e_lng = value\n\n    @property\n    def w_lng(self):\n        return self._w_lng\n\n    @w_lng.setter\n    def w_lng(self, value):\n        self._w_lng = value\n\n    @property\n    def ne_corner(self):\n        return (self.e_lng, self.n_lat)\n\n    @property\n    def nw_corner(self):\n        return (self.w_lng, self.n_lat)\n\n    @property\n    def se_corner(self):\n        return (self.e_lng, self.s_lat)\n\n    @property\n    def sw_corner(self):\n        return (self.w_lng, self.s_lat)\n\n    @property\n    def bounding_box(self):\n        \"\"\"\n        Returns a rectangular geos Polygon constrained by the Bounds' latitude\n        and longitude limits.\n        \"\"\"\n        return Polygon((self.sw_corner, self.nw_corner, self.ne_corner,\n                        self.se_corner, self.sw_corner))\n\n    @property\n    def center_width_m(self):\n        \"\"\"\n        Returns the width of the bounding box at its center latitude, in meters.\n        \"\"\"\n        ave_lat = (self.n_lat + self.s_lat) / 2\n        return vincenty((ave_lat, self.w_lng), (ave_lat, self.e_lng)).meters\n\n    @property\n    def height_m(self):\n        \"\"\"\n        Returns the height of the bounding box in meters.\n        \"\"\"\n        nw_pt = (self.n_lat, self.w_lng)\n        sw_pt = (self.s_lat, self.w_lng)\n        return vincenty(nw_pt, sw_pt).meters\n\n    def get_width_at_latitude_m(self, lat):\n        \"\"\"\n        Returns the width of the bounding box at the given latitude, in meters.\n        \"\"\"\n        east = (lat, self.e_lng)\n        west = (lat, self.w_lng)\n        return vincenty(east, west).meters\n\n    def buffer(self, buffer_m):\n        \"\"\"\n        Takes a buffer distance in meters and extends the bounds by that\n        distance. Uses the average latitude of the current bounds to calculate\n        new latitude bounds. Over extremely large latitude bounds, the results\n        will lose accuracy.\n        \"\"\"\n        calculator = vincenty(meters=buffer_m)\n\n        ave_lng = (self.w_lng + self.e_lng) / 2\n        ave_lat = (self.n_lat + self.s_lat) / 2\n\n        self.n_lat = calculator.destination((self.n_lat, ave_lng), 0).latitude\n        self.s_lat = calculator.destination((self.s_lat, ave_lng), 180).latitude\n        self.e_lng = calculator.destination((ave_lat, self.e_lng), 90).longitude\n        self.w_lng = calculator.destination((ave_lat, self.w_lng), 270).longitude\n\n        return self\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, 1, null, null, 1, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, 1, null, null, 1, 1, null, 1, null, null, 1, 1, 1, 1, null, 1, 1, null, 1, 1, null, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, 1, null, 1, null, null, 1, null, 1, null, null, 1, null, 1, null, 1, null, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, 1, null, null, 1, null, null, 1, 1, 1, 1, null, 1, null, null, 1, null, null, 1, null, null, null, null, null, null, null, 1, 1, null, 1, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, null, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, 1, 1, 1, null, 1, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, null, 1, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, 1, null, null, 1, null, null, 1, null, null, 1, null, 1, null, null, 1, null, null, 1, null, null, 1, null, 1, null, null, 1, null, null, null, 1, 1, 0, 0, 0, 0, 0, 0, null, null], "name": "utils/geometry/shapes.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nProvides functions for measuring and transforming geometries.\n\"\"\"\n\n# standard library\nimport math\nimport logging\n\n# third party\nfrom django.contrib.gis.geos import Point, Polygon, MultiPolygon\nfrom geopy.distance import vincenty\n\n# local\nfrom utils.geometry.bounds import Bounds\n\nLOGGER = logging.getLogger(__name__)\n\n\ndef reverse_coordinate_order(coords):\n    \"\"\"\n    Takes a tuple of (lat, lng) or (lng, lat) coordinates and reverses their\n    order.\n    \"\"\"\n    assert(len(coords) == 2)\n    return (coords[1], coords[0])\n\n\ndef sides_parallel(coords, clockwise=True):\n    \"\"\"\n    Takes a 5-tuple of (x, y) coordinate tuples for a clockwise or\n    counterclockwise quadrilateral. Assumes coordinates start at\n    (min_x, min_y) and end at (min_x, min_y). Returns True if the\n    coordinates define a rectangle. Otherwise returns False.\n    \"\"\"\n    assert(len(coords) == 5)\n\n    # get coordinates for [bottom left, top left, top right, bottom right]\n    if clockwise:\n        corners = [coords[0], coords[1], coords[2], coords[3]]\n    else:\n        corners = [coords[0], coords[3], coords[2], coords[1]]\n\n    # get (x, y) values for each corner\n    (c0_min_x, c0_min_y) = corners[0]   # bottom left\n    (c1_min_x, c1_max_y) = corners[1]   # top left\n    (c2_max_x, c2_max_y) = corners[2]   # top right\n    (c3_max_x, c3_min_y) = corners[3]   # bottom right\n\n    left_rt_parallel = (c0_min_x == c1_min_x and c2_max_x == c3_max_x)\n    top_btm_parallel = (c0_min_y == c3_min_y and c1_max_y == c2_max_y)\n\n    has_width = (c0_min_x != c2_max_x and c1_min_x != c3_max_x)\n    has_height = (c0_min_y != c1_max_y and c3_min_y != c2_max_y)\n\n    if left_rt_parallel and top_btm_parallel and has_width and has_height:\n        return True\n    else:\n        return False\n\n\ndef is_rectangle(coords):\n    \"\"\"\n    (tuple(tuple(float or int, float or int))) -> Boolean\n\n    Takes a tuple of (x, y) coordinate tuples. Returns True if the\n    coordinates represent a rectangle. Otherwise returns False.\n    \"\"\"\n    # look for four segments defined by five points\n    has_four_segments = (len(coords) == 5)\n\n    if has_four_segments:\n\n        # the fifth point should be the same as the first\n        is_closed = (coords[0] == coords[4])\n\n        if is_closed:\n\n            # test sides for both clockwise or counterwise ordering of points\n            if sides_parallel(coords, clockwise=True) or \\\n                sides_parallel(coords, clockwise=False):\n                return True\n            else:\n                return False\n        else:\n            return False\n    else:\n        return False\n\n\ndef convert_circle_to_rectangle(point, radius_m):\n    \"\"\"\n    (tuple(int or float, int or float), int or float) -> GEOSGeometry Polygon\n\n    Takes a circle as a (lng, lat) tuple and a radius in meters. Returns the\n    smallest rectangular Polygon that encompasses the circle.\n    \"\"\"\n    # reverse the lng, lat order to convert to geopy Point format\n    center = reverse_coordinate_order(point)\n\n    # create a geopy coordinate calculator for the given distance\n    calculator = vincenty(meters=radius_m)\n\n    # calculate points at the given distance in the cardinal directions\n    n_pt = calculator.destination(point=center, bearing=0)\n    s_pt = calculator.destination(point=center, bearing=180)\n    e_pt = calculator.destination(point=center, bearing=90)\n    w_pt = calculator.destination(point=center, bearing=270)\n\n    bounds = Bounds(n_lat=n_pt.latitude, s_lat=s_pt.latitude,\n                    e_lng=e_pt.longitude, w_lng=w_pt.longitude)\n\n    return bounds.bounding_box\n\n\ndef calculate_farthest_dist_km(points, target):\n    \"\"\"\n    (tuple(tuple(lng, lat)), tuple(lng, lat)) -> float\n\n    Takes a tuple of (lng, lat) points and a (lng, lat) target. Returns the\n    distance in kilometers between the target and the point farthest from the\n    target.\n    \"\"\"\n    target_pt = reverse_coordinate_order(target)  # need (lat, lng) for vincenty\n    max_radius_km = 0\n\n    for point in points:\n        point = reverse_coordinate_order(point)  # need (lat, lng) for vincenty\n        distance = vincenty(point, target_pt).kilometers\n        if distance > max_radius_km:\n            max_radius_km = distance\n\n    return max_radius_km\n\n\ndef calculate_polygon_radius_km(polygon):\n    \"\"\"\n    Takes a GEOSGeometry Polygon and returns the distance in kilometers\n    between the Polygon's centroid and the point on the polygon farthest\n    from the centroid.\n    \"\"\"\n    assert(isinstance(polygon, Polygon))\n    target = polygon.centroid\n    points = polygon.exterior_ring\n    return calculate_farthest_dist_km(points, target)\n\n\ndef calculate_multipoly_radius_km(multipolygon):\n    \"\"\"\n    Takes a GEOSGeometry MultiPolygon and returns the distance in kilometers\n    between the MultiPolygon's centroid and the point on the MultiPolygon\n    farthest from the centroid.\n    \"\"\"\n    assert(isinstance(multipolygon, MultiPolygon))\n    target = multipolygon.centroid\n    max_radius_km = 0\n\n    for polygon in multipolygon:\n        points = polygon.exterior_ring\n        distance = calculate_farthest_dist_km(points, target)\n        if distance > max_radius_km:\n            max_radius_km = distance\n\n    return max_radius_km\n\n\ndef create_buffered_bounds(polygon, buffer_m):\n    \"\"\"\n    Takes a GEOSGeometry Polygon and a buffer distance in meters.\n    Returns a Bounds object representing the polygon bounds buffered\n    by the specified distance.\n    \"\"\"\n    assert(isinstance(polygon, Polygon))\n    return Bounds(*polygon.extent).buffer(buffer_m)\n\n\ndef calculate_circle_spacing(radius_m, overlap_m=0):\n    \"\"\"\n    Takes a radius in meters and an overlap in meters. Calculates the minimum\n    spacing of circles of the given radius that will ensure no gaps between\n    them. This is equal to the width of a square that fits inside the circle.\n    The overlap insures against gaps between circles when used to calculate\n    geographic coordinates.\n    \"\"\"\n    assert(radius_m > overlap_m)\n    return (2 * radius_m / math.sqrt(2)) - overlap_m\n\n\ndef factor_polygon_into_circles(polygon, radius_km):\n    \"\"\"\n    Takes a GEOSGeomtery Polygon and a radius in kilometers. Returns a list\n    of (lng, lat) tuples representing the centers of circles of the specified\n    radius that together cover the area of the Polygon.\n    \"\"\"\n    assert(isinstance(polygon, Polygon))\n    assert(radius_km > 0.01) # radius should be greater than overlap_m in spacing\n\n    # get the bounds of the polygon with a small safety buffer (1% of radius)\n    buffer_dist_m = (radius_km * 1000) * 0.01\n    bounds = create_buffered_bounds(polygon, buffer_dist_m)\n\n    # get the space between circle centers, with a safety margin of 10 meters\n    dist_bw_centers_m = calculate_circle_spacing(radius_km * 1000, overlap_m=10)\n\n    # create a coordinate calculator for the increment distance\n    calculator = vincenty(meters=dist_bw_centers_m)\n\n    points = [] # array for collecting the circle centers\n\n    # position first point so the circle intersects with the sw corner of bounds\n    starting_pt = vincenty(kilometers=radius_km).destination(\n        point=(bounds.s_lat, bounds.w_lng),\n        bearing=45\n    )\n\n    # get the starting latitude\n    lat = starting_pt.latitude\n\n    # find the number of rows of circles needed to span the height of the polygon\n    rows = int(math.ceil(bounds.height_m / dist_bw_centers_m))\n\n    for dummy_row_idx in range(rows):\n\n        # reset the starting longitude before each west-to-east loop\n        lng = starting_pt.longitude\n\n        # get the distance between w_lng and e_lng at the current latitude\n        width_m = bounds.get_width_at_latitude_m(lat)\n\n        # find the number of columns of circles needed to span the width\n        cols = int(math.ceil(width_m / dist_bw_centers_m))\n\n        for dummy_col_idx in range(cols):\n\n            # add current coordinates to point array\n            points.append((lng, lat))\n\n            # calculate next point to the east and increment longitude\n            lng = calculator.destination(point=(lat, lng), bearing=90).longitude\n\n        # calculate next point to the north and increment latitude\n        lat = calculator.destination(point=(lat, lng), bearing=0).latitude\n\n    return points\n\n\ndef convert_to_point(location, location_format):\n    \"\"\"\n    Takes a tuple or list of coordinates and converts them to a Point.\n    \"\"\"\n    if isinstance(location, Point):\n        return location\n    try:\n        if location_format.lower().startswith('lat'):\n            location = reverse_coordinate_order(location)\n        return Point(location)\n    except (AssertionError, TypeError) as error:\n        LOGGER.error('There was an error processing the location %s: %s',\n                     location, error)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, null], "name": "utils/geometry/units.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a Bounds class to help with calculating dimensions of geographic\nbounds\n\"\"\"\n\n# standard library\nimport math\n\n\ndef meters_to_km(meters):\n    \"\"\"\n    (int or float) -> float\n\n    Takes a distance in meters and returns the distance in kilometers.\n    \"\"\"\n    return meters / 1000.0\n\n\ndef km_to_meters(kilometers):\n    \"\"\"\n    (int or float) -> float\n\n    Takes a distance in kilometers and returns the distance in meters.\n    \"\"\"\n    return kilometers * 1000.0\n\n\ndef sq_meters_to_sq_km(sq_meters):\n    \"\"\"\n    (int or float) -> float\n\n    Takes a distance in square meters and returns the distance in square\n    kilometers.\n    \"\"\"\n    return sq_meters / 1000000.0\n\n\ndef sq_km_to_sq_meters(kilometers):\n    \"\"\"\n    (int or float) -> float\n\n    Takes a distance in square kilometers and returns the distance in square\n    meters.\n    \"\"\"\n    return kilometers * 1000000.0\n\n\ndef km_to_mi(kilometers):\n    \"\"\"\n    (int or float) -> float\n\n    Takes a distance in kilometers and returns the distance in miles.\n    \"\"\"\n    return kilometers * 0.62137119\n\n\ndef convert_meters_to_degrees(radius_m, rnd_dir='closest', places=7):\n    \"\"\"\n    Takes a measurement in meters and, optionally, a direction in which to\n    round the conversion and the number of decimal places for the result.\n    Returns the degrees latitude at the Equator. Because the conversion is based\n    on the circumference of the Earth at the Equator, conersions at other\n    latitudes will not be accurate.\n    \"\"\"\n    raw_degrees = radius_m / 111319.444\n\n    conversion = {\n        'closest': round(raw_degrees, places),\n        'down': (math.floor(raw_degrees * 10**places)) / 10**places,\n        'up': (math.ceil(raw_degrees * 10**places)) / 10**places\n    }\n\n    return conversion[rnd_dir]\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "utils/parserutils/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, 1, null, null, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, 1, null, 1, null, null, 1, null, null, 1, null, 1, null, null, 1, null, 1, null, 1, null, 1, null, null, 1, 1, null, 1, 1, null, 1, null, 1, null, null, 1, null, null, 1, 1, null, 1, null, 1, null, null, 0, null, 1, null, null, null, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, null, 1, null, null, null, 1, null, null, 1, 1, null, null, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, 1, 1, 1, 1, null, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, null, 1, 1, null, 1, null, 1, null, 1, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, null, 1, 1, 1, 1, 1, 1, 1, 1, 1, null, 1, null], "name": "utils/parserutils/parserutils.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nProvides parsing helper functions.\n\"\"\"\n\n# standard library\nfrom copy import deepcopy\nimport logging\nimport os\nimport re\n\n# third party\nfrom bson import ObjectId\nfrom bs4 import BeautifulSoup\n\nLOGGER = logging.getLogger(__name__)\n\n\ndef html_to_text(html):\n    \"\"\"Strip HTML tags from a string.\n\n    Parameters\n    ----------\n    html : |str|\n        Text containing HTML tags.\n\n    Returns\n    -------\n    |str|\n        Text without HTML tags. The string is indented according to\n        where tags were nested, but blank lines are removed.\n\n    Example\n    -------\n    >>> html = ('<html><head></head><body><p>Hi!<br>Here is the '\n    >>>         '<a href=\"https://www.python.org\">link</a> you wanted.</p></html>')\n    >>> html_to_text(html)\n           Hi!\n           Here is the\n            link\n           you wanted.\n\n    \"\"\"\n    html_parser = 'html5lib'\n    soup = BeautifulSoup(html, html_parser)\n    pretty_html = soup.prettify()\n    pretty_soup = BeautifulSoup(pretty_html, html_parser)\n    text = pretty_soup.get_text()\n    lines = [s for s in text.splitlines() if not re.search(r'^\\s*$', s)]\n    return os.linesep.join(lines)\n\n\ndef get_dict_value(field_name, doc):\n    \"\"\"Return the value of a dictionary item.\n\n    Parameters\n    ----------\n    field_name : |str|\n\n    doc : |dict|\n        A data dictionary.\n\n    Returns\n    -------\n    any type\n        The value associated with the given `field_name` from the `doc`.\n\n    Note\n    ----\n    For a nested dictionary, use dot notation in the `field_name`\n    (e.g., 'parentkey.childkey'). You may also reference an array value\n    by its index (e.g., 'tags[0]').\n\n    Examples\n    --------\n    >>> get_value('a.b.c', {'a': {'b': {'c': 100}}})\n    100\n\n    >>> doc = {'a': {'b': [{'c': [100, [15, 20]]}, {'d': 40}], 'e': 10}}\n    >>> field = 'a.b[0].c[1][1]'\n    >>> get_dict_value(field, doc)\n    20\n\n    \"\"\"\n\n    def get_array_value(doc, key):\n        \"\"\"\n        Takes a dictionary (doc) and a string (key) representing a dictionary\n        key and one or more array indexes, e.g. \"location[0][1]\". Returns the\n        corresponding value from the dictionary.\n        \"\"\"\n        # split key at the start of array values, e.g. 'loc[0]' -> ['loc', '0]']\n        key_parts = key.split('[')\n\n        # get the name of the parent field, e.g. \"loc\"\n        key = key_parts.pop(0)\n\n        # get the dictionary value, which is the first array\n        array = doc[key]\n\n        while len(key_parts) > 0:\n\n            index = key_parts.pop(0)\n\n            # remove trailing bracket from index value\n            index = index.replace(']', '')\n\n            # need to convert the string to an integer to use it as an index\n            index = int(index)\n\n            value = array[index]\n\n            # step into the next array\n            array = value\n\n        return value\n\n    if isinstance(field_name, str):\n\n        doc_copy = deepcopy(doc)\n\n        # parse the string into a list of keys\n        keys = field_name.split('.')\n        value = ''\n\n        try:\n            while len(keys) > 0:\n\n                if isinstance(doc_copy, dict):\n\n                    key = keys.pop(0)\n\n                    # remove any leading or trailing whitespaces\n                    key.strip()\n\n                    # check if the key includes an array index (e.g., 'location[0]')\n                    if '[' in key:\n                        value = get_array_value(doc_copy, key)\n                    else:\n                        value = doc_copy[key]\n\n                    doc_copy = value\n\n                else:\n                    return doc_copy\n\n        except KeyError:\n            # log this error so user knows to correct field_name\n            # LOGGER.warning('The field_name \"%s\" cannot be found in the document %s.',\n            #                field_name, str(doc)[:160])\n            return None\n\n        return value\n\n\ndef divide_into_groups(items, max_group_size):\n    \"\"\"Divide a list of items into a list of smaller lists.\n\n    Parameters\n    ----------\n    items : |list|\n        The items to divide into groups.\n\n    max_group_size : |int|\n        The maximum number of items per group.\n\n    Returns\n    -------\n    |list| of |list|\n        A list of lists dividing the items into groups not exceeding the\n        maximum group size.\n\n    Examples\n    --------\n    >>> divide_into_groups(['a', 'b', 'c', 'd', 'e'], 2)\n    [['a', 'b'], ['c', 'd'], ['e']]\n\n    >>> divide_into_groups(['a', 'b', 'c', 'd', 'e'], 6)\n    [['a', 'b', 'c', 'd', 'e']]\n\n    >>> divide_into_groups(['a', 'b', 'c', 'd', 'e'], 0)\n    [[]]\n\n    \"\"\"\n    assert max_group_size > 0, 'Maximum group size must be greater than 0'\n\n    items_copy = deepcopy(items)\n    groups = []\n\n    while len(items_copy) > 0:\n\n        # size of current group is either max number of items or\n        # number of remaining items, whichever is smaller\n        group_size = min(len(items_copy), max_group_size)\n\n        # save the items for the current group\n        new_group = items_copy[:group_size]\n        groups.append(new_group)\n\n        # remove the items from the list\n        del items_copy[:group_size]\n\n    return groups\n\n\ndef extract_substring(string, left, right, right_to_left=False):\n    \"\"\"Return a substring from a string.\n\n    Parameters\n    ----------\n    string : |str|\n        A string to be parsed.\n    left : |str|\n        A character representing the left bound of a target substring.\n    right : |str|\n        A character representing the right bound of a target substring.\n    right_to_left : |bool|, optional\n        Whether the `string` should be searched from right to left.\n\n    Returns\n    -------\n    |str|\n        The substring between the specified bounds.\n\n    Examples\n    --------\n    >>> extract_substring('dup key : { \"123\" }', ':', '}')\n    ' { \"123\" '\n\n    >>> extract_substring('$_id_1', '$', '_', True)\n    '_id'\n\n    \"\"\"\n    if right_to_left:\n        l_index = string.rfind(left) + len(left)\n        r_index = string.rfind(right)\n    else:\n        l_index = string.find(left) + len(left)\n        r_index = string.find(right)\n\n    return string[l_index:r_index]\n\n\ndef string_to_bool(value):\n    \"\"\"Recast a str representation of a Boolean to bool.\n\n    Parameters\n    ----------\n    value : |str|\n        The value to convert (e.g., 'false').\n\n    Returns\n    -------\n    |bool|\n        The Boolean value of `value`.\n\n    Notes\n    -----\n    If `value` is not 'true', 'True', 'false', or 'False', the function\n    simply converts the string to its Boolean value.\n\n    Examples\n    --------\n    >>> string_to_bool('true')\n    True\n\n    >>> string_to_bool('False')\n    False\n\n    >>> string_to_bool('0')\n    True\n\n    >>> string_to_bool(0)\n    False\n\n    \"\"\"\n    if value in ['true', 'True']:\n        return True\n    elif value in ['false', 'False']:\n        return False\n    else:\n        return bool(value)\n\n\ndef restore_type(field_type, value):\n    \"\"\"Recast a string value as a given type.\n\n    Parameters\n    ----------\n    field_type : {'BooleanField', 'CharField', 'FloatField', 'IntegerField'}\n        A model field type.\n\n    value : |str|\n        The value to recast.\n\n    Returns\n    -------\n    |bool|, |float|, |int|, or |str|\n        The value recast to the specified type.\n\n    Examples\n    --------\n    >>> restore_type('BooleanField', 'false')\n    False\n\n    >>> restore_type('CharField', '0')\n    '0'\n\n    >>> restore_type('FloatField', '1.2')\n    1.2\n\n    >>> restore_type('IntegerField', '1')\n    1\n\n    \"\"\"\n    field_types = {\n        'BooleanField': string_to_bool,\n        'CharField': str,\n        'FloatField': float,\n        'IntegerField': int,\n    }\n    return_val = lambda x: x\n    recast = field_types.get(field_type, return_val)\n    return recast(value)\n\n\ndef restore_type_from_str(string):\n    \"\"\"Restore a value to its inferred type.\n\n    Parameters\n    ----------\n    string : str\n        A |str| representation of a string, ObjectId, integer, or null\n        value.\n\n    Returns\n    -------\n    |str|, |ObjectId|, |int|, or |None|\n\n    Examples\n    --------\n    >>> restore_type('\"123\"')\n    '123'\n\n    >>> restore_type(\"ObjectId('123')\")\n    ObjectId('123')\n\n    >>> restore_type('123')\n    123\n\n    >>> restore_type('_123')\n    '_123'\n\n    >>> restore_type('null')\n    None\n\n    \"\"\"\n    if string[0] == '\"':\n        return string.replace('\"', '')\n    elif string[0] == \"'\":\n        return string.replace(\"'\", '')\n    elif re.match('ObjectId', string):\n        match = re.match(r'ObjectId\\(\\'(?P<id>.*)\\'\\)', string)\n        return ObjectId(match.group('id'))\n    elif string == 'null':\n        return None\n    else:\n        try:\n            return int(string)\n        except ValueError:\n            return string\n\n\ndef get_dup_key_val(errmsg):\n    \"\"\"Return the duplicate key referenced in an error message.\n\n    Parameters\n    ----------\n    errmsg : |str|\n        A pymongo `DuplicateKeyError` message.\n\n    Returns\n    -------\n    |dict|\n        The key(s) and value(s) of the duplicate key.\n\n    Example\n    -------\n    >>> errmsg = ('insertDocument :: caused by :: 11000 E11000 duplicate '\n    >>>           'key error collection: cyphon.posts index: '\n    >>>           '_platform_1_doc_id_1 dup key: { : twitter\", : '\n    >>>           '\"ObjectId(\\'5543769ef861c942838c7ee9\\') }')\n    >>> get_dup_key_val(errmsg)\n    {'_platform': 'twitter', '_doc_id': ObjectId('5543769ef861c942838c7ee9')}\n    \"\"\"\n    msg = errmsg.split(' dup key: { ')\n    key = extract_substring(msg[0], 'index: ', '_', 'right').strip()\n    val = extract_substring(msg[1], ':', '}').strip()\n\n    # parse compound indexes\n    keys = re.split(r'_[0-9]+_', key)\n    values = val.split(', : ')\n\n    assert len(keys) == len(values)\n\n    key_val = {}\n\n    for index in range(len(values)):\n        key_val[keys[index]] = restore_type_from_str(values[index])\n\n    return key_val\n\n\ndef format_fields(field_data, include_empty=True):\n    \"\"\"Format field labels and values.\n\n    Parameters\n    ----------\n    field_data : |list| of |tuple|\n       2-tuples of field labels and values.\n\n    include_empty : |bool|, optional\n        Whether fields whose values are |None| or an empty |str| should\n        be included in the formatted fields.\n\n    Returns\n    -------\n    str\n        Formatted field labels and values.\n\n    Examples\n    --------\n    >>> field_data = [('Name', 'Jane'), ('Age', 30), ('DOB', None)]\n    >>> format_fields(field_data, include_empty=True)\n    Name: Jane\n    Age:  30\n    DOB:  None\n\n    >>> field_data = [('Name', 'Jane'), ('Age', 30), ('DOB', None)]\n    >>> format_fields(field_data, include_empty=False)\n    Name: Jane\n    Age:  30\n\n    \"\"\"\n    max_label = 0\n    for (label, value) in field_data:\n        label_length = len(label)\n        if label_length > max_label:\n            max_label = label_length\n\n    fields = []\n    for (label, value) in field_data:\n        empty = str(value).strip() in ['', 'None']\n        if not empty or include_empty:\n            label_length = len(label.strip())\n            extra_spaces = ' ' * (max_label - label_length)\n            label_sep = ':' + extra_spaces + ' '\n            joined_field = label_sep.join([label, str(value)])\n            fields.append(joined_field)\n\n    return '\\n'.join(fields)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "utils/validators/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, 1, 1, null, 1, null, 1, null, null, null, 1, null, null, null, null, 1, 1, null, 1, 1, null, 1, 1, 1, null, null, 1, null, null, null, 1, 1, 1, null, null, 1, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, null, null, 1, null, null, null, 1, 1, null, 1, 1, null, 1, 1, null, null, null, 1, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, 1, 1, null, 1, 1, null, 1, 1, null, null, null, 1, null, null, null, 1, 1, 1, 1, null, null, null, 1, null, null, null, 1, 1, 1, 1], "name": "utils/validators/validators.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nProvides field validators.\n\"\"\"\n\n# standard library\nimport re\n\n# third party\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.utils.translation import ugettext_lazy as _\nfrom django.core.validators import RegexValidator\n\n_DISTILLERY_SETTINGS = settings.DISTILLERIES\n\nIDENTIFIER_VALIDATOR = RegexValidator(r'[a-zA-Z_][a-zA-Z0-9_]*',\n                                      'Not a valid Python identifier')\n\n\ndef validate_str_substitution(template, value_count):\n    \"\"\"\n    Ensures that the number of values provided for a string formatter\n    matches the number of specifiers in the template.\n    \"\"\"\n    if not template and value_count > 1:\n        raise ValidationError(_('No template has been provided '\n                                'for formatting multiple fields.'))\n    elif template:\n        specifiers = re.findall(r'{[0-9]?}', template)\n\n        if len(specifiers) > value_count:\n            if value_count == 1:\n                raise ValidationError(_('The formatter should only contain one '\n                                        '\"{}\" specifier for the source field.'))\n            else:\n                raise ValidationError(_('The number of \"{}\" specifiers in '\n                                        'the formatter exceeds the number '\n                                        'of source fields.'))\n\n        elif len(specifiers) < value_count:\n            if value_count == 1:\n                raise ValidationError(_('The formatter should contain one \"{}\" '\n                                        'specifier.'))\n            else:\n                raise ValidationError(_('The formatter contains too few \"{}\" '\n                                        'specifiers for the number of source '\n                                        'fields.'))\n\n\ndef validate_timeframe(start, end):\n    \"\"\"\n    Validator to ensure that the start and end datetimes make sense (i.e.,\n    that the start datetime is before the end datetime, and the endtime is no\n    later than the current time).\n    \"\"\"\n    if start >= end:\n        raise ValidationError(u'Start date and time must precede '\n                              'end date and time.')\n\n\ndef db_name_validator(db_name):\n    \"\"\"\n    Validates a Collection or Warehouse name.\n    \"\"\"\n    if re.match(r'^\\$', db_name):\n        raise ValidationError(_('Name cannot start with \"$\"'))\n\n    elif re.search(r'\\s', db_name):\n        raise ValidationError(_('Name cannot contain spaces'))\n\n    elif re.search(r'\\W', db_name.replace('$', '')):\n        raise ValidationError(_('Name cannot contain special characters'\n                                'other than underscores and $.'))\n\n\ndef field_name_validator(field_name):\n    \"\"\"\n    Validates a field name for a document.\n\n    Note that this validator allows periods in the name. Dot notation\n    is permitted because it will be used to nest the field within the\n    document. E.g., a field name 'user.screen_name' will be saved as\n    the field 'screen_name' within the embedded document 'user'.)\n    \"\"\"\n    reserved_names = [\n        '_id',\n        _DISTILLERY_SETTINGS['LABEL_KEY'],\n        _DISTILLERY_SETTINGS['RAW_DATA_KEY']\n    ]\n\n    if field_name in reserved_names:\n        raise ValidationError(_('%s is a reserved field name' % field_name))\n\n    elif re.match(r'^\\$', field_name):\n        raise ValidationError(_('Field name cannot start with \"$\"'))\n\n    elif re.search(r'\\s', field_name):\n        raise ValidationError(_('Field name cannot contain spaces'))\n\n    elif re.search(r'\\W', field_name.replace('$', '').replace('@', '')):\n        raise ValidationError(_('Field name cannot contain special characters'\n                                'other than underscores, @, and $.'))\n\n\ndef key_file_validator(field_file):\n    \"\"\"\n    Validates a FieldFile.\n    \"\"\"\n    filename = field_file.name\n    valid_ext = filename.endswith('.pem') or filename.endswith('.pub')\n    if not valid_ext:\n        raise ValidationError(_('The key file must be either '\n                                'a .pem or .pub file.'))\n\n\ndef regex_validator(value):\n    \"\"\"\n    Validates a regex.\n    \"\"\"\n    try:\n        re.compile(value)\n    except re.error:\n        raise ValidationError(_('Please provide a valid regular expression.'))\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], "name": "warehouses/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, 1], "name": "warehouses/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nCustomizes admin pages for |Warehouses| and |Collections|.\n\n=========================  ========================================\nClass                      Description\n=========================  ========================================\n:class:`~CollectionAdmin`  Customize admin pages for |Collections|.\n:class:`~WarehouseAdmin`   Customize admin pages for |Warehouses|.\n=========================  ========================================\n\n\"\"\"\n\n# third party\nfrom django.contrib import admin\n\n# local\nfrom warehouses.models import Warehouse, Collection\n\n\n@admin.register(Warehouse)\nclass WarehouseAdmin(admin.ModelAdmin):\n    \"\"\"Customize admin pages for |Warehouses|.\"\"\"\n\n    list_display = (\n        'name',\n        'backend',\n        'time_series',\n    )\n\n    ordering = ['backend', 'name']\n\n\n@admin.register(Collection)\nclass CollectionAdmin(admin.ModelAdmin):\n    \"\"\"Customize admin pages for |Collections|.\"\"\"\n\n    list_display = (\n        '__str__',\n        'get_warehouse_name',\n        'name',\n        'get_backend',\n        'in_time_series',\n        'get_company',\n    )\n\n    ordering = ['warehouse__backend', 'warehouse__name', 'name']\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, 1, 1, 1, 1, 1, null, null, 1, 1, null, 1, 1, null, 1, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, 1, null, 1, null, null, null, null, null, 1, null, 1, null, null, 1, 1, null, 1, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, 1, null, 1, null, null, 1, 1, null, 1, null, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, 1, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, 1, 1, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1], "name": "warehouses/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nThis module defines models and model managers for storing and retrieving data.\n\nThese models provide a layer of abstraction between Cyphon and the\nstorage engines with which it interacts.\n\n===========================  ==================================================\nClass                        Description\n===========================  ==================================================\n:class:`~Collection`         A document collection, doctype, or database table.\n:class:`~CollectionManager`  Model manager for |Collections|.\n:class:`~Warehouse`          A database or search index.\n:class:`~WarehouseManager`   Model manager for |Warehouses|.\n===========================  ==================================================\n\n\"\"\"\n\n# standard library\nimport importlib\nimport logging\n\n# third party\nfrom django.conf import settings\nfrom django.core.exceptions import ObjectDoesNotExist, ValidationError\nfrom django.db import models\nfrom django.utils.functional import cached_property\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom engines.registry import ENGINES_PACKAGE, ENGINE_MODULE, BACKEND_CHOICES\nfrom utils.validators.validators import db_name_validator\n\n_PAGE_SIZE = settings.PAGE_SIZE\n_WAREHOUSE_SETTINGS = settings.WAREHOUSES\n\n_LOGGER = logging.getLogger(__name__)\n\n\nclass WarehouseManager(models.Manager):\n    \"\"\"Manage |Collection| objects.\n\n    Adds methods to the default Django model manager.\n    \"\"\"\n\n    def get_by_natural_key(self, backend, name):\n        \"\"\"Get a |Warehouse| by its natural key.\n\n        Allows retrieval of a |Warehouse| by its natural key instead of\n        its primary key.\n\n        Parameters\n        ----------\n        backend : str\n            The backend of the |Warehouse|.\n\n        name : str\n            The name of the |Warehouse|.\n\n        Returns\n        -------\n        |Warehouse|\n            The |Warehouse| associated with the natural key.\n\n        \"\"\"\n        try:\n            return self.get(backend=backend, name=name)\n        except ObjectDoesNotExist:\n            _LOGGER.error('%s %s.%s does not exist',\n                          self.model.__name__, backend, name)\n\n\nclass Warehouse(models.Model):\n    \"\"\"Define a database or search index.\n\n    Attributes\n    ----------\n    backend : str\n        Lowercase name of a storage engine, such as 'elasticsearch'.\n        This corresponds to the base file name of the module containing\n        the |Engine| subclass for that storage engine. Choices are\n        constrained to |BACKEND_CHOICES|.\n\n    name : str\n        The name of a database or search index.\n\n    time_series : bool\n        Whether data should be stored as a time series (e.g.,\n        timestamped indexes).\n\n    \"\"\"\n    _DEFAULT_STORAGE_ENGINE = _WAREHOUSE_SETTINGS['DEFAULT_STORAGE_ENGINE']\n\n    backend = models.CharField(max_length=40, choices=BACKEND_CHOICES,\n                               default=_DEFAULT_STORAGE_ENGINE.lower())\n    name = models.CharField(max_length=40,\n                            validators=[db_name_validator])\n    time_series = models.BooleanField(\n        default=False,\n        help_text=_('When used with Elasticsearch, stores each day\\'s '\n                    'data in a separate index. Allows easy deletion '\n                    'of old data in Elasticsearch.'))\n\n    objects = WarehouseManager()\n\n    class Meta(object):\n        \"\"\"Metadata options.\"\"\"\n\n        unique_together = ('backend', 'name')\n        ordering = ['name']\n\n    def __str__(self):\n        \"\"\"Get a string representation of the Warehouse instance.\n\n        Returns a printable string showing the `backend` and `name`.\n        \"\"\"\n        return '%s.%s' % (self.backend, self.name)\n\n    def _allow_time_series(self):\n        \"\"\"Whether data can be stored in a time series.\n\n        Returns a `bool` indicating whether the backend can store data\n        in a time series (e.g., timestamped indexes).\n        \"\"\"\n        module = self.get_module()\n        return module.TIME_SERIES_ENABLED\n\n    def clean(self):\n        \"\"\"Validate the model as a whole.\n\n        Provides custom model validation. If `time_series` is |True|,\n        checks that the backend can work with a time series.\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        ValidationError\n            If `time_series` is |True| but the selected `backend`\n            cannot work with a time series, or if any default Django\n            model validations fail.\n\n        See also\n        --------\n        See Django's documentation for the\n        :meth:`~django.db.models.Model.clean` method.\n\n        \"\"\"\n        super(Warehouse, self).clean()\n        if self.time_series and not self._allow_time_series():\n            raise ValidationError(_('The time series feature is not '\n                                    'enabled for the selected backend.'))\n\n    def get_module(self):\n        \"\"\"Get the module for interacting with the backend.\n\n        Returns\n        -------\n        :class:`~module`\n            The module that contains the |Engine| subclass for\n            interacting with the Warehouse's backend.\n\n        \"\"\"\n        # e.g., 'engines.mongodb.engine'\n        module_full_name = '%s.%s.%s' % (ENGINES_PACKAGE, self.backend,\n                                         ENGINE_MODULE)\n\n        # load the module (will raise ImportError if module cannot be loaded)\n        module = importlib.import_module(module_full_name)\n        return module\n\n\nclass CollectionManager(models.Manager):\n    \"\"\"Manage |Collection| objects.\n\n    Customizes the default Django model manager by adding and overriding\n    methods.\n    \"\"\"\n\n    def get_queryset(self):\n        \"\"\"Get the initial |Collection| queryset.\n\n        Overrides the default `get_queryset` method to also select\n        related |Warehouses|.\n\n        Returns\n        -------\n        |Queryset|\n            A |Queryset| of |Collections|.\n\n        See also\n        --------\n        Django's documentation contains instructions on how to\n        `select related`_ objects and `modify an initial queryset`_.\n\n        \"\"\"\n        default_queryset = super(CollectionManager, self).get_queryset()\n        return default_queryset.select_related('warehouse')\n\n    def get_by_natural_key(self, backend, database, name):\n        \"\"\"Get a |Collection| by its natural key.\n\n        Allows retrieval of a |Collection| by its natural key instead of its\n        primary key.\n\n        Parameters\n        ----------\n        backend : str\n            The backend of the |Warehouse| to which the |Collection| belongs.\n\n        database : str\n            The name of the |Warehouse| to which the |Collection| belongs.\n\n        name : str\n            The name of the |Collection|.\n\n        Returns\n        -------\n        |Collection|\n            The |Collection| associated with the natural key.\n\n        \"\"\"\n        warehouse = Warehouse.objects.get_by_natural_key(backend, database)\n        try:\n            return self.get(warehouse=warehouse, name=name)\n        except ObjectDoesNotExist:\n            _LOGGER.error('%s %s.%s.%s does not exist',\n                          self.model.__name__, backend, database, name)\n\n\nclass Collection(models.Model):\n    \"\"\"Define a document collection, document type, or database table.\n\n    Attributes\n    ----------\n    warehouse : Warehouse\n        The |Warehouse| in which the |Collection| resides.\n\n    name : str\n        The name of a document collection, doc type, or database table,\n        depending on the |Warehouse| backend.\n\n    \"\"\"\n\n    warehouse = models.ForeignKey(Warehouse, related_name='collections',\n                                  related_query_name='collection')\n    name = models.CharField(max_length=40, verbose_name='collection name',\n                            validators=[db_name_validator])\n\n    objects = CollectionManager()\n\n    class Meta(object):\n        \"\"\"Metadata options.\"\"\"\n\n        unique_together = ('warehouse', 'name')\n        ordering = ['warehouse', 'name']\n\n    def __str__(self):\n        \"\"\"Get a string representation of the Collection instance.\n\n        Returns a printable string showing the `backend` and `name` of\n        the Collection's |Warehouse|, as well as the Collection's `name`.\n        \"\"\"\n        return '%s.%s.%s' % (self.warehouse.backend, self.warehouse.name,\n                             self.name)\n\n    @cached_property\n    def company(self):\n        \"\"\"The |Company| associated with the Collection.\n\n        Returns\n        -------\n        |Company|\n            The |Company| associated with the Collection's |Distillery|.\n\n        \"\"\"\n        try:\n            return self.distillery.company\n        except ObjectDoesNotExist:\n            return None\n\n    def get_company(self):\n        \"\"\"Get the |Company| associated with the Collection.\n\n        This method is used to display the Company in the admin list view.\n\n        Returns\n        -------\n        |Company|\n            The |Company| associated with the Collection's |Distillery|.\n\n        \"\"\"\n        return self.company\n\n    get_company.short_description = 'company'\n\n    def _get_module(self):\n        \"\"\"Get the `engines` module for working with the Collection.\n\n        Returns the module that contains the |Engine| suclass for\n        interacting with the Collection.\n        \"\"\"\n        return self.warehouse.get_module()\n\n    def _get_class(self):\n        \"\"\"Get the |Engine| subclass for working with the Collection.\n\n        Returns the |Engine| suclass responsible for communicating with\n        the backend. This will raise an :exc:`~AttributeError` if the\n        class cannot be found.\n        \"\"\"\n        module = self._get_module()\n        return getattr(module, module.ENGINE_CLASS)\n\n    def get_backend(self):\n        \"\"\"Get the backend used by the Collection.\n\n        Returns the name of the backend associated with the Collection's\n        |Warehouse|. This method can be used to display the backend in\n        the admin list view.\n\n        Returns\n        -------\n        str\n            The backend used by the Collection's |Warehouse|.\n\n        \"\"\"\n        return self.warehouse.backend\n\n    get_backend.short_description = 'backend'\n\n    def in_time_series(self):\n        \"\"\"Whether the Collection's |Warehouse| is a time series.\n\n        Returns a |bool| indicating whether the Collection's |Warehouse|\n        stores data in a time series (e.g., timestamped indexes).\n\n        Returns\n        -------\n        bool\n            Whether data is stored as a time series.\n\n        \"\"\"\n        return self.warehouse.time_series\n\n    in_time_series.short_description = 'time series'\n\n    def get_warehouse_name(self):\n        \"\"\"Get the name of the Collection's |Warehouse|.\n\n        This method is used to display the Warehouse name in the admin\n        list view.\n\n        Returns\n        -------\n        str\n            The name of the Collection's |Warehouse|.\n\n        \"\"\"\n        return self.warehouse.name\n\n    get_warehouse_name.short_description = 'warehouse name'\n\n    def get_schema(self):\n        \"\"\"Get the |DataFields| used by documents in the Collection.\n\n        Returns\n        -------\n        |list| of |DataFields|\n            The |DataFields| in the |Container| used by the Collection's\n            |Distillery|.\n\n        \"\"\"\n        if hasattr(self, 'distillery'):\n            return self.distillery.schema\n        else:\n            return []\n\n    def get_sample(self, doc):\n        \"\"\"Get a teaser for a doc.\n\n        Parameters\n        ----------\n        doc : dict\n            A document that conforms to the Collection's schema, which\n            is defined by the |Container| used by the Collection's\n            |Distillery|.\n\n        Returns\n        -------\n        dict\n            A teaser for the original the `doc`.\n\n        \"\"\"\n        return self.distillery.get_sample(doc)\n\n    def _get_engine(self):\n        \"\"\"Get an |Engine| for handling documents.\n\n        Returns an instance of an |Engine| subclass that can be used to\n        handle documents associated with the Collection.\n\n        This method is used to simplify testing, since it can be called\n        in different contexts after the Collection is intialized\n        (whereas the `engine` property that uses it is cached, making\n        patches more difficult to apply).\n        \"\"\"\n        engine_class = self._get_class()\n        try:\n            return engine_class(self)\n        except ConnectionRefusedError as error:\n            _LOGGER.error(error)\n\n    @cached_property\n    def engine(self):\n        \"\"\"An |Engine| for handling documents.\n\n        Returns\n        -------\n        |Engine|\n            An instance of an |Engine| subclass that can be used to\n            handle documents associated with the Collection.\n\n        \"\"\"\n        return self._get_engine()\n\n    def find_by_id(self, doc_ids):\n        \"\"\"Find one or more documents by id.\n\n        Parameters\n        ----------\n        doc_ids : |str| or |list| of |str|\n            A document id or a list of document ids.\n\n        Returns\n        -------\n        |dict|, |list| of |dict|, or |None|\n            Documents that match the given id(s). Returns a |list| of\n            documents if `doc_ids` is a |list|; otherwise returns a\n            single document. If no matches are found, returns |None|.\n\n        \"\"\"\n        return self.engine.find_by_id(doc_ids)\n\n    def find(self, query, sorter=None, page=1, page_size=_PAGE_SIZE):\n        \"\"\"Find documents matching a query.\n\n        Parameters\n        ----------\n        query : |EngineQuery|\n            An |EngineQuery| defining critieria for matching documents\n            in the index or time series.\n\n        sorter : |Sorter| or |None|\n            A |Sorter| defining how results should be ordered.\n\n        page : int\n            The page of results to return.\n\n        page_size : int\n            The number of documents per page of results.\n\n        Returns\n        -------\n        |list| of |dict|\n            Documents matching the query.\n\n        \"\"\"\n        return self.engine.find(query, sorter, page, page_size)\n\n    def filter_ids(self, doc_ids, fields, value):\n        \"\"\"Find the ids of documents that match a value.\n\n        Parameters\n        ----------\n        doc_ids : |list| of |str|\n            The ids of documents to filter.\n\n        fields : |list| of |DataField|\n            |DataFields| that should be examined for a matching value.\n\n        value : |str|\n            A value used to find matching documents.\n\n        Returns\n        -------\n        |list| of |str|\n            The subset of ids for documents containing the given `value`\n            in one or more of the specified `fields`.\n\n        \"\"\"\n        return self.engine.filter_ids(doc_ids, fields, value)\n\n    def insert(self, doc):\n        \"\"\"Save a document to the Collection.\n\n        Parameters\n        ----------\n        doc : dict\n            A document to insert into the data store represented by the\n            Collection.\n\n        Returns\n        -------\n        str\n            The id of the inserted document.\n\n        \"\"\"\n        try:\n            return self.engine.insert(doc)\n\n        # different backends may throw different exceptions\n        except Exception as error:  # pylint: disable=W0703\n            _LOGGER.exception('Insertion error: %s', error)\n\n    def remove_by_id(self, doc_ids):\n        \"\"\"Remove the documents with the given ids.\n\n        Parameters\n        ----------\n        doc_ids : |str| or |list| of |str|\n            An id or list of ids of documents to remove from the\n            Collection.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        return self.engine.remove_by_id(doc_ids)\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, 1, null, null, 1, null, null, 1, null, null, 1, 1, null, null, 1, null, null, 1, null, null, 1, 1], "name": "warehouses/serializers.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines serializers for |Warehouses| and |Collections|.\n\n==============================  =============================\nClass                           Description\n==============================  =============================\n:class:`~CollectionSerializer`  Serializer for |Collections|.\n:class:`~WarehouseSerializer`   Serializer for |Warehouses|.\n==============================  =============================\n\n\"\"\"\n\n# third party\nfrom rest_framework import serializers\n\n# local\nfrom warehouses.models import Warehouse, Collection\n\n\nclass WarehouseSerializer(serializers.HyperlinkedModelSerializer):\n    \"\"\"Serializer for a |Warehouse| object.\"\"\"\n\n    class Meta(object):\n        \"\"\"Metadata options.\"\"\"\n\n        model = Warehouse\n        fields = ('backend', 'name', 'collections', 'url', 'id')\n\n\nclass CollectionSerializer(serializers.HyperlinkedModelSerializer):\n    \"\"\"Serializer for a |Collection| object.\"\"\"\n\n    class Meta(object):\n        \"\"\"Metadata options.\"\"\"\n\n        model = Collection\n        fields = ('url', 'name', 'warehouse', 'id')\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, 1, 1, 1], "name": "warehouses/views.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines views for |Warehouses| and |Collections|.\n\n===========================  ==========================================\nClass                        Description\n===========================  ==========================================\n:class:`~CollectionFilter`   Filters views of |Collections|.\n:class:`~CollectionViewSet`  REST API views for |Collections|.\n:class:`~WarehouseViewSet`   REST API views for |Warehouses|.\n===========================  ==========================================\n\n\"\"\"\n\n# third party\nimport django_filters\nfrom rest_framework import viewsets\n\n# local\nfrom warehouses.models import Collection, Warehouse\nfrom warehouses.serializers import CollectionSerializer, WarehouseSerializer\n\n\nclass WarehouseViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"REST API views for |Warehouses|.\"\"\"\n\n    queryset = Warehouse.objects.all()\n    serializer_class = WarehouseSerializer\n\n\nclass CollectionFilter(django_filters.FilterSet):\n    \"\"\"Filter |Collections| by |Warehouse|.\n\n    Filters REST API views of |Collections| using Django Filter's\n    `FilterSet`_.\n    \"\"\"\n\n    warehouse = django_filters.ModelMultipleChoiceFilter(\n        name='warehouse',\n        queryset=Warehouse.objects.all()\n    )\n\n    class Meta(object):\n        \"\"\"Metadata options.\"\"\"\n\n        model = Collection\n        fields = ['warehouse']\n\n\nclass CollectionViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"REST API views for Collections.\"\"\"\n\n    queryset = Collection.objects.all()\n    serializer_class = CollectionSerializer\n    filter_class = CollectionFilter\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1], "name": "watchdogs/__init__.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\ndefault_app_config = 'watchdogs.apps.WatchdogsConfig'\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, 1, 1, null, null, 1, 1, 1, 1, null, null, 1, null, null, null, 1, 1, 1, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, 1, null, null, null, 1, null, null, 1, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, 1, 1, null, 1, 1, 1, 1, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, 1, 1, null], "name": "watchdogs/admin.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines ModelAdmins for Watchdogs and Triggers, and registers\nthem with Django Admin.\n\"\"\"\n\n# third party\nfrom django.contrib import admin\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom cyphon.admin import ConfigToolAdmin, CONFIG_TOOL_CLASSES\nfrom cyphon.forms import CONFIG_TOOL_INPUTS\nfrom .models import Watchdog, Trigger, Muzzle\nfrom .forms import TriggerForm, TriggerInlineForm, WatchdogForm\n\n\nclass TriggerInLineAdmin(admin.TabularInline):\n    \"\"\"\n    Customizes admin inline tables for Triggers.\n    \"\"\"\n    model = Trigger\n    show_change_link = True\n    form = TriggerInlineForm\n    extra = 0\n\n\nclass TriggerAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Triggers.\n    \"\"\"\n    list_display = [\n        'watchdog',\n        'sieve',\n        'alert_level',\n        'rank',\n    ]\n    list_editable = [\n        'alert_level',\n        'rank',\n    ]\n    form = TriggerForm\n\n\nclass MuzzleAdmin(admin.ModelAdmin):\n    \"\"\"\n    Customizes admin pages for Muzzles.\n    \"\"\"\n    list_display = [\n        'watchdog',\n        'enabled',\n        'matching_fields',\n        'time_interval',\n        'time_unit',\n    ]\n    list_editable = [\n        'time_interval',\n        'time_unit',\n    ]\n    fieldsets = (\n        (None, {\n            'description': _('Use a Muzzle to prevent a Watchdog from '\n                             'generating duplicate Alerts.'),\n            'fields': [\n                'watchdog',\n                'matching_fields',\n                'time_interval',\n                'time_unit',\n                'enabled',\n            ]\n        }),\n    )\n\n\nclass WatchdogAdmin(ConfigToolAdmin):\n    \"\"\"\n    Customizes admin pages for Inspections.\n    \"\"\"\n    model_method = 'inspect'\n    test_data_format = 'json'\n\n    list_display = ['name', 'enabled', ]\n    inlines = [TriggerInLineAdmin, ]\n    save_as = True\n    form = WatchdogForm\n    fieldsets = (\n        ('Test this watchdog', {\n            'classes': CONFIG_TOOL_CLASSES,\n            'description': _('Enter a JSON string and click \"Run test\" '\n                             'to check how the data will be classified.'),\n            'fields': CONFIG_TOOL_INPUTS,\n        }),\n        (None, {\n            'fields': [\n                'name',\n                'enabled',\n                'categories',\n                'groups',\n            ]\n        }),\n    )\n\n\nadmin.site.register(Trigger, TriggerAdmin)\nadmin.site.register(Muzzle, MuzzleAdmin)\nadmin.site.register(Watchdog, WatchdogAdmin)\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, 1, 1, null, 1, null, null, null, 1, null], "name": "watchdogs/apps.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n\"\"\"\n\n# third party\nfrom django.apps import AppConfig\n\n\nclass WatchdogsConfig(AppConfig):\n    \"\"\"\n\n    \"\"\"\n    name = 'watchdogs'\n    verbose_name = 'Watchdogs'\n\n    def ready(self):\n        \"\"\"\n\n        \"\"\"\n        import watchdogs.signals\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, null, 1, 1, 1, null, null, 1, null, null, null, null, 1, 1, null], "name": "watchdogs/forms.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines forms for Watchdogs.\n\"\"\"\n\n# third party\nfrom django import forms\n\n# local\nfrom cyphon.forms import ConfigToolForm\nfrom .models import Trigger, Watchdog\n\n\nclass TriggerForm(forms.ModelForm):\n    \"\"\"\n    Defines a form for adding or updating a Trigger.\n    \"\"\"\n\n    class Meta:\n        model = Trigger\n        exclude = []\n\n\nclass TriggerInlineForm(forms.ModelForm):\n    \"\"\"\n    Defines an inline form for adding or updating a Trigger.\n    \"\"\"\n\n    class Meta:\n        model = Trigger\n        exclude = []\n\n\nclass WatchdogForm(ConfigToolForm):\n    \"\"\"\n    Defines a form for adding or updating a Watchdog.\n    \"\"\"\n\n    class Meta(ConfigToolForm.Meta):\n        model = Watchdog\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, null, null, 1, 1, 1, 1, 1, null, null, 1, 1, 1, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, 1, null, null, null, 1, 1, 1, null, null, 1, 1, null, 1, 1, null, 1, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, null, null, null, 1, null, 1, 1, null, 1, null, null, null, null, 1, 1, null, 1, null, 1, null, null, null, null, 1, null, null, null, null, null, null, 1, 1, null, null, null, null, 1, 1, 1, null, 1, null, null, null, null, null, 1, 1, 1, 1, null, 1, null, null, null, null, null, null, 1, 1, 1, 1, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, 1, null, null, null, null, null, null, 1, null, 1, 1, 1, null, 1, 1, 1, null, 1, 1, null, 1, null, null, null, null, 1, null, null, 1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, 1, null, null, null, null, null, 1, null, null, null, 1, null, null, null, null, 1, null, 1, 1, null, 1, null, null, null, null, 1, 1, null, 1, 1, 1, 1, null, 1, null, 1, null, null, null, null, 1, null, 1, null, 1, null, null, null, null, null, 1, 1, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, 1, null, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, null, 1, null], "name": "watchdogs/models.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines Watchdog, Trigger, and Muzzle classes for generating Alerts.\n\"\"\"\n\n# standard library\nimport datetime\n\n# third party\nfrom django.core.exceptions import ObjectDoesNotExist\nfrom django.db import models\nfrom django.db import transaction\nfrom django.utils import timezone\nfrom django.utils.translation import ugettext_lazy as _\n\n# local\nfrom alarms.models import Alarm, AlarmManager\nfrom alerts.models import Alert\nfrom categories.models import Category\nfrom cyphon.choices import ALERT_LEVEL_CHOICES, TIME_UNIT_CHOICES\nfrom cyphon.models import GetByNameManager\nfrom cyphon.transaction import require_lock\nfrom utils.dateutils.dateutils import convert_time_to_whole_minutes\nfrom sifter.datasifter.datasieves.models import DataSieve\n\n\nclass WatchdogManager(AlarmManager):\n    \"\"\"\n    Adds methods to the default model manager.\n    \"\"\"\n\n    def find_relevant(self, distillery):\n        \"\"\"\n\n        \"\"\"\n        enabled_watchdogs = super(WatchdogManager, self).find_enabled()\n        categories = distillery.categories.all()\n        queryset = enabled_watchdogs.annotate(\n            categories_cnt=models.Count('categories')\n        )\n        no_categories_q = models.Q(categories_cnt=0)\n        shared_categories_q = models.Q(categories__in=categories)\n\n        if categories:\n            queryset = queryset.filter(no_categories_q | shared_categories_q)\n        else:\n            queryset = queryset.filter(no_categories_q)\n\n        return queryset.distinct()\n\n\nclass Watchdog(Alarm):\n    \"\"\"\n    Defines a class for inspecting data produced by a Distillery. Used\n    to create Alerts when appropriate.\n\n    Attributes\n    ----------\n    name : str\n        A |str| representing the name of the Watchdog.\n\n    enabled : bool\n        A |bool| indicating whether the Watchdog is active.\n\n    categories : `QuerySet` of `Categories`\n\n    groups : `QuerySet` of `Groups`\n\n    \"\"\"\n    categories = models.ManyToManyField(\n        Category,\n        related_name='watchdogs',\n        related_query_name='watchdog',\n        blank=True,\n        help_text=_('Restrict coverage to Distilleries with these Categories. '\n                    'If no Categories are selected, all Distilleries will '\n                    'be covered.')\n    )\n\n    objects = WatchdogManager()\n\n    def __str__(self):\n        return self.name\n\n    def _is_muzzled(self, alert):\n        \"\"\"\n        Takes an Alert and returns True if it should be suppressed.\n        Otherwise, returns False.\n        \"\"\"\n        if hasattr(self, 'muzzle') and self.muzzle.enabled:\n            return self.muzzle.is_match(alert)\n        else:\n            return False\n\n    def _create_alert(self, level, distillery, doc_id):\n        \"\"\"\n        Takes an alert level, a distillery, and a document id. Returns\n        an Alert object.\n        \"\"\"\n        return Alert(\n            level=level,\n            alarm=self,\n            distillery=distillery,\n            doc_id=doc_id,\n        )\n\n    @transaction.atomic\n    @require_lock(Alert, 'ACCESS EXCLUSIVE')\n    def _process_alert(self, alert):\n        \"\"\"\n\n        \"\"\"\n        if not self._is_muzzled(alert):\n            alert.save()\n            return alert\n\n    def inspect(self, data):\n        \"\"\"\n        Takes a data dictionary and returns the alert_level of the first\n        Trigger that matches the data. If the data matches no Triggers,\n        returns None.\n        \"\"\"\n        triggers = self.triggers.all()\n        for trigger in triggers:\n            if trigger.is_match(data):\n                return trigger.alert_level\n\n    def process(self, data, distillery, doc_id):\n        \"\"\"\n        Takes a dictionary of data, a distillery, and a document id.\n        If the Watchdog is enabled, inspects the data and generates an\n        Alert if necessary. If the Watchdog is disabled or an Alert is\n        not warranted, returns None.\n        \"\"\"\n        if self.enabled:\n            alert_level = self.inspect(data)\n            if alert_level is not None:\n                alert = self._create_alert(alert_level, distillery, doc_id)\n                return self._process_alert(alert)\n\n\nclass Trigger(models.Model):\n    \"\"\"\n    Defines conditions under which a |Watchdog| will generate an |Alert|.\n\n    Attributes\n    ----------\n    watchdog : Watchdog\n        The |Watchdog| associated with the Trigger.\n\n    sieve : DataSieve\n        A |DataSieve| for examining data.\n\n    alert_level : str\n        A |str| representing an |Alert| level to be returned if the\n        Trigger's sieve returns ``True`` for the data examined. Options are\n        constrained to |ALERT_LEVEL_CHOICES|.\n\n    rank : int\n        An |int| representing the order of the Trigger in a |Watchdog|\n        inspection. Triggers are evaluated in ascending order (the lowest\n        rank first)\n\n    \"\"\"\n    watchdog = models.ForeignKey(\n        Watchdog,\n        related_name='triggers',\n        related_query_name='trigger',\n        verbose_name=_('watchdog'),\n        help_text=_('The Watchdog with which this trigger is associated.')\n    )\n    sieve = models.ForeignKey(\n        DataSieve,\n        related_name='sieves',\n        related_query_name='sieve',\n        help_text=_('The DataSieve used to inspect the data during this step.')\n    )\n    alert_level = models.CharField(\n        max_length=255,\n        choices=ALERT_LEVEL_CHOICES,\n        help_text=_('The Alert level to be returned if the DataSieve returns True '\n                    'for the data examined.')\n    )\n    rank = models.IntegerField(\n        default=0,\n        help_text=_('An integer representing the order of this step in the '\n                    'Inspection. Steps are performed in ascending order, '\n                    'with the lowest number examined first.')\n    )\n\n    objects = GetByNameManager()\n\n    class Meta:\n        ordering = ['rank']\n        unique_together = [('watchdog', 'sieve'), ('watchdog', 'rank')]\n\n    def __str__(self):\n        try:\n            return '%s <- %s (rank: %s)' % \\\n                   (self.sieve, self.alert_level, self.rank)\n        except ObjectDoesNotExist:\n            return super(Trigger, self).__str__()\n\n    def is_match(self, data):\n        \"\"\"\n        Takes a data dictionary and returns a Boolean indicating whether\n        it matches the Trigger's DataSieve.\n        \"\"\"\n        return self.sieve.is_match(data)\n\n\nclass Muzzle(models.Model):\n    \"\"\"\n    Defines parameters for throttling the rate at which a |Watchdog|\n    generates |Alerts|.\n\n    Attributes\n    ----------\n    watchdog : Watchdog\n        The |Watchdog| to be muzzled.\n\n    matching_fields : str\n        A comma-separated string of field names. Defines fields in an\n        Alert's |Alert.data| whose values should be used to identify duplicate\n        |Alerts|.\n\n    time_interval : int\n        A positive |int| that defines the length of time within which\n        generation of duplicate |Alerts| should be supressed.\n\n    time_unit : str\n        The time units for the ``time_interval``. Options are\n        constrained to |TIME_UNIT_CHOICES|.\n\n    enabled : bool\n        A |bool| indicating whether the Muzzle is enabled.\n\n    \"\"\"\n    watchdog = models.OneToOneField(Watchdog, primary_key=True,\n                                    help_text=_('The Watchdog to be muzzled.'))\n    matching_fields = models.CharField(\n        max_length=255,\n        help_text=_('A comma-separated string of field names. Defines '\n                    'data fields whose values should be used to identify '\n                    'duplicate Alerts.')\n    )\n    time_interval = models.PositiveIntegerField(\n        help_text=_('The length of time within which generation of '\n                    'duplicate Alerts should be supressed.')\n    )\n    time_unit = models.CharField(\n        max_length=3,\n        choices=TIME_UNIT_CHOICES,\n        help_text=_('The units of the time interval.')\n    )\n    enabled = models.BooleanField(default=True)\n\n    def __str__(self):\n        return str(self.watchdog)\n\n    def _get_fields(self):\n        \"\"\"\n        Returns a list of field names created from the Muzzle's\n        matching_fields.\n        \"\"\"\n        fields = self.matching_fields.split(',')\n        cleaned_fields = []\n\n        for field in fields:\n            cleaned_field = field.strip()\n            if cleaned_field != '':\n                cleaned_fields.append(cleaned_field)\n\n        return cleaned_fields\n\n    def _get_start_time(self):\n        \"\"\"\n        Returns a DateTime object equal to the current time minus the\n        Muzzle's time_interval.\n        \"\"\"\n        minutes = convert_time_to_whole_minutes(self.time_interval,\n                                                self.time_unit)\n        return timezone.now() - datetime.timedelta(minutes=minutes)\n\n    def _get_filtered_alerts(self, alert):\n        \"\"\"\n        Takes an Alert and returns a queryset of Alerts with the same\n        level and distillery that were generated within the Muzzle's\n        time frame.\n        \"\"\"\n        time = self._get_start_time()\n        return Alert.objects.filter(\n            created_date__gte=time,\n            level=alert.level,\n            distillery=alert.distillery,\n            alarm_type=alert.alarm_type,\n            alarm_id=alert.alarm_id\n        ).order_by('created_date')\n\n    def is_match(self, alert):\n        \"\"\"\n        Takes an Alert and returns a Boolean indicating whether the\n        Alert duplicates a previous Alert within the Muzzle's time frame.\n        \"\"\"\n        fields = self._get_fields()\n        alerts = self._get_filtered_alerts(alert)\n        new_data = alert.saved_data\n\n        for old_alert in alerts:\n            match = True\n            old_data = old_alert.data\n            for field in fields:\n                if new_data.get(field) != old_data.get(field):\n                    match = False\n                    break\n            if match:\n                old_alert.add_incident()\n                return True\n\n        return False\n\n"}, {"coverage": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 1, null, null, null, null, 1, 1, null, null, 1, 1, null, null, 1, null, null, null, null, null, 1, null, 1, 1, null, 1], "name": "watchdogs/signals.py", "source": "# -*- coding: utf-8 -*-\n# Copyright 2017 Dunbar Security Solutions, Inc.\n#\n# This file is part of Cyphon Engine.\n#\n# Cyphon Engine is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, version 3 of the License.\n#\n# Cyphon Engine is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Cyphon Engine. If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nDefines a reciever for the Distillery app's document_saved signal.\n\"\"\"\n\n# third party\nfrom django.db import close_old_connections\nfrom django.dispatch import receiver\n\n# local\nfrom distilleries.signals import document_saved\nfrom watchdogs.models import Watchdog\n\n\n@receiver(document_saved)\ndef inspect_document(sender, doc, distillery, doc_id, **args):\n    \"\"\"\n    Receiver for the Distillery app's document_saved signal. Gathers all\n    Watchdogs to inspect the newly saved document and create Alerts if necessary.\n    \"\"\"\n    watchdogs = Watchdog.objects.find_relevant(distillery)\n\n    for watchdog in watchdogs:\n        watchdog.process(doc, distillery, doc_id)\n\n    close_old_connections()\n"}], "git": {"remotes": [{"url": "https://github.com/dunbarcyber/cyphon.git", "name": "origin"}], "branch": "master", "head": {"committer_name": "lhadjchikh", "author_email": "leila.hadj-chikh@dunbarsecured.com", "id": "fd5e5ff5fdee8db46bd87ecc793abbb1f1a941c0", "committer_email": "leila.hadj-chikh@dunbarsecured.com", "message": "output coveralls report to file", "author_name": "lhadjchikh"}}, "service_name": "coveralls-python"}